<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java 响应式编程-WebFlux基础</title>
    <link href="/2025/08/21/java-%E5%93%8D%E5%BA%94%E5%BC%8F-WebFlux%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/08/21/java-%E5%93%8D%E5%BA%94%E5%BC%8F-WebFlux%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Spring WebFlux 是 Spring 5 中引入的响应式编程框架，其核心概念围绕着构建异步、非阻塞、事件驱动的服务。WebFlux 的基石是实现了 Reactive Streams 规范。该规范定义了四个核心接口：</p><ul><li>Publisher: 发布者，负责发布一系列数据（Mono 和 Flux 是其具体实现）。</li><li>Subscriber: 订阅者，消费发布者发出的数据。</li><li>Subscription: 订阅关系，在发布者和订阅者之间传递，用于管理流（例如，控制背压）。</li><li>Processor: 处理器，兼具 Subscriber 和 Publisher 的能力。</li></ul><span id="more"></span><p>WebFlux 默认并深度集成了 <a href="https://ares081.github.io/2025/08/19/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80/">Project Reactor</a> 作为其响应式编程库。它提供了两个主要的、实现了 Publisher 接口的具体类型：</p><ul><li>Mono<T>: 表示包含 0 个或 1 个元素（即异步结果）的响应式序列。常用于返回单个对象、空值或错误。</li><li>Flux<T>: 表示包含 0 到 N 个元素的响应式序列。常用于返回列表、数据流或无限序列。</li></ul><p>与传统的每个请求分配一个线程的阻塞式 Servlet 容器（如 Tomcat）不同，WebFlux 运行在支持异步非阻塞 I&#x2F;O 的服务器上:</p><ul><li>Netty (默认和首选)</li><li>Undertow(spring-boot4移除了对其支持)</li><li>支持非阻塞模式的 Tomcat 或 Jetty</li></ul><p>这些容器使用 <strong>事件循环线程（Event Loop Threads）</strong> 来处理大量并发连接，提高了资源利用率和可扩展性。WebFlux 提供了两种风格的 API 来定义 HTTP 端点：</p><ul><li><strong>基于注解的控制器 (Annotated Controllers)</strong>: 类似于 Spring MVC 的 @Controller, @GetMapping 等注解，对于熟悉 Spring MVC 的开发者来说迁移成本很低。</li><li><strong>函数式端点 (Functional Endpoints &#x2F; RouterFunctions)</strong>: 采用函数式编程风格，使用 RouterFunctions 配置路由，使用 HandlerFunctions 处理请求和生成响应。这种模型更轻量级，完全脱离了注解和 Spring MVC 的基础设施。</li></ul><h3 id="与Spring-MVC差异"><a href="#与Spring-MVC差异" class="headerlink" title="与Spring MVC差异"></a>与Spring MVC差异</h3><p>Spring WebFlux和Spring MVC都是Spring框架中的Web模块，但它们之间有着显著的差异，主要体现在编程模型、处理方式、性能和适用场景等方面。</p><table><thead><tr><th><strong>特性</strong></th><th><strong>Spring MVC</strong></th><th><strong>Spring WebFlux</strong></th></tr></thead><tbody><tr><td><strong>核心分发器</strong></td><td><code>DispatcherServlet</code></td><td><code>DispatcherHandler</code></td></tr><tr><td><strong>核心对象</strong></td><td><code>HttpServletRequest</code> (Servlet API)</td><td><code>ServerWebExchange</code> (非 Servlet)</td></tr><tr><td><strong>IO 模型</strong></td><td>阻塞式 IO (Blocking)</td><td>非阻塞式 IO (Non-Blocking)</td></tr><tr><td><strong>线程模型</strong></td><td>每个请求一个线程 (Thread-per-Request)</td><td>事件循环 (Event Loop)，少量线程处理高并发</td></tr><tr><td><strong>返回值</strong></td><td>对象直接返回</td><td>通常返回 <code>Mono</code> 或 <code>Flux</code></td></tr></tbody></table><h2 id="SpringBoot-WebFlux使用"><a href="#SpringBoot-WebFlux使用" class="headerlink" title="SpringBoot WebFlux使用"></a>SpringBoot WebFlux使用</h2><p>跟 Spring Boot 大框架一样，Spring Boot Webflux 提供了很多 “开箱即用” 的 Starter 组件。因此在SpringBoot使用只需要引入对应starter依赖即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-webflux<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring-boot-start.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-comment"><!--mysql的reactive实现--></span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-r2dbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring-boot-start.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="实现请求处理器ProductService"><a href="#实现请求处理器ProductService" class="headerlink" title="实现请求处理器ProductService:"></a>实现请求处理器ProductService:</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductService</span> &#123;<br>  <span class="hljs-comment">// 使用一个线程安全的 Map 模拟内存数据库</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ProductRepository productRepository;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ProductService</span><span class="hljs-params">(ProductRepository productRepository)</span> &#123;<br>    <span class="hljs-built_in">this</span>.productRepository = productRepository<br>  &#125;<br><br>  <span class="hljs-comment">// 处理 GET /products 请求：返回所有产品列表</span><br>  <span class="hljs-keyword">public</span> Mono&lt;ServerResponse&gt; <span class="hljs-title function_">listProducts</span><span class="hljs-params">()</span> &#123;<br>    Flux&lt;Product&gt; products = productRepository.findAll();<br>    <br>    <span class="hljs-comment">// 使用 ServerResponse.ok().body(...) 构建响应</span><br>    <span class="hljs-keyword">return</span> ServerResponse.ok()<br>            .contentType(MediaType.APPLICATION_JSON)<br>            .body(products, Product.class); <span class="hljs-comment">// 返回 Flux&lt;Product&gt;</span><br>  &#125;<br><br>  <span class="hljs-comment">// 处理 GET /products/&#123;id&#125; 请求：根据 ID 返回单个产品</span><br>  <span class="hljs-keyword">public</span> Mono&lt;ServerResponse&gt; <span class="hljs-title function_">getProductById</span><span class="hljs-params">(ServerRequest request)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">productId</span> <span class="hljs-operator">=</span> request.pathVariable(<span class="hljs-string">&quot;id&quot;</span>);<br>    Mono&lt;Product&gt; productMono = productRepository.findById(productId);<br><br>    <span class="hljs-comment">// 如果找到产品，返回 200 OK；否则返回 404 Not Found</span><br>    <span class="hljs-keyword">return</span> productMono.flatMap(product -&gt; ServerResponse.ok()<br>                      .contentType(MediaType.APPLICATION_JSON)<br>                      .bodyValue(product)) <span class="hljs-comment">// 返回 Mono&lt;Product&gt;</span><br>                      .switchIfEmpty(ServerResponse.notFound().build());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Repository:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ProductRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReactiveCrudRepository</span>&lt;ProductEntity, Integer&gt; &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>定义Product领域模型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@Setter</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductEntity</span> &#123;<br>  <span class="hljs-keyword">private</span> String id;<br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-keyword">private</span> BigDecimal price;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="基于函数式端点，定义路由配置-ProductRouter"><a href="#基于函数式端点，定义路由配置-ProductRouter" class="headerlink" title="基于函数式端点，定义路由配置 (ProductRouter):"></a>基于函数式端点，定义路由配置 (ProductRouter):</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductRouter</span> &#123;<br><br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-keyword">public</span> RouterFunction&lt;ServerResponse&gt; <span class="hljs-title function_">routeProduct</span><span class="hljs-params">(ProductService handler)</span> &#123;<br>    <span class="hljs-keyword">return</span> RouterFunctions<br>            .route(GET(<span class="hljs-string">&quot;/products&quot;</span>).and(accept(MediaType.APPLICATION_JSON)), handler::listProducts)<br>            .andRoute(GET(<span class="hljs-string">&quot;/products/&#123;id&#125;&quot;</span>).and(accept(MediaType.APPLICATION_JSON)), handler::getProductById);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="基于注解的控制器："><a href="#基于注解的控制器：" class="headerlink" title="基于注解的控制器："></a>基于注解的控制器：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@RestController(&quot;/product&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductController</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ProductService productService；<br>  <span class="hljs-meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br>  <span class="hljs-keyword">public</span> Mono&lt;ServerResponse&gt; <span class="hljs-title function_">getProductById</span><span class="hljs-params">(ServerRequest request)</span>&#123;<br>    <span class="hljs-keyword">return</span> productService.getProductById(request);<br>  &#125;<br><br>  <span class="hljs-meta">@GetMapping</span><br>  <span class="hljs-keyword">public</span> Mono&lt;ServerResponse&gt; <span class="hljs-title function_">listProducts</span><span class="hljs-params">(ServerRequest request)</span> &#123;<br>    <span class="hljs-keyword">return</span> productService.listProducts(request);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="全局异常处理"><a href="#全局异常处理" class="headerlink" title="全局异常处理"></a>全局异常处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestControllerAdvice</span><br><span class="hljs-meta">@Order(Ordered.HIGHEST_PRECEDENCE + 1)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GlobalExceptionHandler</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(<br>      GlobalExceptionHandler.class<br>  );<br><br>  <span class="hljs-meta">@ExceptionHandler(BaseException.class)</span><br>  <span class="hljs-keyword">public</span> Mono&lt;ResponseEntity&lt;Response&lt;?&gt;&gt;&gt; handleBusinessException(BaseException ex) &#123;<br>    logger.info(<span class="hljs-string">&quot;Business exception: &#123;&#125;&quot;</span>, ex.getMessage());<br>    <span class="hljs-keyword">return</span> Mono.just(ResponseEntity.ok(Response.failed(ex.getCode(), ex.getMessage())));<br>  &#125;<br><br>  <span class="hljs-meta">@ExceptionHandler(IllegalArgumentException.class)</span><br>  <span class="hljs-keyword">public</span> Mono&lt;ResponseEntity&lt;Response&lt;?&gt;&gt;&gt; handleIllegalArgumentException(<br>      IllegalArgumentException ex<br>  ) &#123;<br>    logger.info(<span class="hljs-string">&quot;Validation error: &#123;&#125;&quot;</span>, ex.getMessage());<br>    <span class="hljs-keyword">return</span> Mono.just(ResponseEntity.ok(<br>            Response.failed(<br>                BaseErrorCode.PARAM_ERROR.getCode(),<br>                BaseErrorCode.PARAM_ERROR.getMsg()<br>            )<br>        )<br>    );<br>  &#125;<br><br>  <span class="hljs-meta">@ExceptionHandler(Exception.class)</span><br>  <span class="hljs-keyword">public</span> Mono&lt;ResponseEntity&lt;Response&lt;?&gt;&gt;&gt; handleGenericException(<br>      Exception ex<br>  ) &#123;<br>    logger.error(<span class="hljs-string">&quot;Unexpected error, msg: &#123;&#125;, ex: &#123;&#125;&quot;</span>, ex.getMessage(), ex.getCause());<br>    <span class="hljs-keyword">return</span> Mono.just(ResponseEntity.ok(<br>            Response.failed(<br>                BaseErrorCode.UNKOWN_ERROR.getCode(),<br>                BaseErrorCode.UNKOWN_ERROR.getMsg()<br>            )<br>        )<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="基于注解控制器webflux请求处理流程"><a href="#基于注解控制器webflux请求处理流程" class="headerlink" title="基于注解控制器webflux请求处理流程"></a>基于注解控制器webflux请求处理流程</h2><p>与 Spring MVC 的 DispatcherServlet 类似，Spring WebFlux 的核心分发器是 DispatcherHandler，但其底层完全基于 Reactive Streams（反应式流），实现了非阻塞的异步处理。</p><p><img src="/images/java-%E5%93%8D%E5%BA%94%E5%BC%8F-WebFlux%E5%9F%BA%E7%A1%80_%E5%9F%BA%E4%BA%8E%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E6%97%B6%E5%BA%8F%E5%9B%BE.png"></p><p>WebFlux 基于注解的基本流程主要由 <strong>DispatcherHandler</strong> 协调，分为以下几个关键阶段：<font color=green>Request -&gt; DispatcherHandler -&gt; 查找 Mapping -&gt; 适配 Adapter -&gt; 执行 Controller -&gt; 处理 Result -&gt; Response</font>。</p><p><strong>第一阶段：请求接入与适配 (Request Entry)</strong>。底层接入由Netty（默认容器）接收 TCP 连接。底层的请求适配为 ServerWebExchange，这是 WebFlux 的核心交换对象，包含 ServerHttpRequest (非阻塞) 和 ServerHttpResponse。然后请求通过 WebFilter 链（如安全认证、CORS 处理），最后到达 DispatcherHandler。</p><p><strong>第二阶段：寻找处理器 (Handler Mapping)</strong>。DispatcherHandler 调用 getHandler(exchange)，它会遍历所有注册的 HandlerMapping，对于注解控制器，最重要的是 RequestMappingHandlerMapping。其核心是根据 @RequestMapping、@GetMapping 配置的路径，找到对应的 Controller 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DispatcherHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebHandler</span>, PreFlightRequestHandler, ApplicationContextAware &#123;<br><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">private</span> List&lt;HandlerMapping&gt; handlerMappings;<br><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">private</span> List&lt;HandlerAdapter&gt; handlerAdapters;<br><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">private</span> List&lt;HandlerResultHandler&gt; resultHandlers;<br><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initStrategies</span><span class="hljs-params">(ApplicationContext context)</span> &#123;<br><br>    <span class="hljs-comment">//获取HandlerMapping及其子类型的bean</span><br>    <span class="hljs-comment">//HandlerMapping根据请求request获取handler执行链</span><br>Map&lt;String, HandlerMapping&gt; mappingBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(<br>context, HandlerMapping.class, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br><br>ArrayList&lt;HandlerMapping&gt; mappings = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(mappingBeans.values());<br>AnnotationAwareOrderComparator.sort(mappings);<br><span class="hljs-built_in">this</span>.handlerMappings = Collections.unmodifiableList(mappings);<br>    <span class="hljs-comment">//获取HandlerAdapter及其子类型的bean</span><br>Map&lt;String, HandlerAdapter&gt; adapterBeans = BeanFactoryUtils.beansOfTypeIncludingAncestors(<br>context, HandlerAdapter.class, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br><br><span class="hljs-built_in">this</span>.handlerAdapters = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(adapterBeans.values());<br>AnnotationAwareOrderComparator.sort(<span class="hljs-built_in">this</span>.handlerAdapters);<br>    <span class="hljs-comment">//获取HandlerResultHandler及其子类型的bean</span><br>Map&lt;String, HandlerResultHandler&gt; beans = BeanFactoryUtils.beansOfTypeIncludingAncestors(<br>context, HandlerResultHandler.class, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br><br><span class="hljs-built_in">this</span>.resultHandlers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(beans.values());<br>AnnotationAwareOrderComparator.sort(<span class="hljs-built_in">this</span>.resultHandlers);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RouterFunctionMapping</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractHandlerMapping</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitializingBean</span> &#123;<br><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">private</span> RouterFunction&lt;?&gt; routerFunction;<br><br>  <span class="hljs-comment">//afterPropertiesSet()方法 是组件初始化后回调 必须实现InitializingBean接口</span><br>  <span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-keyword">if</span> (CollectionUtils.isEmpty(<span class="hljs-built_in">this</span>.messageReaders)) &#123;<br><span class="hljs-type">ServerCodecConfigurer</span> <span class="hljs-variable">codecConfigurer</span> <span class="hljs-operator">=</span> ServerCodecConfigurer.create();<br><span class="hljs-built_in">this</span>.messageReaders = codecConfigurer.getReaders();<br>&#125;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.routerFunction == <span class="hljs-literal">null</span>) &#123;<br>initRouterFunctions();<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.routerFunction != <span class="hljs-literal">null</span>) &#123;<br>RouterFunctions.changeParser(<span class="hljs-built_in">this</span>.routerFunction, getPathPatternParser());<br>&#125;<br>&#125;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Initialized the router functions by detecting them in the application context.</span><br><span class="hljs-comment">    * 从应用上下文中查找他们并初始化路由方法</span><br><span class="hljs-comment">    */</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initRouterFunctions</span><span class="hljs-params">()</span> &#123;<br>List&lt;RouterFunction&lt;?&gt;&gt; routerFunctions = routerFunctions();<br><span class="hljs-built_in">this</span>.routerFunction = routerFunctions.stream().reduce(RouterFunction::andOther).orElse(<span class="hljs-literal">null</span>);<br>logRouterFunctions(routerFunctions);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第三阶段：请求适配与执行 (Handler Adapter)</strong>。DispatcherHandler 获取到 Handler 后，寻找支持该 Handler 的适配器，通常是 RequestMappingHandlerAdapter。适配器解析 Controller 方法的参数（如 @RequestBody, @PathVariable），@RequestBody 的读取也是非阻塞的（基于 Reactor Flux&#x2F;Mono）。然后反射调用 Controller 的方法。Controller 返回 <code>Mono&lt;T&gt; </code>或 <code>Flux&lt;T&gt;</code>，适配器将其封装为 HandlerResult 返回给 Dispatcher。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Mono&lt;Void&gt; <span class="hljs-title function_">handle</span><span class="hljs-params">(ServerWebExchange exchange)</span> &#123;<br>  <span class="hljs-comment">//handlerMappings在initStrategies()方法中已经构造好了</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.handlerMappings == <span class="hljs-literal">null</span>) &#123;<br>  <span class="hljs-keyword">return</span> createNotFoundError();<br>  &#125;<br>  <span class="hljs-comment">//构造Flux，数据源为handlerMappings集合</span><br>  <span class="hljs-keyword">return</span> Flux.fromIterable(<span class="hljs-built_in">this</span>.handlerMappings)<br>  <span class="hljs-comment">//获取Mono&lt;Handler&gt;对象，通过concatMap保证顺序和handlerMappings顺序一致</span><br>  <span class="hljs-comment">//严格保证顺序是因为在一个系统中可能存在一个Url有多个能够处理的HandlerMapping的情况</span><br>  .concatMap(mapping -&gt; mapping.getHandler(exchange))<br>  .next()<br>  <span class="hljs-comment">//如果next()娶不到值则抛出错误</span><br>  .switchIfEmpty(createNotFoundError())<br>  <span class="hljs-comment">//触发HandlerApter的handle方法</span><br>  .flatMap(handler -&gt; invokeHandler(exchange, handler))<br>  <span class="hljs-comment">//触发HandlerResultHandler 的handleResult方法</span><br>  .flatMap(result -&gt; handleResult(exchange, result));<br>&#125;<br><br><span class="hljs-keyword">private</span> Mono&lt;Void&gt; <span class="hljs-title function_">handleResult</span><span class="hljs-params">(ServerWebExchange exchange, HandlerResult result)</span> &#123;<br>  <span class="hljs-keyword">return</span> getResultHandler(result).handleResult(exchange, result)<br>          .onErrorResume(ex -&gt; result.applyExceptionHandler(ex).flatMap(exceptionResult -&gt;<br>                  getResultHandler(exceptionResult).handleResult(exchange, exceptionResult)));<br>&#125;<br> <br><span class="hljs-keyword">private</span> HandlerResultHandler <span class="hljs-title function_">getResultHandler</span><span class="hljs-params">(HandlerResult handlerResult)</span> &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.resultHandlers != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">for</span> (HandlerResultHandler resultHandler : <span class="hljs-built_in">this</span>.resultHandlers) &#123;<br>          <span class="hljs-keyword">if</span> (resultHandler.supports(handlerResult)) &#123;<br>              <span class="hljs-keyword">return</span> resultHandler;<br>          &#125;<br>      &#125;<br>  &#125;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;No HandlerResultHandler for &quot;</span> + handlerResult.getReturnValue());<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>第四阶段：响应结果处理 (Result Handling)</strong>。DispatcherHandler 拿到 HandlerResult，遍历 HandlerResultHandler 列表。对于数据处理使用的是ResponseBodyResultHandler，ResponseBodyResultHandler用于处理 @ResponseBody 或 @RestController，它利用 HttpMessageWriter 将对象序列化为 JSON&#x2F;XML。对于视图处理使用ViewResolutionResultHandler，即处理返回视图名称的场景（SSR 渲染）。</p><p><strong>第五阶段：订阅与触发 (Subscription)</strong>。在 Reactive 编程中，”Nothing happens until you subscribe”。上述所有步骤实际上是在构建一个 Reactor 的调用链（Pipeline）。只有当 Netty 服务器最终订阅（Subscribe）了这个处理链的 Publisher 时，数据才会真正开始流动，响应才会发送给客户端。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>WebFlux 的注解处理流程在表面上与 Spring MVC 非常相似，但在底层实现上完全不同。它摒弃了 Servlet API，使用 Reactor 库构建了一个从 Socket 读取到业务处理再到 Socket 写入的全异步链路。在实际应用中，如果对性能要求较高，特别是在并发量大、I&#x2F;O密集的场景下，WebFlux是一个更好的选择。但如果是构建传统的Web应用，或者需要广泛的生态支持和较为稳定的技术栈，Spring MVC会更为适合。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>异步</category>
      
      <category>响应式</category>
      
      <category>spring</category>
      
      <category>spring-boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>异步</tag>
      
      <tag>响应式</tag>
      
      <tag>spring</tag>
      
      <tag>spring-boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 响应式编程-Project Reactor基础</title>
    <link href="/2025/08/19/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/08/19/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在上篇中介绍了响应式编程基础，其中提到在JDK中只提供了接口规范，并没有提供丰富的操作算子。而 Project Reactor就是基于Reactive Streams规范的具体实现。Project Reactor是由 Spring 团队维护的，与 Spring 生态系统（特别是 Spring WebFlux）无缝集成，其专注于高性能的服务器端应用，特别强调与函数式编程和响应式流规范的集成。</p><span id="more"></span><h2 id="Project-Reactor基础"><a href="#Project-Reactor基础" class="headerlink" title="Project Reactor基础"></a>Project Reactor基础</h2><p>Reactor 项目主要是 reactor-core，这是一个基于 Java 8 的实现了响应式流规范 （Reactive Streams specification）的响应式库。Reactor 围绕两个核心发布者（Publisher）实现及其管理订阅和调度的机制展开：</p><ul><li><strong><code>Flux&lt;T&gt;</code></strong>：0到N个元素的异步序列：可以发出零个、一个或多个元素，最后可以发出一个完成信号或一个错误信号。用于处理数据流、事件序列、列表数据等，例如网络请求返回的多个结果。</li><li><strong><code>Mono&lt;T&gt;</code></strong>：0到1个元素的异步序列，最多发出一个元素，最后可以发出一个完成信号或一个错误信号。用于处理单个结果的异步操作，例如根据 ID 查找单个用户、执行一个 void 方法（返回 Mono）等。</li><li><strong>Scheduler</strong>：线程调度器，类似于 RxJava 的 Scheduler，用于管理执行上下文和线程切换。<ul><li>Schedulers.elastic()：动态线程池，适合 IO 任务。</li><li>Schedulers.parallel()：固定大小线程池，适合计算任务。</li><li>publishOn()&#x2F;subscribeOn()：用于控制操作符链的执行线程。</li></ul></li><li><strong>Subscriber</strong>：订阅者&#x2F;消费者，遵循 Reactive Streams 规范的标准接口，用于消费 Flux 或 Mono 发出的数据。onSubscribe(), onNext(), onError(), onComplete(), request() (背压控制)。</li><li><strong>Publisher</strong>：发布者&#x2F;数据源，Flux 和 Mono 实现的标准接口，定义了 subscribe(Subscriber s) 方法。这是响应式流规范的核心接口，代表可以发出元素和信号的数据源。</li></ul><p>在 Reactor 中，当创建了一条 Publisher 处理链，数据还不会开始生成。事实上是创建了一个抽象的对于异步处理流程的描述。只有真正“订阅（subscrib）”的时，将 Publisher 关联到一个 Subscriber 上，才会触发整个链的流动。这时候，Subscriber 会向上游发送一个 request 信号，一直到达源头的 Publisher。</p><h2 id="Flux与Mono组件"><a href="#Flux与Mono组件" class="headerlink" title="Flux与Mono组件"></a>Flux与Mono组件</h2><p>Flux 是一个发出(emit)0-N个元素组成的异步序列的<code>Publisher&lt;T&gt;</code>, 可以被onComplete信号或者onError信号所终止。一个 flux 的可能结果是一个 value、completion 或 error，就像在响应式流规范中规定的那样，这三种类型的信号被翻译为面向下游的 onNext，<code>onComplete</code>和<code>onError</code>方法。需要注意，<font color=red>所有的信号事件， 包括代表终止的信号事件都是可选的：如果没有 onNext 事件但是有一个 onComplete 事件， 那么发出的就是 空的 有限序列，但是去掉 onComplete 那么得到的就是一个 无限的 空序列</font>。</p><p><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_Flux%E6%B5%81.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FluxExample</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Flux&lt;String&gt; flux = Flux.just(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;World&quot;</span>, <span class="hljs-string">&quot;From&quot;</span>, <span class="hljs-string">&quot;Project&quot;</span>, <span class="hljs-string">&quot;Reactor&quot;</span>);<br><br>    flux.subscribe(System.out::println,<br>                    error -&gt; System.err.println(<span class="hljs-string">&quot;Error: &quot;</span> + error),<br>                    () -&gt; System.out.println(<span class="hljs-string">&quot;Completed&quot;</span>));<br><br>    Flux&lt;String&gt; flux1 = Flux.just(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>);<br>    Flux&lt;String&gt; flux2 = Flux.just(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>);<br><br>    <span class="hljs-comment">// Merge fluxes</span><br>    Flux&lt;String&gt; mergedFlux = Flux.merge(flux1, flux2);<br>    mergedFlux.subscribe(System.out::println);<br><br>    <span class="hljs-comment">// Zip fluxes</span><br>    Flux&lt;String&gt; zippedFlux = Flux.zip(flux1, flux2, (s1, s2) -&gt; s1 + s2);<br>    zippedFlux.subscribe(System.out::println);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Flux常用操作符：</p><ul><li>just()：可以指定序列中包含的全部元素。创建出来的Flux序列在发布这些元素之后会自动结束</li><li>fromArray()，fromIterable()，fromStream()：可以从一个数组，Iterable对象或Stream对象中穿件Flux对象</li><li>empty()：创建一个不包含任何元素，只发布结束消息的序列</li><li>error(Throwable error)：创建一个只包含错误消息的序列</li><li>never()：传建一个不包含任务消息通知的序列</li><li>range(int start, int count)：创建包含从start起始的count个数量的Integer对象的序列</li><li>interval(Duration period)和interval(Duration delay, Duration period)：创建一个包含了从0开始递增的Long对象的序列。其中包含的元素按照指定的间隔来发布。除了间隔时间之外，还可以指定起始元素发布之前的延迟时间</li><li>intervalMillis(long period)和intervalMillis(long delay, long period)：与interval()方法相同，但该方法通过毫秒数来指定时间间隔和延迟时间</li></ul><p><code>Mono&lt;T&gt;</code> 是一种特殊的 <code>Publisher&lt;T&gt;</code>， 它最多发出一个元素，然后终止于一个 onComplete 信号或一个 onError 信号。它只适用其中一部分可用于 Flux 的操作。比如，（两个 Mono 的）结合类操作可以忽略其中之一 而发出另一个 Mono，也可以将两个都发出，对于后一种情况会切换为一个 Flux。例如，Mono#concatWith(Publisher) 返回一个 Flux，而 Mono#then(Mono) 返回另一个 Mono。注意，<font color=red>Mono 可以用于表示“空”的只有完成概念的异步处理（比如 Runnable）。这种用 <code>Mono&lt;Void&gt;</code> 来创建</font>。</p><p><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_Mono%E6%B5%81.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MonoExample</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Mono&lt;String&gt; mono = Mono.just(<span class="hljs-string">&quot;Hello Mono&quot;</span>);<br><br>    mono.subscribe(System.out::println,<br>                  error -&gt; System.err.println(<span class="hljs-string">&quot;Error: &quot;</span> + error),<br>                  () -&gt; System.out.println(<span class="hljs-string">&quot;Completed&quot;</span>));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Mono常用操作符：Mono类包含了与Flux类中相同的静态方法just()，empty()和never()等。Mono还有一些独有的静态方法：</p><ul><li>fromCallable()，fromCompletionStage()，fromFuture()，fromRunnable()和fromSupplier()：分别从Callable，CompletionStage，CompletableFuture，Runnable和Supplier中创建Mono。</li><li>delay(Duration duration)和delayMillis(long duration)：创建一个Mono序列，在指定的延迟时间之后，产生数字0作为唯一值。</li><li>ignoreElements(Publisher<T> source)：创建一个Mono序列，忽略作为源的Publisher中的所有元素，只产生消息。</li><li>justOrEmpty(Optional&lt;? extends T&gt; data)和justOrEmpty(T data)：从一个Optional对象或可能为null的对象中创建Mono。只有Optional对象中包含之或对象不为null时，Mono序列才产生对应的元素。</li></ul><h2 id="Backpressure处理："><a href="#Backpressure处理：" class="headerlink" title="Backpressure处理："></a>Backpressure处理：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BackpressureExample</span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// 收集到缓冲区中，直到消费者准备好处理</span><br>    Flux.range(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>)<br>        .onBackpressureBuffer(<span class="hljs-number">10</span>)<br>        .subscribe(System.out::println);<br><br>    <span class="hljs-comment">// 如果消费者跟不上，直接删除</span><br>    Flux.range(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>)<br>        .onBackpressureDrop(item -&gt; System.out.println(<span class="hljs-string">&quot;Dropped: &quot;</span> + item))<br>        .subscribe(System.out::println);<br><br>    <span class="hljs-comment">// 只保留最新，其余丢弃</span><br>    Flux.range(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>)<br>        .onBackpressureLatest()<br>        .subscribe(System.out::println);<br><br>    <span class="hljs-comment">// 包含错误处理    </span><br>    Flux.range(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>)<br>        .onBackpressureError()<br>        .subscribe(<br>            System.out::println,<br>            error -&gt; System.err.println(<span class="hljs-string">&quot;Error: &quot;</span> + error));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用BaseSubscriber实现精细化流量控制（背压，Backpressure），通过重写 hookOnSubscribe 和 hookOnNext 方法，可以手动管理从发布者（Publisher）请求的数据量，而不是默认请求无限制的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java">Flux.range(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>)<br>    .subscribe(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BaseSubscriber</span>&lt;Integer&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hookOnSubscribe</span><span class="hljs-params">(Subscription subscription)</span> &#123;<br>            request(<span class="hljs-number">1</span>); <span class="hljs-comment">// Request the first item</span><br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hookOnNext</span><span class="hljs-params">(Integer value)</span> &#123;<br>            System.out.println(value);<br>            request(<span class="hljs-number">1</span>); <span class="hljs-comment">// Request the next item after processing the current one</span><br>        &#125;<br>    &#125;);<br></code></pre></td></tr></table></figure><p>BaseSubscriber 实现了 Subscriber 接口，并提供了方便的以 hook 开头的方法供重写。它的核心优势在于允许用户直接调用 request(long n) 方法来向上游发布者发出数据请求，从而避免因消费者处理速度慢而导致的系统过载。<font color=red>默认情况下，如果不重写 hookOnSubscribe 或 hookOnNext，BaseSubscriber 会自动发出一个无限制的请求（Long.MAX_VALUE）</font>。</p><ul><li><strong>hookOnSubscribe(Subscription subscription)</strong>：这个方法在订阅成功建立时被调用，可以在此方法中执行初始设置，并发出首个数据请求。它是与上游 Subscription 交互的，必须在此处调用 request(long n) 来启动数据流。如果在此处请求有限数量（例如 request(1) 或 request(5)），则意味着需要在 hookOnNext 中继续手动请求后续数据。</li><li><strong>hookOnNext(T value)</strong>：这个方法在每次接收到上游发出的数据项时被调用，是处理业务逻辑和持续流量控制的地方。在处理完当前接收到的数据后，可以决定何时以及请求多少下一个数据。如果在 hookOnSubscribe 中请求了有限数量，那么为了让数据流继续，需要在 hookOnNext 方法中再次调用 request(long n) 来请求下一个（或下一批）数据。</li></ul><h2 id="常用功能操作符"><a href="#常用功能操作符" class="headerlink" title="常用功能操作符"></a>常用功能操作符</h2><p>Project Reactor 提供了丰富的操作符来处理 Flux (0到N个元素) 和 Mono (0或1个元素) 数据流。虽然没有一个官方统一的分类标准，但根据功能，可以将这些操作符分为：创建操作符 (Creation Operators)、转换操作符 (Transformation Operators)、过滤操作符 (Filtering Operators)、组合操作符 (Combining Operators)、工具操作符 (Utility&#x2F;Side-Effect Operators)。</p><h3 id="创建操作符-Creation-Operators"><a href="#创建操作符-Creation-Operators" class="headerlink" title="创建操作符 (Creation Operators)"></a>创建操作符 (Creation Operators)</h3><ul><li><code>just(T...)</code>: 从给定的元素创建一个 Flux 或 Mono。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java">Mono.just(<span class="hljs-string">&quot;mono&quot;</span>).subscribe(data -&gt; System.out.println(<span class="hljs-string">&quot;mono: &quot;</span> + data));<br>Flux.just(<span class="hljs-string">&quot;flux-1&quot;</span>, <span class="hljs-string">&quot;flux-2&quot;</span>).subscribe(data -&gt; System.out.println(<span class="hljs-string">&quot;flux: &quot;</span> + data))<br></code></pre></td></tr></table></figure><ul><li><code>generate()</code>：通过同步和逐一的方式来产生Flux序列。序列的产生是通过调用所提供的的SynchronousSink对象的next()，complete()和error(Throwable)方法来完成的。逐一生成的含义是在具体的生成逻辑中，next()方法只能最多被调用一次。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java">Flux&lt;String&gt; flux = Flux.generate(<br>       () -&gt; <span class="hljs-number">0</span>,<br>       (state, sink) -&gt; &#123;<br>          sink.next(<span class="hljs-string">&quot;3 x &quot;</span> + state + <span class="hljs-string">&quot; = &quot;</span> + <span class="hljs-number">3</span>*state);<br>          <span class="hljs-keyword">if</span> (state == <span class="hljs-number">10</span>) sink.complete();<br>          <span class="hljs-keyword">return</span> state + <span class="hljs-number">1</span>;<br>       &#125;, (state) -&gt; System.out.println(<span class="hljs-string">&quot;state: &quot;</span> + state));<br>flux.subscribe(data -&gt; System.out.println(<span class="hljs-string">&quot;data &quot;</span> + data));<br></code></pre></td></tr></table></figure><ul><li><code>create()</code>：create 是一种更高级的编程方式创建 Flux 的形式，它适合每轮多次发出，甚至来自多个线程。它暴露了一个 FluxSink 及其 next，error 和 complete 方法。与 generate 相反，它没有基于状态的形式。但是，它可以在回调中触发多线程事件。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java">Flux&lt;String&gt; bridge = Flux.create(sink -&gt; &#123;<br>  myMessageProcessor.register(<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyMessageListener</span>&lt;String&gt;() &#123;<br><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMessage</span><span class="hljs-params">(List&lt;String&gt; messages)</span> &#123;<br>        <span class="hljs-keyword">for</span>(String s : messages) &#123;<br>          sink.next(s); <br>        &#125;<br>      &#125;<br>  &#125;);<br>  sink.onRequest(n -&gt; &#123;<br>    List&lt;String&gt; messages = myMessageProcessor.getHistory(n); <br>    <span class="hljs-keyword">for</span>(String s : message) &#123;<br>      sink.next(s); <br>    &#125;<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><ul><li><code>defer()</code>：延迟捕获或创建序列对象。它会在每次对生成的 Flux&#x2F;Mono 进行订阅时懒惰地提供一个发布者，因此实际的源实例化被推迟到每次订阅时，并且提供者可以创建一个订阅者特定的实例。</li></ul><p><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_defer.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">Mono.defer(() -&gt; Mono.just(UUID.randomUUID())).subscribe(x -&gt; System.out.println(x));<br></code></pre></td></tr></table></figure><ul><li><code>fromIterable(Iterable&lt;T&gt;)/fromArray(T[])</code>: 从 Iterable (如 List, Set) 创建一个 Flux。</li></ul><p><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_fromIterable.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java">Flux&lt;String&gt; flux = Flux.fromIterable(Arrays.asList(<span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>, <span class="hljs-string">&quot;purple&quot;</span>));             <br>flux.subscribe(System.out::println);<br></code></pre></td></tr></table></figure><ul><li><code>fromRunnable(Runnable) / fromCallable(Callable&lt;T&gt;)</code>: 将命令式代码转换为 Mono，并在订阅时执行。</li></ul><p><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_fromCallable.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">Mono.fromCallable(() -&gt; UUID.randomUUID()).subscribe(x -&gt; System.out.println(x));<br></code></pre></td></tr></table></figure><ul><li><code>fromSupplier()</code>：它与 defer() 类似，用于延迟创建类似 Mono 的序列对象。但不同之处在于，它可以自动将提供的数据转换为 Mono 格式。它创建一个 Mono 对象，并使用提供的提供者生成其值，如果提供者解析为 null，则生成的 Mono 对象为空。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">Mono.fromSupplier(() -&gt; UUID.randomUUID()).subscribe(x -&gt; System.out.println(x));<br></code></pre></td></tr></table></figure><ul><li><p><code>range()</code>: 创建一个整数序列的 Flux。</p></li><li><p><code>empty()/defaultIfEmpty()</code>: 创建一个立即完成但没有任何元素的 Flux 或 Mono。</p></li></ul><p><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_defaultEmpty.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">Mono.empty().defaultIfEmpty(<span class="hljs-string">&quot;defaultValue&quot;</span>).subscribe(System.out::println);<br></code></pre></td></tr></table></figure><h3 id="转换操作符-Transformation-Operators"><a href="#转换操作符-Transformation-Operators" class="headerlink" title="转换操作符 (Transformation Operators)"></a>转换操作符 (Transformation Operators)</h3><ul><li><code>map(Function&lt;T, V&gt;)</code>: 同步地将上游的每个元素映射为下游的一个新元素。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java">Flux&lt;Integer&gt; flux = Flux.just(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>)<br>       .map(data -&gt; Integer.parseInt(data));<br>flux.subscribe(data -&gt; System.out.println(<span class="hljs-string">&quot;data &quot;</span> + data));<br></code></pre></td></tr></table></figure><ul><li><code>flatMap(Function&lt;T, Publisher&lt;V&gt;&gt;)</code>: 异步地将每个元素映射为一个新的 Publisher（Mono 或 Flux），并将所有内部流合并为一个扁平的下游流。这是响应式编程中最强大的操作符之一。</li></ul><p><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_flatMap.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java">Flux&lt;Integer&gt; flux = Flux.just(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>)<br>       .flatMap(data -&gt; Mono.just(Integer.parseInt(data)));<br>flux.subscribe(data -&gt; System.out.println(<span class="hljs-string">&quot;data &quot;</span> + data));<br></code></pre></td></tr></table></figure><ul><li><code>buffer(int maxSize) / window(int maxSize)</code>: 将元素收集到 List (buffer) 或一个新的 Flux (window) 中，然后发射这些集合。</li><li><code>cast(Class&lt;V&gt; clazz)</code>: 将流中的元素转换为指定的类型。</li></ul><h3 id="过滤操作符-Filtering-Operators"><a href="#过滤操作符-Filtering-Operators" class="headerlink" title="过滤操作符 (Filtering Operators)"></a>过滤操作符 (Filtering Operators)</h3><ul><li><code>filter(Predicate&lt;T&gt;)</code>: 只允许满足条件的元素通过。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java">Flux&lt;Integer&gt; flux = Flux.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span><br>       .filter(data -&gt; data != <span class="hljs-number">4</span>);<br>flux.subscribe(data -&gt; System.out.println(<span class="hljs-string">&quot;data &quot;</span> + data));)<br></code></pre></td></tr></table></figure><ul><li><code>take(long n)</code>: 只获取前 N 个元素。</li><li><code>skip(long n)</code>: 跳过前 N 个元素。</li><li><code>distinct() / distinctUntilChanged()</code>: 过滤掉重复的元素。</li></ul><p><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_distinct.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java">Flux&lt;String&gt; flux =Flux.just(<span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>, <span class="hljs-string">&quot;purple&quot;</span>)<br>       .distinct();<br>flux.subscribe(System.out::println);<br></code></pre></td></tr></table></figure><h3 id="组合操作符-Combining-Operators"><a href="#组合操作符-Combining-Operators" class="headerlink" title="组合操作符 (Combining Operators)"></a>组合操作符 (Combining Operators)</h3><ul><li><code>merge(Publisher&lt;T&gt;... principals)</code>: 以交错的方式合并多个 Publisher 的输出。</li></ul><p><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_merge.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java">Flux&lt;Integer&gt; evenNumbers = Flux<br>.range(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)<br>.filter(x -&gt; x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>);<br><br>Flux&lt;String&gt; oddNumbers = Flux<br>.range(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)<br>.filter(x -&gt; x % <span class="hljs-number">2</span> &gt; <span class="hljs-number">0</span>)<br>.map(x -&gt; x.toString().concat(<span class="hljs-string">&quot;: n&quot;</span>));<br><br><span class="hljs-type">var</span> <span class="hljs-variable">flux1</span> <span class="hljs-operator">=</span> Flux.merge(evenNumbers, oddNumbers);<br>flux1.subscribe(x -&gt; System.out.println(x));<br></code></pre></td></tr></table></figure><ul><li><code>zip(Publisher&lt;T&gt; p1, Publisher&lt;V&gt; p2)</code>: 将两个源 Publisher 按顺序发射的元素配对组合成一个新的元素（如 Tuple2）。</li></ul><p><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_zip.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java">Flux&lt;Integer&gt; evenNumbers = Flux<br>.range(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)<br>.filter(x -&gt; x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>);<br><br>Flux&lt;Integer&gt; oddNumbers = Flux<br>.range(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)<br>.filter(x -&gt; x % <span class="hljs-number">2</span> &gt; <span class="hljs-number">0</span>);<br><br>Flux&lt;Tuple2&lt;Integer, Integer&gt;&gt; fluxOfIntegers = Flux.zip(evenNumbers, oddNumbers);<br>fluxOfIntegers.subscribe(x -&gt; System.out.println(x));<br><br>Flux&lt;Tuple2&lt;Integer, Integer&gt;&gt; flux = evenNumbers.zipWith(oddNumbers);<br>flux.subscribe(x -&gt; System.out.println(x));<br></code></pre></td></tr></table></figure><ul><li><code>concat()/concatMap()</code>：将提供的所有源连接成一个可迭代对象，并将源发出的元素向下游转发。concat是通过依次订阅第一个源，然后等待其完成再订阅下一个源来实现的，依此类推，直到最后一个源完成。任何错误都会立即中断序列并向下游转发，它会返回一个新的 Flux，该 Flux 连接了所有源序列。</li></ul><p><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_concat.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java">Flux&lt;Integer&gt; evenNumbers = Flux<br>.range(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)<br>.filter(x -&gt; x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>);<br><br>Flux&lt;Integer&gt; oddNumbers = Flux<br>.range(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)<br>.filter(x -&gt; x % <span class="hljs-number">2</span> &gt; <span class="hljs-number">0</span>);<br><br>Flux&lt;Integer&gt; fluxOfIntegers = Flux.concat(evenNumbers, oddNumbers);<br>fluxOfIntegers.subscribe(x -&gt; System.out.println(x));<br><br>Flux&lt;String&gt; mergedFlux = Flux.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>.concatMap(it -&gt; Mono.just(it.toString().concat(<span class="hljs-string">&quot;: n&quot;</span>)));<br><br>mergedFlux.subscribe(x -&gt; System.out.println(x));<br></code></pre></td></tr></table></figure><ul><li><code>then()/thenEmpty()</code>：不关心发布者输出了哪些元素，而只关心它何时完成发布的情况。因此，它会接收一个现有的发布者，丢弃它所有的元素，然后传播完成信号或错误信号。如果我们把任何 Mono 作为 then() 的参数传递，它会将该 Mono 作为输出传递。</li></ul><p><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_then.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java">Mono&lt;Void&gt; then = Flux.just(<span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>, <span class="hljs-string">&quot;red&quot;</span>)<br>  .then(Mono.just(<span class="hljs-string">&quot;Orange&quot;</span>))<br>  .thenEmpty(Mono.empty());<br>then.subscribe();<br></code></pre></td></tr></table></figure><h3 id="工具操作符-Utility-Side-Effect-Operators"><a href="#工具操作符-Utility-Side-Effect-Operators" class="headerlink" title="工具操作符 (Utility&#x2F;Side-Effect Operators)"></a>工具操作符 (Utility&#x2F;Side-Effect Operators)</h3><ul><li><code>log()</code>: 记录所有响应式信号 (onNext, onError, onComplete, onSubscribe, request) 到日志。</li><li><code>doOnNext(...), doOnError(...), doOnComplete(...)</code>: 注册回调函数以观察特定信号并执行Side-Effect操作。</li></ul><p><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_doOnNext.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java">Flux&lt;Integer&gt; flux = Flux.just(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>)<br>       .map(data -&gt; Integer.parseInt(data));<br>flux.subscribe(data -&gt; System.out.println(<span class="hljs-string">&quot;data &quot;</span> + data));<br></code></pre></td></tr></table></figure><ul><li><code>subscribeOn(Scheduler s)</code>: 指定上游源执行的调度器（线程池）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">Scheduler</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> Schedulers.newParallel(<span class="hljs-string">&quot;parallel-scheduler&quot;</span>, <span class="hljs-number">4</span>); <br><br><span class="hljs-keyword">final</span> Flux&lt;String&gt; flux = Flux<br>    .range(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>    .map(i -&gt; <span class="hljs-number">10</span> + i)  <br>    .subscribeOn(s)  <br>    .map(i -&gt; <span class="hljs-string">&quot;value &quot;</span> + i);  <br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; flux.subscribe(System.out::println));  <br></code></pre></td></tr></table></figure><ul><li><code>publishOn(Scheduler s)</code>: 指定下游操作符执行的调度器。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">Scheduler</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> Schedulers.newParallel(<span class="hljs-string">&quot;parallel-scheduler&quot;</span>, <span class="hljs-number">4</span>); <br><br><span class="hljs-keyword">final</span> Flux&lt;String&gt; flux = Flux<br>    .range(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>    .map(i -&gt; <span class="hljs-number">10</span> + i)  <br>    .publishOn(s)  <br>    .map(i -&gt; <span class="hljs-string">&quot;value &quot;</span> + i);  <br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; flux.subscribe(System.out::println));  <br></code></pre></td></tr></table></figure><ul><li><code>block() / blockFirst() / blockLast()</code>: 阻塞当前线程直到流完成或发出元素（应谨慎使用，主要用于测试或非响应式边界）。</li></ul><p><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_block.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> Mono.just(<span class="hljs-string">&quot;Value&quot;</span>)<br>             .block();<br>System.out.println(value);<br></code></pre></td></tr></table></figure><ul><li><code>switchIfEmpty()</code>：如果序列完成时没有任何数据，它会切换到备用发布者。</li></ul><p><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_switchIfEmpty.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java">Mono&lt;String&gt; defaultMono = Mono.just(<span class="hljs-string">&quot;defaultString&quot;</span>);<br>Mono&lt;Object&gt; mono = Mono.empty().switchIfEmpty(defaultMono);<br>mono.subscribe(System.out::println);<br></code></pre></td></tr></table></figure><ul><li><code>handle()</code>：用于创建自定义处理器。handle 方法可以用于自定义流的处理逻辑，与 map 方法重新映射、生成新的流不同，handle 方法用于消费元素，可以重新定义流。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">alphabet</span><span class="hljs-params">(<span class="hljs-type">int</span> letterNumber)</span> &#123;<br>  <span class="hljs-keyword">if</span> (letterNumber &lt; <span class="hljs-number">1</span> || letterNumber &gt; <span class="hljs-number">26</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">letterIndexAscii</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;A&#x27;</span> + letterNumber - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span> + (<span class="hljs-type">char</span>) letterIndexAscii;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operatorTest</span><span class="hljs-params">()</span> &#123;<br>  Flux&lt;String&gt; alphabet = Flux.just(-<span class="hljs-number">1</span>, <span class="hljs-number">30</span>, <span class="hljs-number">13</span>, <span class="hljs-number">9</span>, <span class="hljs-number">20</span>)<br>      .handle((i, sink) -&gt; &#123;<br>          <span class="hljs-type">String</span> <span class="hljs-variable">letter</span> <span class="hljs-operator">=</span> alphabet(i);<br>          <span class="hljs-keyword">if</span> (letter != <span class="hljs-literal">null</span>) sink.next(letter);<br>      &#125;)<br>      .filter(data -&gt; &#123;<br>          <span class="hljs-type">boolean</span> <span class="hljs-variable">isTrue</span> <span class="hljs-operator">=</span> !data.equals(<span class="hljs-string">&quot;M&quot;</span>);<br>          System.out.println(isTrue);<br>          <span class="hljs-keyword">return</span> isTrue;<br>      &#125;)<br>      .map(ch -&gt; ch+<span class="hljs-string">&quot;-Data&quot;</span>)<br>      .doOnNext(conData -&gt; System.out.println(conData))<br>      .flatMap(conData -&gt; Mono.just(conData));<br><br>  alphabet.subscribe(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>在 Project Reactor 中，处理错误是响应式编程的关键部分，流一旦发生错误就会终止 (onError 信号)，因此需要使用特定的操作符来截取错误并决定后续行为。</p><h3 id="错误恢复操作符-Recovery-Operators-："><a href="#错误恢复操作符-Recovery-Operators-：" class="headerlink" title="错误恢复操作符 (Recovery Operators)："></a>错误恢复操作符 (Recovery Operators)：</h3><p><strong>onErrorReturn(T fallbackValue)</strong>：当发生错误时，抛出一个默认值，然后正常完成 (onComplete)。适用于需要提供一个默认值作为简单回退逻辑的情况，例如：服务不可用时返回一个缓存的默认值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java">Flux.just(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)<br>    .map(i -&gt; <span class="hljs-number">10</span> / i) <span class="hljs-comment">// 当 i 为 0 时抛出 ArithmeticException</span><br>    .onErrorReturn(-<span class="hljs-number">1</span>) <span class="hljs-comment">// 捕获错误并返回 -1</span><br>    .subscribe(System.out::println); <br><span class="hljs-comment">// 输出: 10, -1</span><br></code></pre></td></tr></table></figure><p><strong><code>onErrorResume(Function&lt;Throwable, ? extends Publisher&lt;? extends T&gt;&gt; fallbackSupplier)</code></strong>：当发生错误时，切换到一个新的备用 Publisher (如另一个 Mono 或 Flux) 来继续数据流。适用于需要执行更复杂的备用逻辑、调用另一个服务或根据错误类型动态生成备用数据流的情况。</p><p><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_onErrorResume.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java">Flux.just(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;unknown&quot;</span>)<br>    .flatMap(user -&gt; callExternalService(user) <span class="hljs-comment">// 模拟外部服务调用</span><br>        .onErrorResume(e -&gt; getFromCache(user)) <span class="hljs-comment">// 外部服务失败时从缓存获取</span><br>    )<br>    .subscribe(System.out::println);<br></code></pre></td></tr></table></figure><p><strong>onErrorComplete()</strong>：捕获错误信号，并将其转换为正常的完成信号 (onComplete)。适用于成功的结果而可以完全忽略错误的场景。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java">Flux.just(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>)<br>    .map(<span class="hljs-built_in">this</span>::doSomethingDangerousOn30)<br>    .onErrorComplete();<br></code></pre></td></tr></table></figure><p><strong>doFinally()</strong>：最终执行，类似try-finally。 doFinally 在终止时无论是 onComplete、<code>onError</code>还是取消都会被执行， 并且能够判断是什么类型的终止事件。</p><p><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_doFinally.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java">Flux.just(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>)<br>    .doOnSubscribe(s -&gt; stats.startTimer())<br>    .doFinally(type -&gt; &#123; <br>        stats.stopTimerAndRecordTiming();<br>        <span class="hljs-keyword">if</span> (type == SignalType.CANCEL) <br>          statsCancel.increment();<br>    &#125;);<br></code></pre></td></tr></table></figure><p><strong><code>onErrorContinue(BiConsumer&lt;Throwable, Object&gt; consumer)</code></strong>：允许在处理 Flux 流中的元素时，跳过导致错误的元素，记录错误信息，然后继续处理流中的下一个元素。主要用于 Flux 中，当某个元素处理失败不应中断整个流时。注意，必须将此操作符放在可能抛出异常的操作符（例如 map）之前。</p><h3 id="错误转换操作符"><a href="#错误转换操作符" class="headerlink" title="错误转换操作符"></a>错误转换操作符</h3><p><strong><code>onErrorMap(Function&lt;Throwable, Throwable&gt; mapper)</code></strong>：将捕获到的异常转换为另一种自定义的异常类型，并重新抛出（向下游传递新的 onError 信号）。适用于将底层技术异常（如 IOException）封装为业务异常（如 UserServiceException），以便下游更好地理解和处理。</p><p><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_onErrorMap.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java">Flux.just(<span class="hljs-string">&quot;timeout1&quot;</span>)<br>    .flatMap(k -&gt; callExternalService(k))<br>    .onErrorMap(original -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">BusinessException</span>(<span class="hljs-string">&quot;oops, SLA exceeded&quot;</span>, original));<br></code></pre></td></tr></table></figure><p><strong><code>doOnError(Consumer&lt;Throwable&gt; consumer)</code></strong>：注册一个回调函数，用于观察（记录日志、监控指标等）错误信号，但不会改变或消耗错误信号，错误会继续向下游传播。仅用于执行副作用操作，如日志记录或指标收集。</p><p><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_doOnError.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java">Flux.just(<span class="hljs-string">&quot;unknown&quot;</span>)<br>    .flatMap(k -&gt; callExternalService(k).doOnError(e -&gt; &#123;<br>            failureStat.increment();<br>            log(<span class="hljs-string">&quot;uh oh, falling back, service failed for key &quot;</span> + k); <br>        &#125;)<br>    );<br></code></pre></td></tr></table></figure><h3 id="重试操作符-Retry-Operators"><a href="#重试操作符-Retry-Operators" class="headerlink" title="重试操作符 (Retry Operators)"></a>重试操作符 (Retry Operators)</h3><p><strong>retry() 或 retry(long maxRetries)</strong>：发生错误时，重新订阅上游的 Publisher，尝试再次执行整个流。原始流会终止，但 retry 会创建一个新的订阅。适用于处理瞬时错误（例如网络波动、临时服务不可用）的情况。应设置最大重试次数以避免无限循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java">Flux.interval(Duration.ofMillis(<span class="hljs-number">250</span>))<br>    .map(input -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (input &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;tick &quot;</span> + input;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;boom&quot;</span>);<br>    &#125;)<br>    .elapsed() <br>    .retry(<span class="hljs-number">1</span>)<br>    .subscribe(System.out::println, System.err::println);<br></code></pre></td></tr></table></figure><p><strong><code>retryWhen(Function&lt;Flux&lt;Throwable&gt;, ? extends Publisher&lt;?&gt;&gt;)</code></strong>：: 提供基于异常类型和重试次数的更精细的重试逻辑控制，支持指数退避等高级策略。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java">Flux.&lt;String&gt;error(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>()) <br>    .doOnError(System.out::println) <br>    .retryWhen(companion -&gt; companion.take(<span class="hljs-number">3</span>));<br></code></pre></td></tr></table></figure><h2 id="线程和调度器"><a href="#线程和调度器" class="headerlink" title="线程和调度器"></a>线程和调度器</h2><p>响应式流（Flux和Mono）本质上是关于数据流和信号回调的，而不是并发模型。默认情况下，操作符会继续在执行前一个操作符的线程中工作。即，除非指定，否则源操作符本身运行在调用了 subscribe() 的 Thread 上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>  <span class="hljs-keyword">final</span> Flux&lt;Object&gt; flux = Flux.fromArray(Arrays.asList(<span class="hljs-string">&quot;hello &quot;</span>, <span class="hljs-string">&quot;reactive &quot;</span>).toArray());<br><br>  <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; flux<br>      .map(msg -&gt; msg + <span class="hljs-string">&quot;thread &quot;</span>)<br>      .subscribe(v -&gt;<br>          System.out.println(v + Thread.currentThread().getName())<br>      )<br>  );<br>  t.start();<br>  t.join();<br>&#125;<br></code></pre></td></tr></table></figure><p>Reactor的 <strong>调度器（Scheduler）</strong> 是控制线程执行的关键机制，它类似于 ExecutorService，用于将不同的操作分派到特定的线程或线程池。Schedulers 类提供了一系列静态方法来访问不同类型的内置调度器，它们抽象了底层的线程池管理。Reactor主要的内置调度器类型包括：</p><ul><li>Schedulers.immediate(): 在当前线程中立即执行任务。</li><li>Schedulers.single(): 使用一个单一的、可重用的后台线程。</li><li>Schedulers.parallel(): 使用一个固定大小的线程池，其大小通常等于 CPU 核心数，适用于并行计算任务。</li><li>Schedulers.boundedElastic(): 这是一个有界的弹性线程池，按需动态创建线程，但有数量上限，适用于执行阻塞 I&#x2F;O 操作（如数据库调用、网络请求）。它是已弃用的 Schedulers.elastic() 的替代品。</li></ul><p>除了上面内置的调度器，也可以使用现有的 ExecutorService 创建自定义调度器。Project Reactor 提供了两个核心操作符来控制流的执行线程上下文：</p><ul><li><strong>subscribeOn(Scheduler)</strong>：把订阅动作（Subscriber.onSubscribe 的创建、链路建立、上游 request 的初次调用等）移动到指定 Scheduler。当在上游调用 subscribe 时，subscribeOn 会 schedule 一个 Runnable 去执行真正的 subscribe 操作（即把 subscription 的建立放到其他线程），因此上游的同步产生&#x2F;拉取代码会在该 Scheduler 的线程上运行。它影响整个操作链的源头（upstream）和下游（downstream），决定了数据生成和初始订阅发生的线程。无论 subscribeOn 放在操作链的哪个位置，它都会改变整个流的根执行上下文。</li><li><strong>publishOn(Scheduler)</strong>：在数据流中的某处建立异步边界——把从这个 operator 向下游发送的信号切换到指定 Scheduler 的线程。publishOn 用一个内部队列把上游发来的 onNext&#x2F;onError&#x2F;onComplete 等事件缓存起来，然后在 Worker 的线程中做 drain（取出并调用下游的 onNext&#x2F;onComplete&#x2F;onError）。因此，publishOn 会序列化并且切换信号执行线程。它只影响其 <strong>下游（downstream）</strong> 的操作符（从它出现的位置到下一个 publishOn 或流结束）。会在流中引入一个异步边界，将后续的处理切换到指定的调度器上。这对于在不同阶段（例如，将 I&#x2F;O 操作与 CPU 密集型操作分开）使用不同的线程池非常有用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java">Flux.range(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)<br>    .map(i -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;map1 thread: &quot;</span> + Thread.currentThread().getName());<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;)<br>    .subscribeOn(Schedulers.boundedElastic()) <span class="hljs-comment">// 订阅在 boundedElastic 线程</span><br>    .map(i -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;map2 thread: &quot;</span> + Thread.currentThread().getName());<br>        <span class="hljs-keyword">return</span> i * <span class="hljs-number">10</span>;<br>    &#125;)<br>    .publishOn(Schedulers.parallel()) <span class="hljs-comment">// 从这里开始把信号转到 parallel 线程</span><br>    .map(i -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;map3 thread: &quot;</span> + Thread.currentThread().getName());<br>        <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>    &#125;)<br>    .subscribe(i -&gt; System.out.println(<span class="hljs-string">&quot;onNext thread: &quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot; =&gt; &quot;</span> + i));<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>异步</category>
      
      <category>响应式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>异步</tag>
      
      <tag>响应式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 响应式编程基础</title>
    <link href="/2025/08/17/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/08/17/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>响应式编程（Reactive Programming）是 2013 年底由 Netflix、Lightbend 和 Pivotal（Spring 背后的公司）的工程师发起的一项计划，是一种处理异步数据流并传播变化的编程范式，旨在构建更具响应性、弹性、可伸缩性的非阻塞式应用。它主要围绕数据流和变化的自动传播来构建，核心在于<strong>对事件作出反应</strong>。 2015 年 Reactive Stream（响应式流）规范诞生，为 JVM 上的响应式编程定义了一组接口和交互规则。根据反应式编程规范，反应式系统具有以下特征：</p><span id="more"></span><ul><li>响应迅速：一个响应式系统应该提供快速且一致的响应时间，从而提供一致的服务质量。</li><li>高可用：反应式系统应通过复制和隔离，在发生随机故障时保持响应能力。</li><li>可扩展：这样的系统应该能够通过经济高效的可扩展性，在不可预测的工作负载下保持响应能力。</li><li>消息驱动：应该依赖于系统组件之间的异步消息传递。</li></ul><p><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80_%E5%8F%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%E8%A6%81%E7%B4%A0.png"></p><p>响应式模型有两种基本的实现机制:</p><ul><li>一种就是传统开发模式下的“拉”模式，即消费者主动从生产者拉取元素；</li><li>一种是“推”模式，在这种模式下，生产者将元素推送给消费者。相较于“拉”模式，“推”模式下的数据处理的资源利用率更好。</li></ul><p>推模式中数据流的生产者会持续地生成数据并推送给消费者。这里就引出了 <code>流量控制问题</code> ，即如果数据的生产者和消费者处理数据的速度是不一致的。当生产者和消费者处理数据的速度不一致有如下两种情况：</p><ul><li><strong>生产者生产数据的速率小于消费者的场景：</strong> 这种场景对于消费者来说没啥压力，正常消费就好了，这里也就不需要所谓的流量控制了。</li><li><strong>生产者生产数据的速率大于消费者的场景：</strong> 生产者生产数据的速率大于消费者的场景，应该是我们业务中经常遇到的场景了，这种场景由于消费者处理不过来导致崩溃，业界通常的做法是在生产者与消费者之间加一个队列做缓冲。我们知道队列具有存储与转发的功能，所以可以用它来进行一定的流量控制。</li></ul><p>控制流量主要基于 Java 的队列实现，主要有以下三种实现方式：</p><ul><li><p>无界队列：无界队列在原则上是拥有无线大小容量的队列，可以存放生产者产生的所有消息。</p><ul><li>优势：确保消费者消费到所有的数据</li><li>劣势：系统的回弹性降低，任何一个系统不可能拥有无限的资源，一旦内存等资源耗尽，系统就可能会有崩溃的风险。</li></ul></li><li><p>有界丢弃队列：为了避免上面无界队列的弊端，有界丢弃队列采用的是如果队列满了，就会采用丢弃后面传入的值，这里可以设置一些丢弃策略，比如说按照优先级或先进先出等。</p><ul><li>优势：考虑到资源的限制，适合允许丢消息的业务场景。</li><li>劣势：消息重要性很高的场景不建议采取这种队列</li></ul></li><li><p>有界阻塞队列：在数据高度一致性的场景是不允许丢数据的，这时使用有界阻塞队列，当队列消息数量达到上限后阻塞生产者，而不是直接丢弃消息。</p><ul><li>优势：解决了不允许丢数据的业务场景</li><li>劣势：当队列满了的时候，会阻塞生产者停止生产数据，这种场景不可能实现异步操作的。</li></ul></li></ul><p>在推模式下的数据流量会有很多不可控制的因素，并不能直接应用，而是需要在“推”模式和“拉”模式之间考虑一定的平衡性，从而优雅地实现流量控制。这就需要引出响应式系统中非常重要的一个概念——<strong>背压机制（Backpressure）。</strong> <font color=red>背压机制是指下游能够向上游反馈流量请求的机制</font>。采用背压机制，消费者会根据自身的处理能力来请求数据，而生产者也会根据消费者的能力来生产数据，从而在两者之间达成一种动态的平衡，确保系统的即时响应性。</p><h2 id="Reactive-Stream实现"><a href="#Reactive-Stream实现" class="headerlink" title="Reactive Stream实现"></a>Reactive Stream实现</h2><p>前面提到，2015 年 Reactive Stream（响应式流）规范正式发布，Java 9 正式引入了响应式编程的 API，将 Reactive Stream 规范定义的四个接口集成到了 java.util.concurrent.Flow 类中，Java 9 Flow 提供了一个标准化的基础接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Flow</span> &#123;<br>  <span class="hljs-meta">@FunctionalInterface</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Publisher</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">subscribe</span><span class="hljs-params">(Subscriber&lt;? <span class="hljs-built_in">super</span> T&gt; subscriber)</span>;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Subscriber</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSubscribe</span><span class="hljs-params">(Subscription subscription)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onNext</span><span class="hljs-params">(T item)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onError</span><span class="hljs-params">(Throwable throwable)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onComplete</span><span class="hljs-params">()</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Subscription</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">request</span><span class="hljs-params">(<span class="hljs-type">long</span> n)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">()</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Processor</span>&lt;T,R&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Subscriber</span>&lt;T&gt;, Publisher&lt;R&gt; &#123;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80_ReactiveStream%E6%B5%81%E7%A8%8B.png"></p><p>在实际应用中，Java Reactive Stream 有多种具体实现，最常用的是：</p><ul><li><strong>Java 9 Flow API</strong>：Java 9 Flow 提供了一个标准化的基础接口，定义了响应式流应该如何工作，但不提供具体的实现或操作符。它旨在确保不同的响应式库（如 RxJava 和 Reactor）能够相互协作（互操作性）。</li><li><strong>Project Reactor</strong>：是由 Spring 团队维护的，与 Spring 生态系统（特别是 Spring WebFlux）无缝集成，专注于高性能的服务器端应用。</li><li><strong>RxJava</strong>： 是一个更通用的库，提供了更丰富的操作符和类型（如 Single, Completable），在 Android 和各种独立 Java 应用中非常流行。 </li><li><strong>Akka Streams</strong>：提供了直观、类型安全且支持背压的流处理 API，其核心功能是使用有限的缓冲区资源高效执行流式计算。</li></ul><h3 id="Project-Reactor"><a href="#Project-Reactor" class="headerlink" title="Project Reactor"></a>Project Reactor</h3><p>Project Reactor 的核心功能专注于构建高效、非阻塞的服务器端应用程序，特别强调与函数式编程和响应式流规范的集成。其核心在于使用 Flux 和 Mono 这两个核心类型来处理数据流。核心功能如下：</p><ul><li>响应式流规范实现：Reactor 完全实现了 Reactive Streams 规范，确保了良好的互操作性和标准的背压（Backpressure）支持。</li><li>函数式与声明式 API：Reactor 的 API 设计高度函数式，利用 Java 8 的 Lambda 表达式，使得数据转换和组合操作非常简洁易读。</li><li>与 Spring 生态集成：这是 Reactor 的关键优势。它是 Spring WebFlux 的基础，使得构建完全响应式的 Spring 5+ 应用成为可能。</li><li>简化的类型系统：相比 RxJava 复杂的类型（如 Observable, Flowable, Single, 等），Reactor 仅使用 Flux（0到N个元素）和 Mono（0到1个元素）来覆盖所有场景，降低了学习和使用的复杂性。</li><li>高效的背压管理：通过 Reactive Streams 接口，Reactor 能够自动管理生产者和消费者之间的需求信号，有效控制资源使用。</li></ul><p>Reactor 围绕两个核心发布者（Publisher）实现及其管理订阅和调度的机制展开：</p><ul><li><code>Flux&lt;T&gt;</code>：0到N个元素的异步序列：可以发出零个、一个或多个元素，最后可以发出一个完成信号或一个错误信号。用于处理数据流、事件序列、列表数据等，例如网络请求返回的多个结果。</li><li><code>Mono&lt;T&gt;</code>：0到1个元素的异步序列，最多发出一个元素，最后可以发出一个完成信号或一个错误信号。用于处理单个结果的异步操作，例如根据 ID 查找单个用户、执行一个 void 方法（返回 Mono<Void>）等。</li><li><code>Scheduler</code>：线程调度器，类似于 RxJava 的 Scheduler，用于管理执行上下文和线程切换。<ul><li>Schedulers.elastic(): 动态线程池，适合 IO 任务。</li><li>Schedulers.parallel(): 固定大小线程池，适合计算任务。</li><li>publishOn() &#x2F; subscribeOn(): 用于控制操作符链的执行线程。</li></ul></li><li><code>Subscriber</code>：订阅者&#x2F;消费者，遵循 Reactive Streams 规范的标准接口，用于消费 Flux 或 Mono 发出的数据。onSubscribe(), onNext(), onError(), onComplete(), request() (背压控制)。</li><li><code>Publisher</code>：发布者&#x2F;数据源，Flux 和 Mono 实现的标准接口，定义了 subscribe(Subscriber s) 方法。这是响应式流规范的核心接口，代表可以发出元素和信号的数据源。</li></ul><h3 id="RxJava"><a href="#RxJava" class="headerlink" title="RxJava"></a>RxJava</h3><p>RxJava 的核心功能在于使用可观察序列（observable sequences）来组合异步和基于事件的程序，它将扩展的观察者模式（Observer pattern）应用于数据流和事件流。其核心功能主要围绕四个基本组件及其提供的丰富操作符。</p><ul><li>异步编程与事件处理：RxJava 提供了一种优雅的方式来处理异步操作（如网络请求、数据库查询、用户界面事件），避免了传统回调嵌套导致的“回调地狱”（Callback Hell）。</li><li>链式调用与操作符：RxJava 提供了数百种强大的操作符（Operators），允许开发者以声明式的方式组合、转换、过滤和合并数据流。这些操作符支持流畅的链式调用，使复杂的业务逻辑清晰易懂。</li><li>线程调度（Schedulers）：RxJava 抽象了线程管理，通过 Schedulers 组件，开发者可以轻松地指定代码运行的线程（例如，在 IO 线程执行耗时操作，在主线程更新 UI），从而简化并发编程。</li><li>背压支持（Backpressure）：针对可能产生大量数据的场景（数据生成速度快于消费速度），RxJava 引入了背压机制，允许消费者控制数据源的发送速度，防止系统过载。</li></ul><p>RxJava 的核心概念主要由以下四个基本接口（或类）构成：</p><ul><li><p>Observable &#x2F; Flowable：发出数据或事件的序列。Flowable 专用于支持背压的场景，subscribe(Observer)将观察者与被观察者连接起来。</p></li><li><p>Observer &#x2F; Subscriber：观察者&#x2F;消费者，接收并处理 Observable 或 Flowable 发出的数据或事件。</p><ul><li>onNext(T t): 接收下一个数据项。</li><li>onError(Throwable e): 接收错误通知。</li><li>onComplete(): 接收完成通知（无更多数据）。</li><li>onSubscribe(Disposable d): 建立订阅关系时调用。</li></ul></li><li><p>Disposable：可处置对象，表示一个订阅关系，用于在不需要继续接收数据时取消订阅，防止内存泄漏。</p><ul><li>dispose(): 取消订阅。</li><li>isDisposed(): 检查是否已取消。</li></ul></li><li><p>Scheduler：线程调度器，管理操作符和订阅执行的线程上下文。</p><ul><li>Schedulers.io(): 用于 IO 密集型任务。</li><li>AndroidSchedulers.mainThread(): 在 Android 主线程执行 UI 操作。</li></ul></li><li><p>Single, Maybe, Completable：针对特定场景的简化版数据源。</p><ul><li>Single 只发射一个数据或一个错误；</li><li>Completable 只发射完成信号或错误；</li><li>Maybe 可发射零个或一个数据，以及完成信号或错误。</li></ul></li></ul><h3 id="Akka-Streams"><a href="#Akka-Streams" class="headerlink" title="Akka Streams"></a>Akka Streams</h3><p>Akka Streams建立在强大的 Akka Actor 模型之上，但提供了一个更高级别的抽象，使得开发者无需手动管理底层的背压信号。其核心功能：</p><ul><li>非阻塞背压（Non-Blocking Backpressure）：Akka Streams 完全实现了 Reactive Streams 规范，这是其最核心的功能。数据发送方会根据接收方的处理能力自动调整发送速率，防止资源耗尽或内存溢出。</li><li>有界资源使用（Bounded Resource Usage）：流处理的实体只缓冲有限数量的元素。即使在重负载或高流量输入下，也能确保有界的内存使用，这是它与传统 Actor 模型的一个关键区别。</li><li>声明式 API 与图形 DSL：Akka Streams 提供了流畅的、声明式的领域特定语言（DSL），允许开发者以非常直观的方式描述数据流的拓扑结构（即流经的路径），类似于构建一个计算图（Graph）。</li><li>物化（Materialization）：流的定义（蓝图）本身只是一个描述，必须通过“物化”步骤才能真正运行。物化过程将逻辑流描述转换为正在运行的 Actor 链，并在此过程中处理线程调度和优化（如熔合 Fusing）。</li><li>与 Akka 生态集成：可以方便地与 Akka Actors、Akka HTTP、Akka Kafka 连接器等其他 Akka 模块集成，用于构建完整的分布式、容错系统。</li></ul><p>虽然 Akka Streams 在内部使用 Reactive Streams 接口，但提供给最终用户的 API 是高度抽象的三个核心组件，用于构建任何线性的流处理管道：</p><ul><li><code>Source&lt;Out, Mat&gt;</code>：数据源（Publisher），具有一个输出端口，负责产生数据流的起点。数据可以来自集合、文件、Actor 或其他系统。对应JDK中Publisher。</li><li><code>Flow&lt;In, Out, Mat&gt;</code>：数据转换（Processor），具有一个输入端口和一个输出端口，用于在数据流经过程中进行转换、过滤、映射、聚合等操作。对应JDK中Processor。</li><li><code>Sink&lt;In, Mat&gt;</code>：数据终点（Subscriber），具有一个输入端口，负责消费数据流的终点，例如写入文件、发送给 Actor 或返回单个聚合结果。对应JDK中Subscriber。</li></ul><p>此外，还有两个核心接口：</p><ul><li>RunnableGraph：当 Source、Flow 和 Sink 被连接成一个完整的、封闭的拓扑结构时，就形成了一个可运行的图（Runnable Graph）。调用其 .run(materializer) 方法即可启动流处理。</li><li>Materializer：这是一个至关重要的组件，负责将抽象的 RunnableGraph 转换为实际运行的流处理器实例（由 Akka Actors 支持）。</li></ul><h3 id="RxJava、Project-Reactor、Java-9-Flow区别"><a href="#RxJava、Project-Reactor、Java-9-Flow区别" class="headerlink" title="RxJava、Project Reactor、Java 9 Flow区别"></a>RxJava、Project Reactor、Java 9 Flow区别</h3><p>RxJava、Project Reactor 和 Java 9 Flow API 的主要区别在于它们的定位、功能丰富度以及与特定生态系统的集成。Java 9 Flow 提供了一个标准化的基础接口，而 RxJava 和 Project Reactor 则是功能更全面的实现库，提供了丰富的操作符和实用工具。</p><table><thead><tr><th align="left">特性</th><th align="left">Java 9 Flow</th><th align="left">Project Reactor</th><th align="left">RxJava</th></tr></thead><tbody><tr><td align="left"><strong>定位</strong></td><td align="left">JDK 内置的 <strong>响应式流（Reactive Streams）规范</strong> 接口。</td><td align="left">一个功能齐全的<strong>响应式编程库</strong>。</td><td align="left">ReactiveX 规范的 Java <strong>实现库</strong>。</td></tr><tr><td align="left"><strong>功能</strong></td><td align="left">仅包含基础接口 (<code>Publisher</code>, <code>Subscriber</code>, <code>Subscription</code>, <code>Processor</code>)，<strong>没有具体实现或操作符</strong>。</td><td align="left">拥有丰富的操作符和调试工具，提供 <code>Flux</code> (0..N 个元素) 和 <code>Mono</code> (0..1 个元素) 核心类型。</td><td align="left">拥有数百种操作符，提供 <code>Flowable</code> (支持背压), <code>Observable</code>, <code>Single</code>, <code>Completable</code>, <code>Maybe</code> 等多种类型。</td></tr><tr><td align="left"><strong>背压 (Backpressure)</strong></td><td align="left">作为规范的一部分，要求实现支持背压机制。</td><td align="left">完全支持背压，是其核心特性之一。</td><td align="left"><code>Flowable</code> 类专门用于处理支持背压的数据流。</td></tr><tr><td align="left"><strong>主要用途&#x2F;生态</strong></td><td align="left">作为其他响应式库互操作性的基础标准。</td><td align="left"><strong>与 Spring WebFlux 紧密集成</strong>，常用于构建响应式微服务和非阻塞 API。</td><td align="left">广泛应用于 <strong>Android 开发</strong>和通用的事件驱动架构。</td></tr><tr><td align="left"><strong>学习曲线</strong></td><td align="left">简单，因为它只是几个接口。</td><td align="left">学习曲线中等，操作符丰富，但有良好的文档和调试支持。</td><td align="left">学习曲线较陡峭，概念和操作符众多。</td></tr></tbody></table><h2 id="jdk-Flow"><a href="#jdk-Flow" class="headerlink" title="jdk Flow"></a>jdk Flow</h2><p>Java Flow API 的设计初衷是提供一个标准化的接口规范，而不是一个完整的终端用户库（如 RxJava 或 Project Reactor）。因此，JDK 默认不包含丰富的实现类或操作符。它的主要作用是作为不同响应式库之间的互操作性标准，使它们能够无缝协作。 Java Flow API 包含在 java.util.concurrent.Flow 类中，由四个静态嵌套接口组成：</p><ul><li><code>Flow.Publisher&lt;T&gt;</code>：发布者（数据源），负责生产数据流并将其发送给已订阅的 Subscriber。它只包含一个方法 subscribe(Subscriber&lt;? super T&gt; subscriber)。</li><li><code>Flow.Subscriber&lt;T&gt;</code>：订阅者（消费者），负责消费 Publisher 发出的数据。它定义了四个生命周期方法：onSubscribe, onNext, onError, onComplete。</li><li><code>Flow.Subscription</code>：上下文，代表 Publisher 和 Subscriber 之间的连接，用于管理背压（backpressure）。它有两个关键方法：request(long n)（订阅者请求数据）和 cancel()（取消订阅）。</li><li><code>Flow.Processor&lt;T, R&gt;</code>：处理器，兼具 Subscriber 和 Publisher 的双重角色，用于在流中进行数据转换（例如，从类型 T 转换为类型 R）。</li></ul><p>在标准的 JDK 中，Java 9 Flow API 仅提供了一个具体的、开箱即用的 Publisher 实现类： </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubmissionPublisher</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Publisher</span>&lt;T&gt;, AutoCloseable &#123;<br>  <span class="hljs-comment">// 任务队列</span><br>  BufferedSubscription&lt;T&gt; clients;<br><br>  <span class="hljs-comment">/** The largest possible power of two array size. */</span><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">BUFFER_CAPACITY_LIMIT</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * Default executor -- ForkJoinPool.commonPool() unless it cannot</span><br><span class="hljs-comment">  * support parallelism.</span><br><span class="hljs-comment">  */</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Executor</span> <span class="hljs-variable">ASYNC_POOL</span> <span class="hljs-operator">=</span><br>      (ForkJoinPool.getCommonPoolParallelism() &gt; <span class="hljs-number">1</span>) ?<br>      ForkJoinPool.commonPool() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPerTaskExecutor</span>();<br><br>  <span class="hljs-comment">/** Fallback if ForkJoinPool.commonPool() cannot support parallelism */</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPerTaskExecutor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Executor</span> &#123;<br>      ThreadPerTaskExecutor() &#123;&#125;      <span class="hljs-comment">// prevent access constructor creation</span><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable r)</span> &#123; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r).start(); &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">SubmissionPublisher</span><span class="hljs-params">(Executor executor, <span class="hljs-type">int</span> maxBufferCapacity,</span><br><span class="hljs-params">                               BiConsumer&lt;? <span class="hljs-built_in">super</span> Subscriber&lt;? <span class="hljs-built_in">super</span> T&gt;, ? <span class="hljs-built_in">super</span> Throwable&gt; handler)</span> &#123;<br>    <span class="hljs-keyword">if</span> (executor == <span class="hljs-literal">null</span>)<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-keyword">if</span> (maxBufferCapacity &lt;= <span class="hljs-number">0</span>)<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;capacity must be positive&quot;</span>);<br>    <span class="hljs-built_in">this</span>.lock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-built_in">this</span>.executor = executor;<br>    <span class="hljs-built_in">this</span>.onNextHandler = handler;<br>    <span class="hljs-built_in">this</span>.maxBufferCapacity = roundCapacity(maxBufferCapacity);<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsumerSubscriber</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Subscriber</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">final</span> CompletableFuture&lt;Void&gt; status;<br>    <span class="hljs-keyword">final</span> Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; consumer;<br>    Subscription subscription;<br><br>    ConsumerSubscriber(CompletableFuture&lt;Void&gt; status, Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; consumer) &#123;<br>      <span class="hljs-built_in">this</span>.status = status; <span class="hljs-built_in">this</span>.consumer = consumer;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSubscribe</span><span class="hljs-params">(Subscription subscription)</span> &#123;<br>      <span class="hljs-built_in">this</span>.subscription = subscription;<br>      status.whenComplete((v, e) -&gt; subscription.cancel());<br>      <span class="hljs-keyword">if</span> (!status.isDone())<br>        subscription.request(Long.MAX_VALUE);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onError</span><span class="hljs-params">(Throwable ex)</span> &#123;<br>      status.completeExceptionally(ex);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onComplete</span><span class="hljs-params">()</span> &#123;<br>      status.complete(<span class="hljs-literal">null</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onNext</span><span class="hljs-params">(T item)</span> &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        consumer.accept(item);<br>      &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        subscription.cancel();<br>        status.completeExceptionally(ex);<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-meta">@jdk</span>.internal.vm.annotation.Contended<br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BufferedSubscription</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Subscription</span>, ForkJoinPool.ManagedBlocker &#123;<br>    <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="JDK-Flow使用示例"><a href="#JDK-Flow使用示例" class="headerlink" title="JDK Flow使用示例"></a>JDK Flow使用示例</h3><p>需要自定义实现：Subscriber与Processor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdkFlowExample</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">// 1. 定义发布者, 发布的数据类型是 Integer</span><br>    <span class="hljs-comment">// 直接使用jdk自带的SubmissionPublisher, 它实现了 Publisher 接口</span><br>    <span class="hljs-keyword">try</span> (SubmissionPublisher&lt;Integer&gt; publisher = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubmissionPublisher</span>&lt;&gt;()) &#123;<br>      <span class="hljs-comment">// 2. 定义订阅者</span><br>      <span class="hljs-type">DefaultSubscriber</span> <span class="hljs-variable">subscriber</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultSubscriber</span>();<br><br>      <span class="hljs-comment">// 3. 发布者和订阅者 建立订阅关系</span><br>      publisher.subscribe(subscriber);<br>      <span class="hljs-comment">// 4. 生产数据, 并发布</span><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        <span class="hljs-comment">// submit是个block方法</span><br>        publisher.submit(i);<br>      &#125;<br>    &#125;<br><br>    Thread.sleep(<span class="hljs-number">10000L</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultSubscriber</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Subscriber</span>&lt;Integer&gt; &#123;<br>    <span class="hljs-keyword">private</span> Subscription subscription;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSubscribe</span><span class="hljs-params">(Subscription subscription)</span> &#123;<br>      <span class="hljs-comment">// 保存订阅关系, 需要用它来给发布者响应</span><br>      <span class="hljs-built_in">this</span>.subscription = subscription;<br>      <span class="hljs-comment">// 请求一个数据</span><br>      <span class="hljs-built_in">this</span>.subscription.request(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onNext</span><span class="hljs-params">(Integer item)</span> &#123;<br>      <span class="hljs-comment">// 接受到一个数据, 处理</span><br>      System.out.println(<span class="hljs-string">&quot;接受到数据: &quot;</span> + item);<br><br>      <span class="hljs-keyword">try</span> &#123;<br>        TimeUnit.MILLISECONDS.sleep(<span class="hljs-number">10</span>);<br>      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>      &#125;<br><br>      <span class="hljs-comment">// 处理完调用request再请求一个数据</span><br>      <span class="hljs-built_in">this</span>.subscription.request(<span class="hljs-number">1</span>);<br><br>      <span class="hljs-comment">// 或者 已经达到了目标, 调用cancel告诉发布者不再接受数据了</span><br>      <span class="hljs-comment">// this.subscription.cancel();</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onError</span><span class="hljs-params">(Throwable throwable)</span> &#123;<br>      <span class="hljs-comment">// 出现了异常(例如处理数据的时候产生了异常)</span><br>      throwable.printStackTrace();<br>      <span class="hljs-comment">// 我们可以告诉发布者, 后面不接受数据了</span><br>      <span class="hljs-built_in">this</span>.subscription.cancel();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onComplete</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// 全部数据处理完了(发布者关闭了)</span><br>      System.out.println(<span class="hljs-string">&quot;处理完了!&quot;</span>);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SubmissionPublisher</span>&lt;String&gt; <span class="hljs-keyword">implements</span><br>      <span class="hljs-title class_">Processor</span>&lt;Integer, String&gt; &#123;<br>    <span class="hljs-keyword">private</span> Subscription subscription;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSubscribe</span><span class="hljs-params">(Subscription subscription)</span> &#123;<br>      <span class="hljs-built_in">this</span>.subscription = subscription;<br>      <span class="hljs-comment">// 请求一个数据</span><br>      <span class="hljs-built_in">this</span>.subscription.request(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onNext</span><span class="hljs-params">(Integer item)</span> &#123;<br>      <span class="hljs-comment">// 接受到一个数据, 处理</span><br>      System.out.println(<span class="hljs-string">&quot;处理器接受到数据: &quot;</span> + item);<br>      <span class="hljs-comment">// 过滤掉小于0的, 然后发布出去</span><br>      <span class="hljs-keyword">if</span> (item &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">this</span>.submit(<span class="hljs-string">&quot;转换后的数据:&quot;</span> + item);<br>      &#125;<br>      <span class="hljs-comment">// 处理完调用request再请求一个数据</span><br>      <span class="hljs-built_in">this</span>.subscription.request(<span class="hljs-number">1</span>);<br>      <span class="hljs-comment">// 或者 已经达到了目标, 调用cancel告诉发布者不再接受数据了</span><br>      <span class="hljs-comment">// this.subscription.cancel();</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onError</span><span class="hljs-params">(Throwable throwable)</span> &#123;<br>      <span class="hljs-comment">// 出现了异常(例如处理数据的时候产生了异常)</span><br>      throwable.printStackTrace();<br>      <span class="hljs-comment">// 告诉发布者, 后面不接受数据了</span><br>      <span class="hljs-built_in">this</span>.subscription.cancel();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onComplete</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// 全部数据处理完了(发布者关闭了)</span><br>      System.out.println(<span class="hljs-string">&quot;处理器处理完了!&quot;</span>);<br>      <span class="hljs-comment">// 关闭发布者</span><br>      <span class="hljs-built_in">this</span>.close();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>异步</category>
      
      <category>响应式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>异步</tag>
      
      <tag>响应式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式中件间-Consul基础使用</title>
    <link href="/2025/08/10/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6-consul%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    <url>/2025/08/10/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6-consul%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="https://developer.hashicorp.com/">Consul</a>是一种分布式服务网格（Service Mesh）解决方案，提供服务发现、健康检查、键&#x2F;值存储、多数据中心管理等功能。核心组件包括客户端（Agent）、服务器（Server）、以及多种通信协议（Gossip、<a href="https://ares081.github.io/2025/07/28/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95Raft%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/">Raft</a>、RPC）的协同工作。</p><p>consul提供的功能特性：</p><ul><li>多数据中心：Consul 被构建为数据中心感知的，可以支持任意数量的区域，而不需要复杂的配置。</li><li>服务网格&#x2F;服务细分：使用自动 TLS 加密和基于身份的授权实现安全的服务对服务通信。应用程序可以在服务网格配置中使用 sidecar 代理为入站和出站连接建立 TLS 连接，而完全不知道连接方。</li><li>服务发现：Consul 使服务注册自己和通过 DNS 或 HTTP 接口发现其他服务变得简单。也可以注册外部服务，如 SaaS 提供者。</li><li>健康检查：健康检查使得 Consul 能够就集群中的任何问题快速向操作员发出警报。与服务发现的集成可以防止将流量路由到不健康的主机，并启用服务级断路器。</li><li>Key&#x2F;Value存储：一个灵活的键&#x2F;值存储允许存储动态配置、特性标记、协调、领导选举等。简单的 HTTP API 使得在任何地方都可以轻松使用。</li></ul><p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6-consul%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90_Consul%E9%83%A8%E7%BD%B2%E6%9E%B6%E6%9E%84.png"></p><span id="more"></span><p>Agent，在Consul中不管Client或是Server都是Agent:</p><ul><li>Client（客户端&#x2F;Agent）：客户端是无状态的，负责将服务注册、健康检查等请求转发给Consul服务器。它运行在每个需要使用Consul服务节点（物理机、虚拟机或容器）的守护进程，维护着本地节点和服务的状态，并通过Gossip协议与集群中的其他代理通信。</li><li>Server（服务器）：负责存储、复制和管理集群状态的关键数据。服务器节点通常部署3到5台，以确保高可用性和数据一致性，底层通过Raft一致性算法选举出一个Leader（领导者），其他节点为Follower（追随者）。所有关键数据的写入和事务请求都由Leader处理，Follower则响应RPC查询并负责数据同步。</li></ul><p>以dev模式运行示例：单机运行通常使用<code>consul agent -dev</code>，下面是带配置文件的运行方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs hcl">#server.hcl<br>datacenter = &quot;dev-dc1&quot;<br>primary_datacenter = &quot;dev-dc1&quot;<br>data_dir = &quot;/opt/app-data/consul&quot;<br>bind_addr = &quot;127.0.0.1&quot;<br>node_name = &quot;consul-server-01&quot;<br>client_addr = &quot;127.0.0.1&quot;<br><br>server = true<br>bootstrap_expect = 1 <br>#retry_join = [&quot;192.168.1.10&quot;, &quot;192.168.1.11&quot;, &quot;192.168.1.12&quot;]<br><br>encrypt = &quot;E2V40IyXw7QsbQEDh+gjMbHeBDK0J4K9JLQvKIRx7vY=&quot;<br><br>acl &#123;<br>  enabled = true<br>  default_policy = &quot;deny&quot;<br>  enable_token_persistence = true<br>  tokens &#123;<br>      initial_management =  &quot;1fb9ffca-d8cb-4cb5-be9a-5c4bcfca1ed0&quot;<br>      agent = &quot;622dc12d-ad9d-cfa4-654d-3597bf7954a1&quot; <br>  &#125;<br>&#125;<br><br>log_file = &quot;/opt/app-data/consul/log/consul.log&quot;<br><br>log_level = &quot;INFO&quot;<br>log_rotate_bytes = 104857600<br>log_rotate_duration = &quot;24h&quot;<br><br>enable_script_checks = false<br>enable_local_script_checks = false<br><br>ui_config &#123;<br>  enabled = true<br>&#125;<br></code></pre></td></tr></table></figure><p>执行命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">consul agent -config-file=./server.hcl<br>consul acl policy create -name <span class="hljs-string">&quot;agent-token-policy&quot;</span> -rules @agent-policy.hcl  <span class="hljs-comment"># 如果不执行，会报[WARN]  agent: Coordinate update blocked by ACLs: accessorID=&quot;anonymous token&quot;</span><br>consul acl token create -description <span class="hljs-string">&quot;Token for Consul agent internal operations&quot;</span> -policy-name <span class="hljs-string">&quot;agent-token-policy&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6-consul%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90_agent-token.png"></p><p>其中SecretID就是 agent token，然后在 server.hcl文件中添加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs hcl">acl &#123;<br>  enabled = true<br>  default_policy = &quot;deny&quot;<br>  enable_token_persistence = true<br>  tokens &#123;<br>      initial_management =  &quot;1fb9ffca-d8cb-4cb5-be9a-5c4bcfca1ed0&quot;<br>      agent = &quot;622dc12d-ad9d-cfa4-654d-3597bf7954a1&quot; # 添加这一行<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>重启：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">consul agent -config-file=./server.hcl<br></code></pre></td></tr></table></figure><p>配置参数说明：</p><ul><li>datacenter: 指定当前 Consul 节点所属的数据中心名称，默认值 dc1。所有未显式指定数据中心的操作默认在该 DC 内进行。多数据中心部署时，每个 DC 应使用唯一名称，同一集群内所有节点必须属于同一个数据中心。</li><li>primary_datacenter：指定 主数据中心。用于ACL 系统与Connect CA。</li><li>data_dir：Consul 存放持久化数据的目录（如 Raft 日志、快照、服务注册信息等）。必须为 绝对路径，Server 节点必须使用本地磁盘（不能是 NFS 等网络存储）。</li><li>enable_script_checks：是否允许通过 script 字段定义健康检查脚本（如 “script”: “&#x2F;check.sh”）。出于安全考虑，默认禁用的，若启用，需确保脚本来源可信，防止任意代码执行，推荐使用 HTTP&#x2F;TCP&#x2F;Docker 检查替代。</li><li>bind_addr：Consul Agent 用于集群通信（Gossip、RPC）的绑定地址，默认值0.0.0.0。通常设为节点内网 IP（如 192.168.10.5），必须能被集群内其他节点访问。生产环境不要设为 127.0.0.1。<strong>HTTP API 地址由 client_addr 控制（默认仅 127.0.0.1），与 bind_addr 不同</strong>。</li><li>node_name：当前节点在 Consul 集群中的唯一名称，默认值为主机名（hostname），必须在整个集群中唯一。</li><li>enable_local_script_checks：允许仅在本地注册的服务（通过 HTTP API 或 CLI 注册）使用脚本健康检查。比 enable_script_checks 更细粒度，仍存在安全风险，生产环境建议关闭。</li><li>log_file：指定日志文件路径，启用日志文件输出。需配合 log_rotate_bytes 和 log_rotate_duration 使用。</li><li>log_level：设置日志级别，默认值为INFO。生产环境通常用 INFO 或 WARN，调试时可用 DEBUG。可选值：TRACE, DEBUG, INFO, WARN, ERROR。</li><li>log_rotate_bytes：单个日志文件的最大大小（超过则轮转）。</li><li>log_rotate_duration：强制日志轮转的时间间隔（即使未达到 log_rotate_bytes）。</li><li>encrypt：用于 Gossip 协议通信加密 的密钥（Base64 编码），可通过 consul keygen 生成，集群内所有节点必须使用相同的密钥。注意：此加密仅用于 - Serf Gossip（成员关系、事件广播），不用于 RPC 或 HTTP API。</li><li>acl.enabled：是否启用 ACL（访问控制列表）系统。启用后，所有 API 请求需携带有效 Token。</li><li>acl.default_policy：默认 ACL 策略行为。allow，未匹配任何规则时允许操作（宽松模式）。deny，未匹配时拒绝操作（零信任，推荐生产使用）。</li><li>acl.enable_token_persistence：是否将通过 API 创建的 Token 持久化到 Raft 日志（即重启后保留）。若为 false，Token 仅存在于内存（重启丢 失），生产环境应设为 true。</li><li>acl.tokens.initial_management：设置 初始 Master Token（也称 Bootstrap Token）。仅在首次启动 ACL 系统时使用，拥有最高权限（可管理所有策略和 Token），首次启动后应立即删除或妥善保管，并创建更细粒度的 Token。后续启动无需再配置此字段（否则会报错）。</li></ul><h3 id="consul基础命令"><a href="#consul基础命令" class="headerlink" title="consul基础命令"></a>consul基础命令</h3><p><a href="https://developer.hashicorp.com/consul/commands">CLI</a></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs text">consul<br>Usage: consul [--version] [--help] &lt;command&gt; [&lt;args&gt;]<br><br>Available commands are:<br>    acl            Interact with Consul&#x27;s ACLs<br>    agent          Runs a Consul agent<br>    catalog        Interact with the catalog<br>    connect        Interact with service mesh functionality<br>    debug          Records a debugging archive for operators<br>    event          Fire a new event<br>    exec           Executes a command on Consul nodes<br>    force-leave    Forces a member of the cluster to enter the &quot;left&quot; state<br>    info           Provides debugging information for operators.<br>    intention      Interact with service mesh intentions<br>    join           Tell Consul agent to join cluster<br>    keygen         Generates a new encryption key<br>    keyring        Manages gossip layer encryption keys<br>    kv             Interact with the key-value store<br>    leave          Gracefully leaves the Consul cluster and shuts down<br>    lock           Execute a command holding a lock<br>    login          Login to Consul using an auth method<br>    logout         Destroy a Consul token created with login<br>    maint          Controls node or service maintenance mode<br>    members        Lists the members of a Consul cluster<br>    monitor        Stream logs from a Consul agent<br>    operator       Provides cluster-level tools for Consul operators<br>    peering        Create and manage peering connections between Consul clusters<br>    reload         Triggers the agent to reload configuration files<br>    rtt            Estimates network round trip time between nodes<br>    services       Interact with services<br>    snapshot       Saves, restores and inspects snapshots of Consul server state<br>    tls            Builtin helpers for creating CAs and certificates<br>    troubleshoot   Provides tools to troubleshoot Consul&#x27;s service mesh configuration<br>    validate       Validate config files/directories<br>    version        Prints the Consul version<br>    watch          Watch for changes in Consul<br></code></pre></td></tr></table></figure><h4 id="重要命令说明："><a href="#重要命令说明：" class="headerlink" title="重要命令说明："></a>重要命令说明：</h4><ol><li>启动 &#x2F; 版本 &#x2F; 帮助：</li></ol><ul><li>consul version： 查看版本</li><li><code>consul -h/consul &lt;subcommand&gt; -h</code>：查看帮助</li><li>consul agent -dev：快速启动一个开发模式的单节点 agent</li></ul><hr><ol start="2"><li>Agent &#x2F; 成员 &#x2F; 加入 &#x2F; 离开</li></ol><ul><li>consul agent -config-dir&#x3D;&#x2F;etc&#x2F;consul.d：启动 agent（server 或 client 由 -server 指定，或在配置文件中设置）</li><li>consul join &lt;IP|HOST&gt; ：加入集群（把当前 agent 加入到已有节点），如 <code>consul join 10.0.0.5</code></li><li>consul leave：离开集群</li><li>consul members：列出当前 agent 能看到的成员</li></ul><hr><ol start="3"><li>Catalog（节点&#x2F;服务目录）</li></ol><ul><li>consul catalog services：列出集群中所有服务</li><li><code>consul catalog nodes -service=&lt;SERVICE_NAME&gt;</code>：列出某服务对应的节点 </li><li>consul catalog register service.json consul catalog deregister service.json：手动注册&#x2F;反注册</li></ul><hr><ol start="4"><li>服务与健康检查（通过 agent 注册服务）</li></ol><ul><li>使用 JSON 文件注册服务：这是常见方式。consul services register svc.json consul services deregister svc.json：</li><li>通过 agent 本地命令注册：<code>consul agent service register -name web -address 10.0.0.10 -port 80 consul agent service deregister &lt;service_id&gt;</code></li></ul><hr><ol start="5"><li>KV（键值存储）</li></ol><ul><li>写入键：<code>consul kv put &lt;key&gt; &lt;value&gt;</code></li><li>读取键（默认显示 base64 编码结果)：<code>consul kv get &lt;key&gt; </code></li><li>删除键：<code>consul kv delete &lt;key&gt;</code></li><li>递归删除前缀：<code>consul kv delete -recurse &lt;prefix&gt;</code></li><li>列出前缀下所有键：<code>consul kv get -recurse &lt;prefix&gt;</code></li></ul><hr><ol start="6"><li>ACL（访问控制）：在启用 ACL 时，需要设置 CONSUL_HTTP_TOKEN 环境变量或在请求中加入 <code>?token=&lt;token&gt;</code></li></ol><ul><li>引导：首次启动时获得管理 token， consul acl bootstrap</li><li>创建： consul acl token create -description “deploy token”</li><li>列表 &#x2F; 查看： token consul acl token list consul acl token read <code>&lt;token-id&gt;</code></li></ul><hr><ol start="7"><li>Raft &#x2F; operator（运维相关）</li></ol><ul><li>查看 Raft 节点与 leader（典型）： consul operator raft list-peers</li><li>强制移除 Raft peer（谨慎）： consul operator raft remove-peer <code>&lt;ID&gt;</code></li><li>保存&#x2F;恢复快照（备份&#x2F;恢复）： consul snapshot save backup.snap consul snapshot restore backup.snap</li></ul><hr><ol start="8"><li>Consul Connect（服务网格相关）</li></ol><ul><li>启动本地代理: consul connect proxy -sidecar-for <code>&lt;service&gt;</code></li><li>列出 intentions：服务间访问控制，consul connect intentions list</li></ul><hr><ol start="9"><li>监控 &#x2F; 日志 &#x2F; 信息</li></ol><ul><li>实时查看 agent 日志输出：consul monitor</li><li>获取 agent 信息（配置、成员等）：consul info</li></ul><hr><ol start="10"><li>Watch（事件&#x2F;Key 触发）</li></ol><ul><li>使用 watch 的简单命令行方式（通常写在配置中） consul watch -type&#x3D;key -key&#x3D;”config&#x2F;foo” -handler&#x3D;”&#x2F;path&#x2F;to&#x2F;script.sh”</li></ul><h4 id="示例：注册mysql到consul"><a href="#示例：注册mysql到consul" class="headerlink" title="示例：注册mysql到consul"></a>示例：注册mysql到consul</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span> <br>  <span class="hljs-attr">&quot;service&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;mysql&quot;</span><span class="hljs-punctuation">,</span> <br>    <span class="hljs-attr">&quot;tags&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;database&quot;</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span> <br>    <span class="hljs-attr">&quot;port&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3306</span> <br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span> <br>  <span class="hljs-attr">&quot;checks&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span> <span class="hljs-punctuation">&#123;</span> <br>    <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;MySQL TCP Check&quot;</span><span class="hljs-punctuation">,</span> <br>    <span class="hljs-attr">&quot;tcp&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;localhost:3306&quot;</span><span class="hljs-punctuation">,</span> <br>    <span class="hljs-attr">&quot;interval&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;10s&quot;</span><span class="hljs-punctuation">,</span> <br>    <span class="hljs-attr">&quot;timeout&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1s&quot;</span> <br>  <span class="hljs-punctuation">&#125;</span> <span class="hljs-punctuation">]</span> <br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>注册：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs hcl">consul services register mysql-service.json<br></code></pre></td></tr></table></figure><h3 id="Consul-API"><a href="#Consul-API" class="headerlink" title="Consul API"></a>Consul API</h3><p>Consul不仅有丰富的 CLI 命令，还提供了一套强大的 <a href="https://developer.hashicorp.com/consul/api-docs">API</a>，用于与 Consul 服务进行交互。Consul HTTP API 为 &#x2F;v1&#x2F; 开头，如 &#x2F;v1&#x2F;kv、&#x2F;v1&#x2F;catalog 等。支持 HTTP&#x2F;HTTPS，若开启 ACL，需要在请求中通过 HTTP 头 X-Consul-Token 或环境变量 CONSUL_HTTP_TOKEN 提供 token。响应格式通常为 JSON。KV 的值在默认 JSON 返回中为 base64 编码，可以使用 ?raw 来获取原始值。</p><p>核心认证&#x2F;请求头：</p><ul><li>X-Consul-Token (请求头)：ACL token，用于授权所有需要权限的 API 调用（读&#x2F;写&#x2F;管理）。这是 Consul 官方推荐的方式；也可以用 ?token&#x3D;<token> 查询参数，但不推荐用于公开场景。<code>curl -H &quot;X-Consul-Token: $CONSUL_TOKEN&quot; http://127.0.0.1:8500/v1/kv/app/conf?raw</code></li><li>Authorization: Bearer <code>&lt;token&gt;</code>：部分版本&#x2F;集成支持，但 X-Consul-Token 始终是明确的首选。</li><li>X-Request-Id：自定义追踪头，由前端代理或网关提供请求 ID，便于追踪与排错，Consul 本身不强制，但可传递。</li><li>Content-Type：标准HTTP头，在请求方法POST&#x2F;PUT&#x2F;PUT JSON 数据时设为 application&#x2F;json。</li><li>Accept：标准HTTP头，指定能接受的响应类型（一般默认 JSON）。</li></ul><p>响应头重要项：<strong>用于一致性、长轮询与状态</strong></p><ul><li>X-Consul-Index：服务端返回的全局修改索引，用于实现阻塞查询（long-polling）。客户端保存此索引并在后续请求通过 <code>?index=&lt;last-index&gt;&amp;wait=&lt;duration&gt;</code>实现阻塞等待数据变更，请求会在有更新或超时后返回，并在响应头包含新的 X-Consul-Index。通常在KV、Catalog、Health 等可以用来做高效事件监听&#x2F;同步。</li><li>X-Consul-KnownLeader：布尔值（”true”&#x2F;“false”），表示 agent 是否知道当前 datacenter 的 Raft leader。用于判断节点是否与 leader 通信正常，适合健康检查与监控告警。</li><li>X-Consul-LastContact：与 leader 的最后接触时间（ms），可用于判定网络抖动或 leader 连接问题。</li></ul><h4 id="重要接口说明"><a href="#重要接口说明" class="headerlink" title="重要接口说明"></a>重要接口说明</h4><ol><li>KV（键值存储）</li></ol><ul><li>路径 &#x2F; 方法<ul><li>GET &#x2F;v1&#x2F;kv&#x2F;<key>            — 读取键（返回 JSON 或 ?raw）</li><li>PUT &#x2F;v1&#x2F;kv&#x2F;<key>            — 写入键（请求体为值）</li><li>DELETE &#x2F;v1&#x2F;kv&#x2F;<key>         — 删除键</li><li>GET &#x2F;v1&#x2F;kv&#x2F;<prefix>?recurse — 递归列出前缀</li></ul></li><li>重要参数<ul><li>?raw、?recurse、?flags、?cas、?acquire、?release</li><li>长轮询：?index&#x3D;<n>&amp;wait&#x3D;<duration></li></ul></li><li>示例<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --request PUT http://127.0.0.1:8500/v1/kv/config/name -d <span class="hljs-string">&#x27;myapp&#x27;</span><br>curl http://127.0.0.1:8500/v1/kv/config/name?raw<br>curl <span class="hljs-string">&quot;http://127.0.0.1:8500/v1/kv/config/name?index=100&amp;wait=5m&quot;</span><br></code></pre></td></tr></table></figure></li><li>注意<ul><li>值在 JSON 返回中为 base64；使用 ?raw 简化读取。</li><li>支持与 session 结合的分布式锁（acquire&#x2F;release）。</li></ul></li></ul><hr><ol start="2"><li>Agent（本地 agent 操作）</li></ol><ul><li>路径 &#x2F; 方法<ul><li>GET  &#x2F;v1&#x2F;agent&#x2F;services                    — 列出本地注册服务</li><li>PUT  &#x2F;v1&#x2F;agent&#x2F;service&#x2F;register            — 本地注册服务（JSON body）</li><li>PUT  &#x2F;v1&#x2F;agent&#x2F;service&#x2F;deregister&#x2F;<id>     — 注销服务</li><li>GET  &#x2F;v1&#x2F;agent&#x2F;self                        — agent 本身信息</li></ul></li><li>示例<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --request PUT --data @svc.json http://127.0.0.1:8500/v1/agent/service/register<br>curl http://127.0.0.1:8500/v1/agent/services<br></code></pre></td></tr></table></figure></li></ul><hr><ol start="3"><li>Catalog（节点&#x2F;服务目录）</li></ol><ul><li>路径 &#x2F; 方法<ul><li>GET &#x2F;v1&#x2F;catalog&#x2F;services               — 列出服务名和标签</li><li>GET &#x2F;v1&#x2F;catalog&#x2F;service&#x2F;<service>      — 列出提供该服务的节点</li><li>GET &#x2F;v1&#x2F;catalog&#x2F;nodes                  — 列出节点</li></ul></li><li>示例<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl http://127.0.0.1:8500/v1/catalog/services<br>curl http://127.0.0.1:8500/v1/catalog/service/web<br></code></pre></td></tr></table></figure></li></ul><hr><ol start="4"><li>Health（健康检查）</li></ol><ul><li>路径 &#x2F; 方法<ul><li>GET &#x2F;v1&#x2F;health&#x2F;checks&#x2F;<service>        — 返回服务的检查项</li><li>GET &#x2F;v1&#x2F;health&#x2F;service&#x2F;<service>       — 返回带健康状态的服务实例列表</li><li>GET &#x2F;v1&#x2F;health&#x2F;state&#x2F;<state>           — state &#x3D; passing|warning|critical</li></ul></li><li>示例<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl http://127.0.0.1:8500/v1/health/service/web<br>curl http://127.0.0.1:8500/v1/health/state/critical<br></code></pre></td></tr></table></figure></li></ul><hr><ol start="5"><li>Session（会话，用于锁&#x2F;选主）</li></ol><ul><li>路径 &#x2F; 方法<ul><li>PUT &#x2F;v1&#x2F;session&#x2F;create                 — 创建 session（JSON body）</li><li>GET &#x2F;v1&#x2F;session&#x2F;list                   — 列出 sessions</li><li>PUT &#x2F;v1&#x2F;session&#x2F;destroy&#x2F;<id>           — 销毁 session</li></ul></li><li>示例<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --request PUT --data <span class="hljs-string">&#x27;&#123;&quot;LockDelay&quot;:&quot;15s&quot;,&quot;Name&quot;:&quot;my-session&quot;&#125;&#x27;</span> http://127.0.0.1:8500/v1/session/create<br></code></pre></td></tr></table></figure></li><li>场景<ul><li>与 KV 的 ?acquire&#x3D;<sessionID> &#x2F; ?release&#x3D;<sessionID> 实现分布式锁或 leader 选举。</li></ul></li></ul><hr><ol start="6"><li>Transactions（原子事务）</li></ol><ul><li>路径 &#x2F; 方法<ul><li>PUT &#x2F;v1&#x2F;txn                            — 接受一个操作数组，原子执行</li></ul></li><li>示例（伪）<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --request PUT --data <span class="hljs-string">&#x27;[&#123;&quot;KV&quot;:&#123;&quot;Verb&quot;:&quot;set&quot;,&quot;Key&quot;:&quot;a&quot;,&quot;Value&quot;:&quot;b64&quot;&#125;&#125;]&#x27;</span> http://127.0.0.1:8500/v1/txn<br></code></pre></td></tr></table></figure></li><li>注意<ul><li>支持多步原子操作（KV、service 等），失败时返回错误详情。</li></ul></li></ul><hr><ol start="7"><li>ACL（访问控制）</li></ol><ul><li>路径 &#x2F; 方法<ul><li>PUT &#x2F;v1&#x2F;acl&#x2F;bootstrap                  — 初始化（返回管理 token）</li><li>PUT &#x2F;v1&#x2F;acl&#x2F;token                      — 创建 token</li><li>GET &#x2F;v1&#x2F;acl&#x2F;token&#x2F;<id>                 — 读取 token</li><li>GET &#x2F;v1&#x2F;acl&#x2F;tokens                     — 列表</li></ul></li><li>示例<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --request PUT http://127.0.0.1:8500/v1/acl/bootstrap<br>curl -H <span class="hljs-string">&quot;X-Consul-Token: <span class="hljs-variable">$BOOTSTRAP</span>&quot;</span> --request PUT --data @token.json http://127.0.0.1:8500/v1/acl/token<br></code></pre></td></tr></table></figure></li><li>安全<ul><li>在生产建议用 HTTPS，最小权限策略，避免将 token 放 URL。</li></ul></li></ul><hr><ol start="8"><li>Operator（运维 &#x2F; Raft &#x2F; 快照）</li></ol><ul><li>路径 &#x2F; 方法<ul><li>GET  &#x2F;v1&#x2F;operator&#x2F;raft&#x2F;configuration   — Raft peers</li><li>PUT  &#x2F;v1&#x2F;operator&#x2F;raft&#x2F;remove-peer     — 移除 peer（谨慎）</li><li>GET  &#x2F;v1&#x2F;operator&#x2F;snapshot             — 下载 snapshot</li></ul></li><li>示例<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl http://127.0.0.1:8500/v1/operator/raft/configuration<br>curl --output backup.snap http://127.0.0.1:8500/v1/operator/snapshot<br></code></pre></td></tr></table></figure></li></ul><hr><ol start="9"><li>Status（集群状态）</li></ol><ul><li>路径 &#x2F; 方法<ul><li>GET &#x2F;v1&#x2F;status&#x2F;leader                  — 返回 leader 地址</li><li>GET &#x2F;v1&#x2F;status&#x2F;peers                   — 返回 raft peers 列表</li></ul></li><li>示例<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl http://127.0.0.1:8500/v1/status/leader<br>curl http://127.0.0.1:8500/v1/status/peers<br></code></pre></td></tr></table></figure></li></ul><hr><ol start="10"><li>Connect（服务网格）</li></ol><ul><li>路径 &#x2F; 方法<ul><li>GET&#x2F;POST &#x2F;v1&#x2F;connect&#x2F;intentions        — 列出&#x2F;创建 intentions（服务间访问控制）</li><li>GET &#x2F;v1&#x2F;connect&#x2F;proxy                    — 代理相关信息</li></ul></li><li>示例<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl http://127.0.0.1:8500/v1/connect/intentions<br></code></pre></td></tr></table></figure></li></ul><hr><ol start="11"><li>Events（事件广播）</li></ol><ul><li>路径 &#x2F; 方法<ul><li>PUT &#x2F;v1&#x2F;event&#x2F;fire&#x2F;<name>              — 触发事件（body 可带负载）</li><li>GET &#x2F;v1&#x2F;event&#x2F;list                     — 列出事件（按名称&#x2F;时间）</li></ul></li><li>示例<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">curl --request PUT --data <span class="hljs-string">&#x27;&#123;&quot;reason&quot;:&quot;reload&quot;&#125;&#x27;</span> http://127.0.0.1:8500/v1/event/fire/reload<br></code></pre></td></tr></table></figure></li></ul><hr><ol start="12"><li>Prepared Queries &#x2F; Query（高级查询）</li></ol><ul><li>路径 &#x2F; 方法<ul><li>POST &#x2F;v1&#x2F;query                         — 创建 prepared query</li><li>GET  &#x2F;v1&#x2F;query&#x2F;<id>&#x2F;execute            — 执行 prepared query</li></ul></li><li>用途<ul><li>预定义发现策略（过滤&#x2F;排序&#x2F;健康策略），便于跨团队复用与权限控制。</li></ul></li></ul><hr><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>常见错误码与含义</p><ul><li>200 OK &#x2F; 204 No Content &#x2F; 201 Created：正常</li><li>400 Bad Request：请求格式或参数错误</li><li>403 Forbidden：ACL 权限不足或 token 无效</li><li>404 Not Found：资源不存在</li><li>500&#x2F;5xx：服务器错误或内部故障</li></ul><p>注意点：</p><ul><li>使用 X-Consul-Token 而非 URL token，且通过 HTTPS 传输。</li><li>长轮询使用 X-Consul-Index + ?index&#x2F;&amp;wait，避免频繁短轮询。</li><li>对会被代理缓存的端点（如阻塞查询）在代理层设置 no-cache。</li><li>在自动化脚本中使用事务（&#x2F;v1&#x2F;txn）避免中间不一致状态。</li><li>在生产使用配置文件 + systemd 管理 Agent，避免 -dev 模式。</li></ul>]]></content>
    
    
    <categories>
      
      <category>架构</category>
      
      <category>分布式</category>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>架构</tag>
      
      <tag>分布式</tag>
      
      <tag>中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式中件间-基于zookeeper实现配置中心</title>
    <link href="/2025/08/07/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6-%E5%9F%BA%E4%BA%8Ezookeeper%E5%AE%9E%E7%8E%B0%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"/>
    <url>/2025/08/07/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6-%E5%9F%BA%E4%BA%8Ezookeeper%E5%AE%9E%E7%8E%B0%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在微服务架构中，通常是将一个大型的单体应用拆解为多个独立的服务，这对于一个服务不同节点的配置管理上的新挑战，如果没有配置中心，这些挑战会显著增加系统的复杂性和维护成本。</p><ol><li><strong>配置分散，难以管理</strong><br>在单体应用中，所有配置都集中在一个配置文件（如 <code>application.properties</code>）中，易于管理。在微服务架构中，每个服务都有自己的配置，一个大型系统可能包含几十甚至上百个微服务，配置也随之分散。如果没有配置中心，开发和运维团队将需要手动管理每个服务的配置文件，这在多环境（开发、测试、生产）部署时尤其困难。</li><li><strong>动态配置，无需重启</strong><br>在单体应用中，修改配置通常需要重新打包和部署整个应用，这在微服务架构中是不可接受的。配置中心支持配置的动态刷新，允许开发者在不重启微服务的情况下更新配置，例如调整日志级别、修改数据库连接、或启用&#x2F;关闭某个功能。这对于快速响应和线上运维至关重要。</li><li><strong>环境隔离，保持一致</strong><br>不同的部署环境（开发、测试、生产）需要不同的配置。例如，数据库连接、第三方API密钥等都不同。配置中心可以根据环境（如通过 <code>application-dev.yml</code>、<code>application-prod.yml</code> 等）存储和管理不同版本的配置，并确保每个服务在启动时都能加载正确的配置，避免因配置错误导致的环境问题。</li><li><strong>安全管理，隔离敏感信息</strong><br>数据库密码、API密钥等敏感信息不应硬编码在代码中。配置中心可以安全地存储这些敏感信息，并提供加密和权限控制，确保只有授权的服务才能访问。</li><li><strong>版本控制，方便回滚</strong><br>配置中心通常与Git等版本控制系统集成，可以对配置进行版本管理。这使得配置的变更历史清晰可查，如果新的配置出现问题，可以快速回滚到之前的版本，大大提高了系统的健壮性。</li><li><strong>提升开发运维效率</strong><br>配置中心将配置从应用代码中分离，实现了<strong>配置与代码的解耦</strong>。这使得开发团队可以专注于业务逻辑的开发，而运维团队可以专注于配置的集中管理和动态调整，显著提升了工作效率。</li></ol><span id="more"></span><p>总之：<strong>配置中心</strong>在微服务架构中扮演着“中央大脑”的角色，通过<strong>集中化、动态化、版本化</strong>的方式管理所有微服务的配置。它解决了传统静态配置文件带来的维护难题，提高了系统的灵活性、可维护性和安全性，是构建和管理大规模微服务系统的关键基础设施。</p><p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6-%E5%9F%BA%E4%BA%8Ezookeeper%E5%AE%9E%E7%8E%B0%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83_ConfigService%E6%9E%B6%E6%9E%84.png"></p><h2 id="常见的实现"><a href="#常见的实现" class="headerlink" title="常见的实现"></a>常见的实现</h2><p>在选择配置中心时，需要综合考虑功能需求、高可用性、易用性、多语言支持和生态成熟度等因素。目前主流的配置中心包括 Apollo、Nacos、Consul 和 Spring Cloud Config。</p><h3 id="Apollo"><a href="#Apollo" class="headerlink" title="Apollo"></a>Apollo</h3><p>Apollo是携程开源的分布式配置管理中心，能够集中化管理应用在不同环境、不同集群的配置，并支持配置修改后实时推送到应用端。解决了微服务架构下配置管理分散、配置变更不及时、配置版本管理混乱、缺乏权限和审计等问题。Apollo支持不同维度的配置：</p><ul><li>应用（AppId）： 唯一的应用程序标识。</li><li>环境（Environment）： 例如DEV、FAT、UAT、PRO等。</li><li>集群（Cluster）： 例如某个机房或特定的部署集群。</li><li>命名空间（Namespace）： 独立的配置管理单元，应用可以通过命名空间共享配置或拥有私有配置。</li></ul><p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6-%E5%9F%BA%E4%BA%8Ezookeeper%E5%AE%9E%E7%8E%B0%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83_Apollo%E6%9E%B6%E6%9E%84.png"></p><p>Apollo 架构是一个典型的分布式微服务架构，它由多个独立的服务组件构成，协同工作以提供完整的配置管理功能，这种设计确保了系统的高可用性、可扩展性和容错性：</p><ul><li>Portal： 配置管理界面，供用户管理应用、环境、集群和命名空间。</li><li>Config Service： 提供配置读取、推送和管理接口。</li><li>Admin Service： 提供配置的增删改查接口，供Portal调用。</li><li>Meta Server： 负责服务发现，提供Config Service和Admin Service的地址信息。</li><li>Client： 应用嵌入的SDK，用于获取和监听配置。</li><li>Eureka： 用于服务注册和发现。</li></ul><h4 id="Apollo核心逻辑"><a href="#Apollo核心逻辑" class="headerlink" title="Apollo核心逻辑"></a>Apollo核心逻辑</h4><p>Apollo通过长轮询（Long Polling）机制结合消息队列和本地缓存，实现了配置的实时更新和高可用性。整个流程可以分为配置发布（服务端）和客户端感知（客户端）两个部分。</p><ol><li><strong>服务端配置发布流程</strong>：当管理员在Apollo Portal发布配置时，会触发以下流程：</li></ol><ul><li>发布配置： 管理员在Portal上修改并发布某个应用、环境和命名空间的配置。</li><li>Admin Service： Portal调用Admin Service的接口，将配置变更持久化到数据库中。</li><li>发送消息： Admin Service在数据库中保存配置变更的同时，会发送一个ReleaseMessage（发布消息）到消息队列（通常是InMemory队列，但可以扩展为Kafka等）。</li><li>Config Service监听： Config Service会监听消息队列，当收到ReleaseMessage时，表示有新的配置发布。</li></ul><ol start="2"><li><strong>应用服务配置感知与更新流程</strong>：应用服务在启动后，会以长轮询的方式与Config Service保持通信，等待配置更新。</li></ol><ul><li><p>客户端长轮询</p><ul><li>发起长轮询： 客户端会异步地向Config Service的notifications&#x2F;v2接口发起HTTP长轮询请求。</li><li>服务暂挂： Config Service接收到客户端的请求后，并不会立即响应。如果此时没有配置更新，Config Service会利用异步Servlet（如Spring的DeferredResult）将该请求挂起，最长等待60秒。</li></ul></li><li><p>配置有更新：</p><ul><li>当Config Service从消息队列中接收到配置发布消息后，会通知所有被挂起的客户端请求。</li><li>所有相关客户端的请求立即返回，响应体中包含更新通知。</li></ul></li><li><p>配置无更新：</p><ul><li>如果60秒超时，但期间没有任何配置更新，Config Service会返回一个空响应给客户端。</li><li>客户端收到响应后，会立即发起下一次长轮询请求，继续等待。</li></ul></li><li><p>客户端拉取最新配置</p><ul><li>收到通知：客户端从长轮询请求中得知有配置更新后，会主动向Config Service的configfiles接口发起短连接请求，拉取最新的配置内容。</li><li>更新本地缓存：客户端会将最新配置写入本地缓存文件，以防止网络或服务器故障，确保应用重启时能够恢复。</li><li>通知应用：客户端的监听器（ConfigChangeListener）会被触发，将最新的配置通知到应用程序，从而实现配置热更新。</li></ul></li></ul><p><strong>关键机制</strong></p><ul><li><strong>长轮询（Long Polling）</strong>：客户端发起请求后，服务器端保持连接，直到有新数据或者超时。这种方式比传统短轮询更高效，延迟更低，但又不像WebSocket那样需要维持大量长连接。</li><li><strong>消息队列</strong>：服务端使用消息队列实现了配置发布和通知机制的解耦，使得Config Service可以及时收到配置变更通知，并通知客户端。</li><li><strong>本地缓存</strong>：客户端本地会缓存配置，保障了服务的可用性。即使Apollo服务器宕机，应用重启后仍能使用本地缓存的配置。</li><li><strong>异步Servlet</strong>：Config Service使用异步Servlet（如DeferredResult），在处理长轮询请求时不会阻塞线程，从而可以处理大量客户端的连接，提高系统并发能力。</li></ul><h3 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h3><p>Nacos 配置中心的原理主要围绕 配置的拉取（pull）和动态推送（push） 机制展开，其核心是巧妙地利用 长轮询（Long Polling） 来高效地实现配置的实时更新。</p><h4 id="Nacos核心逻辑"><a href="#Nacos核心逻辑" class="headerlink" title="Nacos核心逻辑"></a>Nacos核心逻辑</h4><ol><li><strong>客户端启动拉取</strong><ul><li>当微服务应用启动时，客户端会通过 HTTP 请求从 Nacos Server 拉取当前应用所需的配置信息，并加载到本地内存。</li><li>这个过程通常在应用的 <code>bootstrap</code> 阶段完成，确保应用在启动之初就拥有正确的配置。</li></ul></li><li><strong>配置动态监听与推送</strong><ul><li>为了实现配置的动态刷新，Nacos 采用了<strong>长轮询</strong>的机制，而不是传统的短轮询或 WebSocket。</li><li><strong>客户端</strong>：在获取配置后，客户端会开启一个后台线程，每隔一段时间（例如 30 秒）向 Nacos Server 发送一个特殊的 HTTP 长轮询请求，以询问配置是否有变更。</li><li><strong>服务端</strong>：<ul><li>当客户端的请求到达服务端时，服务端并不会立即返回，而是将该请求“挂起”。</li><li>服务端会持有一个<strong>监听器</strong>，用于监听数据库中的配置变更。</li><li>如果配置在挂起期间发生了变更，服务端会立即响应客户端的请求，并告知客户端配置已更新。</li><li>如果挂起时间超过设定的超时时间（例如 29.5 秒），服务端也会返回一个响应（可能是一个空响应），客户端收到响应后会立即发起下一个长轮询请求。</li></ul></li></ul></li><li><strong>客户端配置更新</strong><ul><li>客户端收到配置变更的通知后，会立即重新发起一次 HTTP 请求，从 Nacos Server 拉取最新的配置内容。</li><li>客户端会根据新配置和旧配置的 <strong>MD5 值</strong>进行比对，以确保配置确实发生了变更。</li><li>配置更新后，如果使用了 <code>@RefreshScope</code> 等注解，Spring 容器会刷新相关的 Bean，使得应用能够无需重启就应用新的配置。</li></ul></li></ol><p><strong>关键机制</strong></p><ul><li><p>长轮询（Long Polling）</p><ul><li><strong>优点</strong>：<ul><li><strong>效率高</strong>：避免了短轮询带来的大量无效请求和网络开销。</li><li><strong>实时性好</strong>：当配置变更时，能立即通知客户端，不像短轮询那样有延迟。</li></ul></li><li><strong>实现</strong>：Nacos 在客户端和服务端都维护了长轮询的逻辑。客户端发送请求，服务端挂起连接，直到配置变更或超时。这种模式既保障了实时性，又有效地利用了网络资源。</li></ul></li><li><p>MD5 值比对</p><ul><li><strong>作用</strong>：为了减少网络传输和处理开销，客户端在发起长轮询请求时，会将本地配置的 MD5 值发送给服务端。</li><li><strong>过程</strong>：<ul><li>客户端发起长轮询请求时，携带 <code>configId</code> 和 <code>md5</code> 等参数。</li><li>服务端接收请求，将请求挂起。</li><li>当配置发生变更时，服务端会对比新的 MD5 和客户端传入的 MD5，如果不同，就立即响应客户端。</li><li>这种方式避免了每次都传输完整的配置内容，提高了效率。</li></ul></li></ul></li><li><p>本地缓存</p><ul><li><strong>作用</strong>：为了在网络故障或 Nacos Server 宕机时，客户端仍然能够正常运行。</li><li><strong>实现</strong>：客户端在成功获取配置后，会将其<strong>缓存</strong>到本地文件。如果下次启动时无法连接到 Nacos Server，它会加载本地缓存的配置。</li></ul></li></ul><h2 id="基于zookeeper实现配置中心"><a href="#基于zookeeper实现配置中心" class="headerlink" title="基于zookeeper实现配置中心"></a>基于zookeeper实现配置中心</h2><p>使用Curator基于zookeeper实现配置中心的核心，是利用 ZooKeeper 的 ZNode 数据模型和 Watcher 事件通知机制，再通过 Curator 自身的 Cache 组件（如 NodeCache）对原生 Watcher 的“一次性”缺陷进行封装和优化，从而实现配置的持久化存储和客户端的自动、持续监听。</p><h3 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h3><p>ZNode 数据模型：ZooKeeper 提供了一个类似文件系统的树形结构（ZNode Tree），每个 ZNode（节点）可以存储一小块数据（通常小于1MB）。同时ZooKeeper集群可以保证数据的强一致性，所有写操作都会在集群的多数节点上达成一致后才返回成功。这确保了所有客户端读取到的配置数据是最新、一致的。在Znode中创建根目录&#x2F;config持久化节点（PERSISTENT），然后在该路径下创建子节点来存储不同的配置项：</p><ul><li>配置项：&#x2F;config&#x2F;app&#x2F;dev&#x2F;database_url -&gt; jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mydb。</li><li>snapshot作为快照：&#x2F;config&#x2F;application&#x2F;dev&#x2F;snapshot&#x2F;releases_id，用来保存具体配置项快照。</li><li>releases_meta作为其他信息，如操作信息、历史版本、回滚版本等</li></ul><p>Leader写入：利用ZooKeeper的Leader 选举机制，确保配置的写入操作只由集群中的一个实例（Leader）执行，从而避免了多个实例同时写入导致的冲突。</p><p>ZooKeeper Watcher 与配置变更通知：对一个 ZNode 设置一个 Watcher，当该 ZNode 的数据发生变更（NodeDataChanged）、被删除（NodeDeleted）或其子节点列表发生变化时，ZooKeeper 服务器会向设置 Watcher 的客户端发送一个事件通知。Curator </p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><ul><li>CuratorClientFactory用于创建CuratorFramework</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CuratorClientFactory</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> CuratorFramework <span class="hljs-title function_">createCuratorClient</span><span class="hljs-params">(CuratorProperties properties)</span> &#123;<br>    CuratorFrameworkFactory.<span class="hljs-type">Builder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> CuratorFrameworkFactory.builder()<br>        .connectString(properties.getAddress())<br>        .sessionTimeoutMs(properties.getSessionTimeout())<br>        .connectionTimeoutMs(properties.getConnectionTimeout())<br>        .retryPolicy(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExponentialBackoffRetry</span>(properties.getSleepTime(), properties.getMaxRetries()));<br><br>    <span class="hljs-keyword">if</span> (properties.getAuthDigest() == <span class="hljs-literal">null</span> || properties.getAuthDigest().isBlank()) &#123;<br>      <span class="hljs-type">CuratorFramework</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> builder.build();<br>      client.start();<br>      <span class="hljs-keyword">return</span> client;<br>    &#125;<br><br>    <span class="hljs-comment">// authDigest 格式: &quot;user:password&quot;</span><br>    builder = builder.authorization(<span class="hljs-string">&quot;digest&quot;</span>, properties.getAuthDigest().getBytes());<br>    <span class="hljs-comment">// 提供 ACLProvider，让新创建的节点有 digest ACL（管理服务可以写）</span><br>    builder = builder.aclProvider(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ACLProvider</span>() &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> List&lt;ACL&gt; <span class="hljs-title function_">getDefaultAcl</span><span class="hljs-params">()</span> &#123;<br>        List&lt;ACL&gt; acls = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-comment">// grant all to the digest auth we provided</span><br>        acls.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ACL</span>(ZooDefs.Perms.ALL, ZooDefs.Ids.CREATOR_ALL_ACL.get(<span class="hljs-number">0</span>).getId()));<br>        <span class="hljs-comment">// grant read to anyone (可改为更严格)</span><br>        acls.addAll(ZooDefs.Ids.READ_ACL_UNSAFE);<br>        <span class="hljs-keyword">return</span> acls;<br>      &#125;<br><br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> List&lt;ACL&gt; <span class="hljs-title function_">getAclForPath</span><span class="hljs-params">(String path)</span> &#123;<br>        <span class="hljs-keyword">return</span> getDefaultAcl();<br>      &#125;<br>    &#125;);<br><br>    <span class="hljs-type">CuratorFramework</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> builder.build();<br>    client.start();<br>    <span class="hljs-keyword">return</span> client;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>LeaderService 用于应用服务Leader选举：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LeaderService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">LeaderSelectorListenerAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AutoCloseable</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LeaderSelector selector;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicBoolean</span> <span class="hljs-variable">isLeader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicBoolean</span>(<span class="hljs-literal">false</span>);<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">LeaderService</span><span class="hljs-params">(CuratorFramework client)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-built_in">this</span>.selector = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LeaderSelector</span>(client, <span class="hljs-string">&quot;/config/leader&quot;</span>, <span class="hljs-built_in">this</span>);<br>    <span class="hljs-type">InetAddress</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> InetAddress.getLocalHost();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> address.getHostAddress();<br>    <span class="hljs-built_in">this</span>.selector.setId(id);<br>    <span class="hljs-comment">// 参加选举后，当释放领导权，会自动重新加入</span><br>    <span class="hljs-built_in">this</span>.selector.autoRequeue();<br>    <span class="hljs-built_in">this</span>.selector.start();<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">takeLeadership</span><span class="hljs-params">(CuratorFramework client)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 线程获得领导权时会调用此方法，直到方法返回领导权才会交出</span><br>    isLeader.set(<span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// Block until we are interrupted (release leadership when interrupted)</span><br>      Thread.sleep(Long.MAX_VALUE);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>      <span class="hljs-comment">// lost leadership or closing</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      isLeader.set(<span class="hljs-literal">false</span>);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">returnIfLeader</span><span class="hljs-params">(Supplier&lt;T&gt; supplier)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">if</span> (!checkLeader()) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Leader is not leader&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> supplier.get();<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkLeader</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> isLeader.get();<br>  &#125;<br><br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    selector.close();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>ConfigService配置核心逻辑，实现了配置发布与回滚：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigService</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(ConfigService.class);<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CuratorFramework client;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ObjectMapper mapper;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SnowflakeIdGenerator idGenerator;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">configRootPath</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/config&quot;</span>;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConfigService</span><span class="hljs-params">(CuratorFramework client, String applicationName)</span> &#123;<br>    <span class="hljs-built_in">this</span>.client = client;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">watchPath</span> <span class="hljs-operator">=</span> configRootPath + <span class="hljs-string">&quot;/&quot;</span> + applicationName;<br><br>    <span class="hljs-type">CuratorCache</span> <span class="hljs-variable">cache</span> <span class="hljs-operator">=</span> CuratorCache.build(client, watchPath);<br>    <span class="hljs-type">CuratorCacheListener</span> <span class="hljs-variable">listener</span> <span class="hljs-operator">=</span> CuratorCacheListener<br>        .builder().forAll((type, oldData, newData) -&gt; &#123;<br>          <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> newData != <span class="hljs-literal">null</span> ? newData.getPath()<br>              : (oldData != <span class="hljs-literal">null</span> ? oldData.getPath() : <span class="hljs-string">&quot;unknown&quot;</span>);<br>          logger.info(<span class="hljs-string">&quot;[CuratorCache] event=&#123;&#125; path=&#123;&#125;&#125;&quot;</span>, type, path);<br>        &#125;).build();<br>    cache.listenable().addListener(listener);<br>    cache.start();<br>    <span class="hljs-built_in">this</span>.mapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectMapper</span>();<br>    <span class="hljs-built_in">this</span>.idGenerator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SnowflakeIdGenerator</span>();<br>  &#125;<br><br>  <span class="hljs-comment">// 获取正式值（读取 cache first, fallback to zk）</span><br>  <span class="hljs-keyword">public</span> Optional&lt;String&gt; <span class="hljs-title function_">getRelease</span><span class="hljs-params">(String app, String env, String key)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> keyPath(app, env, key);<br>    <span class="hljs-type">byte</span>[] data = client.getData().forPath(path);<br>    <span class="hljs-keyword">return</span> Optional.ofNullable(data).map(b -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(b, StandardCharsets.UTF_8));<br>  &#125;<br><br>  <span class="hljs-comment">// 创建或更新正式值（由 leader 执行）：先保存快照，再写新值，并在 releases_meta 记录 releaseId</span><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">putRelease</span><span class="hljs-params">(String app, String env, Map&lt;String, String&gt; kvs, String author)</span><br>      <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">releaseId</span> <span class="hljs-operator">=</span> String.valueOf(idGenerator.nextId());<br>    List&lt;CuratorOp&gt; ops = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">releasesPath</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;%s/%s/%s/snapshot/%s&quot;</span>, configRootPath, app, env,<br>        releaseId);<br>    ensurePathExists(releasesPath);<br><br>    <span class="hljs-comment">// 为每个 key 做两个操作：</span><br>    <span class="hljs-comment">// 1) 备份当前值到 snapshot/&#123;releaseId&#125;/&#123;key&#125;（如果存在）</span><br>    <span class="hljs-comment">// 2) setData 到正式路径（create if not exist）</span><br>    <span class="hljs-keyword">for</span> (Map.Entry&lt;String, String&gt; kv : kvs.entrySet()) &#123;<br>      <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> kv.getKey();<br>      <span class="hljs-type">String</span> <span class="hljs-variable">newValue</span> <span class="hljs-operator">=</span> kv.getValue();<br>      <span class="hljs-type">String</span> <span class="hljs-variable">targetPath</span> <span class="hljs-operator">=</span> keyPath(app, env, key);<br>      <span class="hljs-type">String</span> <span class="hljs-variable">snapshotPath</span> <span class="hljs-operator">=</span> releaseSnapshotPath(app, env, releaseId, key);<br>      <span class="hljs-type">byte</span>[] newBytes = newValue.getBytes(StandardCharsets.UTF_8);<br><br>      <span class="hljs-comment">// 创建 snapshot node: 获取原值（若不存在则写空）</span><br>      <span class="hljs-type">byte</span>[] old = <span class="hljs-literal">null</span>;<br>      <span class="hljs-keyword">if</span> (checkPathExists(targetPath)) &#123;<br>        old = client.getData().forPath(targetPath);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        old = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">0</span>];<br>      &#125;<br>      <span class="hljs-type">byte</span>[] snapshotBytes = old;<br><br>      <span class="hljs-type">CuratorOp</span> <span class="hljs-variable">opCreateSnapshot</span> <span class="hljs-operator">=</span> client.transactionOp()<br>          .create()<br>          .forPath(snapshotPath, snapshotBytes);<br>      ops.add(opCreateSnapshot);<br><br>      <span class="hljs-comment">// 处理新配置</span><br>      ensurePathExists(String.format(<span class="hljs-string">&quot;%s/%s/%s&quot;</span>, configRootPath, app, env));<br>      <span class="hljs-keyword">if</span> (checkPathExists(targetPath)) &#123;<br>        <span class="hljs-type">CuratorOp</span> <span class="hljs-variable">setOp</span> <span class="hljs-operator">=</span> client.transactionOp().setData().forPath(targetPath, newBytes);<br>        ops.add(setOp);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// node 不存在 -&gt; create op</span><br>        <span class="hljs-type">CuratorOp</span> <span class="hljs-variable">createOp</span> <span class="hljs-operator">=</span> client.transactionOp().create().withMode(CreateMode.PERSISTENT)<br>            .forPath(targetPath, newBytes);<br>        ops.add(createOp);<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 添加 release meta</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">metaPath</span> <span class="hljs-operator">=</span> releasesMetaPath(app, env, releaseId);<br>    Map&lt;String, Object&gt; meta = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    meta.put(<span class="hljs-string">&quot;id&quot;</span>, releaseId);<br>    meta.put(<span class="hljs-string">&quot;author&quot;</span>, author);<br>    meta.put(<span class="hljs-string">&quot;time&quot;</span>, Instant.now().toString());<br>    <span class="hljs-type">byte</span>[] metaBytes = mapper.writeValueAsBytes(meta);<br><br>    ensurePathExists(metaPath);<br>    <span class="hljs-type">CuratorOp</span> <span class="hljs-variable">metaOp</span> <span class="hljs-operator">=</span> client.transactionOp().setData().forPath(metaPath, metaBytes);<br>    ops.add(metaOp);<br><br>    <span class="hljs-comment">// 执行事务 (atomic): create snapshots + setData/create targets + create meta</span><br>    client.transaction().forOperations(ops.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CuratorOp</span>[<span class="hljs-number">0</span>]));<br>    <span class="hljs-keyword">return</span> releaseId;<br>  &#125;<br><br>  <span class="hljs-comment">// 回滚到某个 releaseId（将 releases/&#123;releaseId&#125; 快照写回正式路径）</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rollbackToRelease</span><span class="hljs-params">(String app, String env, String releaseId, String author)</span><br>      <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">releaseBase</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;%s/%s/%s/snapshot/%s&quot;</span>, configRootPath, app, env, releaseId);<br>    List&lt;String&gt; keys = client.getChildren().forPath(releaseBase);<br><br>    <span class="hljs-keyword">if</span> (keys == <span class="hljs-literal">null</span> || keys.isEmpty()) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;release snapshot empty&quot;</span>);<br>    &#125;<br><br>    List&lt;CuratorOp&gt; ops = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (String key : keys) &#123;<br>      <span class="hljs-type">String</span> <span class="hljs-variable">snapshotPath</span> <span class="hljs-operator">=</span> releaseBase + <span class="hljs-string">&quot;/&quot;</span> + key;<br>      <span class="hljs-type">byte</span>[] snap = client.getData().forPath(snapshotPath);<br>      <span class="hljs-type">String</span> <span class="hljs-variable">targetPath</span> <span class="hljs-operator">=</span> keyPath(app, env, key);<br>      ensurePathExists(String.format(<span class="hljs-string">&quot;%s/%s/%s&quot;</span>, configRootPath, app, env));<br>      <span class="hljs-keyword">if</span> (checkPathExists(targetPath)) &#123;<br>        <span class="hljs-type">CuratorOp</span> <span class="hljs-variable">setOp</span> <span class="hljs-operator">=</span> client.transactionOp().setData().forPath(targetPath, snap);<br>        ops.add(setOp);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">CuratorOp</span> <span class="hljs-variable">createOp</span> <span class="hljs-operator">=</span> client.transactionOp().create().forPath(targetPath, snap);<br>        ops.add(createOp);<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// add rollback meta entry</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">rbId</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;rollback-&quot;</span> + idGenerator.nextId();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">metaPath</span> <span class="hljs-operator">=</span> releasesMetaPath(app, env, rbId);<br>    Map&lt;String, Object&gt; meta = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    meta.put(<span class="hljs-string">&quot;id&quot;</span>, rbId);<br>    meta.put(<span class="hljs-string">&quot;author&quot;</span>, author);<br>    meta.put(<span class="hljs-string">&quot;time&quot;</span>, Instant.now().toString());<br>    meta.put(<span class="hljs-string">&quot;rollbackFrom&quot;</span>, releaseId);<br>    <span class="hljs-type">byte</span>[] metaBytes = mapper.writeValueAsBytes(meta);<br><br>    ensurePathExists(metaPath);<br>    <span class="hljs-type">CuratorOp</span> <span class="hljs-variable">metaOp</span> <span class="hljs-operator">=</span> client.transactionOp().setData().forPath(metaPath, metaBytes);<br>    ops.add(metaOp);<br><br>    client.transaction().forOperations(ops.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CuratorOp</span>[<span class="hljs-number">0</span>]));<br>  &#125;<br><br>  <span class="hljs-comment">// path 存在返回 true</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkPathExists</span><span class="hljs-params">(String path)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">return</span> client.checkExists().forPath(path) != <span class="hljs-literal">null</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensurePathExists</span><span class="hljs-params">(String path)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">if</span> (!checkPathExists(path)) &#123;<br>      System.out.println(<span class="hljs-string">&quot;path = &quot;</span> + path);<br>      client.create().creatingParentsIfNeeded().forPath(path, <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">0</span>]);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> String <span class="hljs-title function_">keyPath</span><span class="hljs-params">(String app, String env, String key)</span> &#123;<br>    <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;%s/%s/%s/%s&quot;</span>, configRootPath, app, env, key);<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> String <span class="hljs-title function_">releaseSnapshotPath</span><span class="hljs-params">(String app, String env, String releaseId, String key)</span> &#123;<br>    <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;%s/%s/%s/snapshot/%s/%s&quot;</span>, configRootPath, app, env, releaseId, key);<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> String <span class="hljs-title function_">releasesMetaPath</span><span class="hljs-params">(String app, String env, String releaseId)</span> &#123;<br>    <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;%s/%s/%s/releases_meta/%s&quot;</span>, configRootPath, app, env, releaseId);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>配置存储（层次化 ZNode）</p><ul><li>ZooKeeper 提供一个类似文件系统的树形结构命名空间，每个节点称为一个 ZNode。</li><li>可以将配置项作为数据存储在特定的 ZNode 中。例如，可以为不同的应用、不同的环境和不同的配置项创建对应的 ZNode 路径，如 &#x2F;config&#x2F;application&#x2F;dev&#x2F;database.url。</li><li>每个 ZNode 都可以存储少量数据（如配置值、JSON 或 Properties 文件内容），并且有元数据（如版本号、ACL 等）。</li></ul></li><li><p>客户端初始化与读取配置</p><ul><li>应用客户端在启动时，连接 ZooKeeper 集群。</li><li>客户端根据应用的需要，读取相应的 ZNode 数据，并将配置加载到本地内存（如 Java 的 Properties 或其他配置管理对象）。</li></ul></li><li><p>动态更新（Watcher 机制）</p><ul><li>Watcher是实现配置中心的关键机制。客户端在读取 ZNode 数据的同时，会向该 ZNode 注册一个 watcher 监听器。</li><li>一旦该 ZNode 的数据发生变化（例如，配置被修改），ZooKeeper 服务器会主动通知注册了 watcher 的客户端。客户端收到通知后，会重新去 ZooKeeper 拉取最新的配置数据，并更新本地内存中的配置值，从而实现配置的动态刷新，无需重启应用。</li></ul></li><li><p>高可用性与一致性</p><ul><li>ZooKeeper 通常以集群（Ensemble）模式部署，推荐使用奇数节点（如 3、5 个节点），只要集群中大多数节点（Quorum）正常工作，服务就可用，从而避免单点故障。</li><li>ZooKeeper 通过 ZAB（ZooKeeper Atomic Broadcast）协议保证数据的一致性，确保所有客户端在同一时刻看到的数据是一致的（强一致性）。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>架构</category>
      
      <category>分布式</category>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>架构</tag>
      
      <tag>分布式</tag>
      
      <tag>中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式中件间-zookeeper使用</title>
    <link href="/2025/08/02/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E4%BB%B6%E9%97%B4-zookeeper%E4%BD%BF%E7%94%A8/"/>
    <url>/2025/08/02/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E4%BB%B6%E9%97%B4-zookeeper%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>Zookeeper 是一个开源的分布式协调框架，基于ZAB协议来确保在分布式环境下的数据一致性和可靠性，实现了一个高可用的、小型的、树形结构（类似文件系统）的数据存储。通常用于分布式系统中的配置管理、同步服务、命名服务等，Zookeeper 主要用于以下几种场景：</p><ul><li>分布式锁：通过 Zookeeper 提供的节点机制，可以实现分布式环境中的锁机制。</li><li>配置管理：Zookeeper 用作分布式系统的配置中心，客户端可以从 Zookeeper 获取共享的配置信息。</li><li>命名服务：Zookeeper 可以作为一个高效的命名服务，提供唯一的命名空间。</li><li>集群管理：Zookeeper 可以用来管理分布式系统中节点的健康状况和成员变更。</li></ul><span id="more"></span><h2 id="zookeeper客户端"><a href="#zookeeper客户端" class="headerlink" title="zookeeper客户端"></a>zookeeper客户端</h2><p>在 Java 生态中，有多种 ZooKeeper 客户端可供选择。主要包括 ZooKeeper 官方原生客户端、以及两个流行的第三方开源客户端 ZkClient 和 Apache Curator。目前在生产环境中最被推荐和广泛使用的是 Apache Curator。 </p><table><thead><tr><th align="left">客户端</th><th align="left">优点</th><th align="left">缺点</th></tr></thead><tbody><tr><td align="left"><strong>官方原生客户端：Zookeeper</strong></td><td align="left">官方支持，最基础的 API</td><td align="left">API 复杂、功能简单，需要手动处理连接丢失、Watcher（观察者）一次性注册等问题，不推荐在生产环境直接使用</td></tr><tr><td align="left"><strong>ZkClient</strong></td><td align="left">对原生 API 进行了封装，提供了更简洁的 API</td><td align="left">社区不活跃，文档不完善，异常处理简化（抛出 RuntimeException），重试机制较难用</td></tr><tr><td align="left"><strong>Apache Curator</strong></td><td align="left">简化了 ZooKeeper 的复杂性，提供了高级 API、连接管理、重试机制、各种分布式场景的抽象封装（如分布式锁、领导选举）</td><td align="left">学习曲线相对复杂（相比 ZkClient）</td></tr></tbody></table><h3 id="官方原生客户端：Zookeeper"><a href="#官方原生客户端：Zookeeper" class="headerlink" title="官方原生客户端：Zookeeper"></a>官方原生客户端：Zookeeper</h3><p>ZooKeeper 的官方原生 Java 客户端库<strong>org.apache.zookeeper</strong>虽然功能基础，但提供了所有与 ZooKeeper 服务端交互的核心接口和类，实现了建立、管理连接和执行所有数据操作。下面是ZookKeeper的其中一个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ZooKeeper</span><span class="hljs-params">(String connectString, <span class="hljs-type">int</span> sessionTimeout, Watcher watcher)</span>&#123;&#125;<br><br></code></pre></td></tr></table></figure><ul><li>connectString: 集群地址列表（如 “host1:2181,host2:2181”）。</li><li>sessionTimeout: 会话超时时间（毫秒），ZooKeeper 依赖心跳来维持会话，超时后会话失效，临时节点将被删除。</li><li>watcher: 默认的全局 Watcher，用于处理连接状态变化等事件。</li></ul><p>ZooKeeper增删改的核心方法如下：</p><ul><li><p>create：用于创建节点，可以指定节点路径、节点数据、节点的访问权限、节点类型</p></li><li><p>delete：删除节点，每个节点都有一个版本，删除时可指定删除的版本，类似乐观锁。设置-1，则就直接删除节点。</p></li><li><p>exists：节点存不存在，若存在返回节点Stat信息，否则返回null。</p></li><li><p>getChildren：获取子节点。</p></li><li><p>getData&#x2F;setData：获取&#x2F;设置节点数据。</p></li><li><p>getACL&#x2F;setACL：获取节点访问权限列表，每个节点都可以设置访问权限，指定只有特定的客户端才能访问和操作节点。ACL说明：</p><ul><li>Ids.CREATOR_ALL_ACL：只有创建节点的客户端才有所有权限</li><li>Ids.OPEN_ACL_UNSAFE：这是一个完全开放的权限，所有客户端都有权限</li><li>Ids.READ_ACL_UNSAFE：所有客户端只有读取的</li></ul></li><li><p>close：关闭连接并终止会话。</p></li></ul><p>Watcher 接口（事件监听）：org.apache.zookeeper.Watcher 是处理 ZooKeeper 客户端事件的核心接口。ZooKeeper 的设计原则是“一次性通知”（One-time trigger），即一个 Watcher 只能监听一次事件，事件触发后就需要重新注册。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 监控所有被触发的事件处理</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(WatchedEvent event)</span>;<br></code></pre></td></tr></table></figure><p>在使用时可以通过实现 <strong>process(WatchedEvent event)</strong> 来做一些自定义处理逻辑与Watcher重新注册。WatchedEvent 包含事件的所有信息：</p><ul><li>EventType: 事件类型（如 NodeCreated, NodeDeleted, NodeDataChanged, NodeChildrenChanged）。</li><li>KeeperState: 客户端连接状态（如 SyncConnected, Disconnected, Expired）。</li><li>getPath(): 发生事件的 ZNode 路径。</li></ul><p>Stat元数据类：org.apache.zookeeper.data.Stat 类用于存储 ZNode 的所有元数据（Metadata），例如版本号、创建&#x2F;修改时间等。在调用 getData() 或 exists() 方法时，该对象会被填充。重要的属性包括：</p><ul><li>czxid: 创建 ZNode 的事务 ID。</li><li>mzxid: 最后修改 ZNode 数据的事务 ID。</li><li>version: 数据的版本号。</li><li>cversion: 子节点列表的版本号。</li><li>dataLength: 数据长度。</li></ul><p>AsyncCallback 接口（异步操作回调）：原生客户端支持同步（Synchronous）和异步（Asynchronous）两种 API。当使用异步方法时（方法名通常以 Async 结尾），需要实现 AsyncCallback 接口来处理操作完成后的结果。常见的子接口：</p><ul><li>DataCallback: 用于 getData 异步操作。</li><li>StatCallback: 用于 exists 异步操作。</li><li>VoidCallback: 用于 delete 异步操作。</li><li>StringCallback: 用于 create 异步操作。</li><li>ChildrenCallback: 用于 getChildren 异步操作。</li></ul><p>基于原生客户端实现同步队列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用原生 zookeeper api</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Watcher</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(Sync.class);<br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> ZooKeeper zookeeper;<br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> String root;<br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">mutex</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br><br>  Sync(String addr, String root) <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-built_in">this</span>.zookeeper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZooKeeper</span>(addr, <span class="hljs-number">3000</span>, <span class="hljs-built_in">this</span>);<br>    <span class="hljs-built_in">this</span>.root = root;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(WatchedEvent watchedEvent)</span> &#123;<br>    logger.info(watchedEvent.toString());<br>    <span class="hljs-keyword">synchronized</span> (mutex) &#123;<br>      mutex.notify();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Queue</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br><br>    Queue(String address, String root) <span class="hljs-keyword">throws</span> IOException, InterruptedException, KeeperException &#123;<br>      <span class="hljs-built_in">super</span>(address, root);<br>      <span class="hljs-keyword">if</span> (zookeeper == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;zookeeper is null&quot;</span>);<br>      &#125;<br><br>      <span class="hljs-type">Stat</span> <span class="hljs-variable">stat</span> <span class="hljs-operator">=</span> zookeeper.exists(root, <span class="hljs-literal">false</span>);<br>      <span class="hljs-keyword">if</span> (stat == <span class="hljs-literal">null</span>) &#123;<br>        zookeeper.create(root, <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">0</span>], Ids.OPEN_ACL_UNSAFE,<br>            CreateMode.PERSISTENT);<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">produce</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-keyword">throws</span> InterruptedException, KeeperException &#123;<br>      <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">4</span>);<br>      <span class="hljs-type">byte</span>[] value;<br>      b.putInt(i);<br>      value = b.array();<br>      zookeeper.create(root + <span class="hljs-string">&quot;/element&quot;</span>, value, Ids.OPEN_ACL_UNSAFE,<br>          CreateMode.PERSISTENT_SEQUENTIAL);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">consume</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> KeeperException, InterruptedException &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">retvalue</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>      <span class="hljs-type">Stat</span> <span class="hljs-variable">stat</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>      <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">synchronized</span> (mutex) &#123;<br>          List&lt;String&gt; list = zookeeper.getChildren(root, <span class="hljs-literal">true</span>);<br>          <span class="hljs-keyword">if</span> (list.isEmpty()) &#123;<br>            logger.info(<span class="hljs-string">&quot;consumer going to wait&quot;</span>);<br>            mutex.wait();<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Integer.parseInt(list.get(<span class="hljs-number">0</span>).substring(<span class="hljs-number">7</span>));<br>            <span class="hljs-type">String</span> <span class="hljs-variable">minNode</span> <span class="hljs-operator">=</span> list.get(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">for</span> (String s : list) &#123;<br>              <span class="hljs-type">int</span> <span class="hljs-variable">tempValue</span> <span class="hljs-operator">=</span> Integer.parseInt(s.substring(<span class="hljs-number">7</span>));<br>              <span class="hljs-keyword">if</span> (tempValue &lt; min) &#123;<br>                min = tempValue;<br>                minNode = s;<br>              &#125;<br>            &#125;<br>            logger.info(<span class="hljs-string">&quot;Temporary value: &#123;&#125;/&#123;&#125;&quot;</span>, root, minNode);<br>            <span class="hljs-type">byte</span>[] b = zookeeper.getData(root + <span class="hljs-string">&quot;/&quot;</span> + minNode, <span class="hljs-literal">false</span>, stat);<br>            zookeeper.delete(root + <span class="hljs-string">&quot;/&quot;</span> + minNode, <span class="hljs-number">0</span>);<br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(b);<br>            retvalue = buffer.getInt();<br>            <span class="hljs-keyword">return</span> retvalue;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>原生客户端的使用流程通常如下：</p><ul><li>创建 ZooKeeper 实例，传入全局 Watcher。</li><li>等待连接建立（SyncConnected 状态）。</li><li>执行操作（create, getData 等），并根据需要注册临时的 Watcher。</li><li>处理 KeeperException 异常。</li><li>处理 Watcher 事件（并在需要时重新注册 Watcher）。</li><li>调用 close() 结束会话。</li></ul><p>由于需要手动管理连接状态和 Watcher 的重复注册，原生客户端使用起来相对繁琐，这也是 Apache Curator 等第三方客户端流行的原因。</p><h3 id="Apache-Curator5-7"><a href="#Apache-Curator5-7" class="headerlink" title="Apache Curator5.7"></a>Apache Curator5.7</h3><p>Apache Curator 是 Netflix 开源并贡献给 Apache 基金会的 ZooKeeper 客户端框架，它极大地简化了 ZooKeeper 的使用，提供了许多强大的特性来解决原生客户端的痛点。使用原生Zookeeper客户端时存在着如下几个问题：</p><ul><li>连接丢失（ConnectionLossException）后不会自动重连。</li><li>会话过期（Session Expired）后，需要手动关闭旧客户端、重新创建新客户端、并恢复所有瞬时（EPHEMERAL）节点和 Watcher。</li><li>开发者必须手动编写复杂的重试逻辑。</li><li>Watcher 是“一次性”的（One-time trigger）。事件触发后立即失效，如果需要持续监听，必须在处理完事件后立即重新注册 Watcher。这个过程容易出错，且在并发场景下可能导致遗漏事件。</li><li>原生 API 方法参数多，使用复杂，代码冗长。例如，create(path, data, acl, mode) 需要同时指定 ACL 和模式，不够直观。</li><li>原生客户端只提供最基本的原语（如创建节点、删除节点），实现分布式锁、领导选举等高级功能需要开发者自己设计复杂的算法，并手动处理各种竞争条件和边界情况。</li></ul><p>Curator 框架解决了原生客户端的使用问题，其核心特性可以概括为以下几点：</p><ul><li><p><strong>健壮的连接管理和重试机制：</strong></p><ul><li><p>连接状态监听： Curator 提供了一个 ConnectionStateListener，可以方便地监听连接状态的变化（CONNECTED, SUSPENDED, RECONNECTED, LOST）。</p></li><li><p>自动重连与重试策略： 内置了强大的重试机制（Retry Policy），如 ExponentialBackoffRetry（指数退避重试）。当出现连接丢失、操作失败等情况时，Curator 会自动根据策略进行重试，极大地简化了错误处理。重试策略：</p><ul><li>ExponentialBackoffRetry：指数退避重试（推荐）。</li><li>RetryNTimes：重试固定次数。</li><li>RetryUntilStopped：一直重试直到停止。</li></ul></li><li><p>会话管理： 自动处理会话过期后的恢复逻辑，透明地重建临时节点和重新注册 Watcher。</p></li></ul></li><li><p><strong>简化的 API 和 Fluent 风格</strong>：Curator 使用了现代化的链式调用（Fluent API）设计模式，使得代码更简洁、可读性更高，相比原生客户端冗长的方法签名，Curator 提供了更直观的接口。</p></li><li><p><strong>高级 Watcher 封装（缓存机制）</strong>：Curator 解决了原生客户端 Watcher“一次性触发”的痛点，提供了持久化和缓存功能。</p><ul><li>持久化 Watcher（Persistent Watcher）： Curator 提供了高级接口，这些接口会自动管理 Watcher 的注册和重新注册。</li><li>事件缓存： *Cache 等组件不仅监听事件，还会缓存节点数据，使得应用程序能够及时获取最新的节点状态，而无需每次都去 ZooKeeper 服务端拉取数据。</li></ul></li><li><p><strong>内置的 Recipes（分布式协调组件）</strong>：这是 Curator 最受欢迎的特性，它将常见的 ZooKeeper 使用场景抽象成了可以直接使用的组件。</p><ul><li>分布式锁（Distributed Locks）：InterProcessMutex、InterProcessSemaphoreMutex、InterProcessReadWriteLock。</li><li>领导选举（Leader Election）： LeaderSelector 组件，允许多个客户端竞争领导权，并在当前领导者宕机时自动进行新的选举。</li><li>分布式计数器（Distributed Counter）： 提供了线程安全的分布式计数器实现。</li><li>服务发现（Service Discovery）： 提供了构建服务注册与发现系统的框架和工具。</li><li>分布式队列&#x2F;屏障： DistributedQueue、DistributedBarrier 等。</li></ul></li><li><p><strong>Zookeeper 2 风格的集成（Testing Server）</strong>：Curator 提供了 TestingServer 和 TestingCluster 类，使得在单元测试和集成测试中启动一个嵌入式的 ZooKeeper 实例变得非常简单，极大地提高了开发和测试效率。</p></li></ul><p>综上，Curator 是目前 Java 生态中最成熟、最稳定的 ZooKeeper 客户端，它将复杂的底层交互封装成了一套易于使用、且经过生产验证的 API 和组件。</p><h4 id="Curator-核心组件"><a href="#Curator-核心组件" class="headerlink" title="Curator 核心组件"></a>Curator 核心组件</h4><p>Curator 框架的核心设计围绕几个关键组件和接口展开，它们协同工作，提供了健壮且易于使用的 ZooKeeper 客户端功能。Curator 的核心组件主要有：</p><ul><li><p><strong>CuratorFramework (核心接口)</strong>：CuratorFramework 是 Curator 框架的主要接口，代表了客户端与 ZooKeeper 集群的连接会话，是所有操作的起点。 它是与 ZooKeeper 服务端通信的门面（Facade），封装了连接管理、重试机制、会话状态监听以及数据操作的所有逻辑。通常使用 CuratorFrameworkFactory 的构建者模式来创建实例。</p></li><li><p><strong>RetryPolicy (重试策略)</strong>：RetryPolicy 是一个接口，定义了当 ZooKeeper 操作失败时（例如网络波动导致连接丢失）客户端应如何重试的规则，实现了自动化的错误恢复机制，避免开发者手动编写复杂的重试逻辑。</p></li><li><p><strong>ConnectionStateListener (连接状态监听器)</strong>：这个监听器用于监控 CuratorFramework 实例与 ZooKeeper 集群的连接状态。使用时应用程序可以对连接状态的变化做出反应，例如会话挂起、重新连接或完全丢失。关键状态有：</p><ul><li>CONNECTED：首次成功连接或重新连接成功。</li><li>SUSPENDED：连接丢失，但会话可能仍然有效（在超时时间内）。</li><li>RECONNECTED：连接从挂起状态恢复。</li><li>LOST：会话超时，连接永久丢失（临时节点会被删除），需要重新建立一个新的 CuratorFramework 实例。</li></ul></li><li><p><strong>CuratorCache (原 TreeCache 等缓存组件)</strong>：Curator 3.x 以后引入了 CuratorCache，整合了早期版本中的 NodeCache、PathChildrenCache 和 TreeCache 的功能。实现了本地缓存和持久化 Watcher 功能，在本地维护 ZNode 结构和数据的最新副本，并自动处理 Watcher 的重新注册，确保不错过任何事件。使用时可以直接从本地缓存获取数据，减少与 ZooKeeper 服务端的网络往返，同时简化了事件监听的复杂性。</p></li><li><p>Recipes (高级功能组件)：Recipes 并非一个单一的接口或类，而是一系列预构建的高级协调组件，基于 ZooKeeper 原语（如临时有序节点）实现分布式系统的通用模式，为复杂的分布式协调任务提供了即插即用的解决方案。</p></li></ul><h4 id="Curator核心方法"><a href="#Curator核心方法" class="headerlink" title="Curator核心方法"></a>Curator核心方法</h4><p>客户端生命周期管理：</p><ul><li>start(): 启动客户端实例并连接到 ZooKeeper 服务端。这是执行任何操作之前的必须步骤。</li><li>close(): 关闭连接，释放所有资源，并终止会话。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">CuratorFramework</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> CuratorFrameworkFactory<br>      .newClient(<span class="hljs-string">&quot;localhost:2181&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExponentialBackoffRetry</span>(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>));<br>client.start();<br><br>client.close();<br></code></pre></td></tr></table></figure><p>数据操作核心方法：</p><ul><li><p>create()：用于在 ZooKeeper 中创建 ZNode。可以通过链式方法指定节点的类型（持久、临时、有序）和数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java">client.create()<br>      .withMode(CreateMode.EPHEMERAL)  <span class="hljs-comment">// 指定节点类型（如 CreateMode.EPHEMERAL 临时节点）。</span><br>      .compress(compressor) <span class="hljs-comment">// 压缩数据（可选）。</span><br>      .forPath(<span class="hljs-string">&quot;/path/to/ephemeral/node&quot;</span>, <span class="hljs-string">&quot;data&quot;</span>.getBytes()); <span class="hljs-comment">//指定路径和要存储的数据，执行操作。</span><br></code></pre></td></tr></table></figure></li><li><p>getData()：开始获得ZNode节点数据的操作，可以调用额外的方法(监控、后台处理或者获取状态watch, background or get stat) 并在最后调用forPath()指定要操作的ZNode。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">byte</span>[] data = client.getData()<br>                    .storingStatsIn(stat) <span class="hljs-comment">// 将节点的元数据存储到提供的 Stat 对象中（可选）。</span><br>                    .watched()                 <span class="hljs-comment">// 注册一个一次性的 Watcher 或者使用：usingWatcher(Watcher watcher)，通常使用缓存替代</span><br>                    .forPath(<span class="hljs-string">&quot;/path/to/node&quot;</span>); <span class="hljs-comment">// 指定路径和新数据，执行操作。</span><br></code></pre></td></tr></table></figure></li><li><p>setData()：用于更新 ZNode 中的数据。可以通过指定版本号实现乐观锁，防止并发修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java">client.setData()<br>      .withVersion(-<span class="hljs-number">1</span>)    <span class="hljs-comment">// 定期望的数据版本号（可选，默认为 -1，表示匹配任何版本）。</span><br>      .forPath(<span class="hljs-string">&quot;/path/to/node&quot;</span>, <span class="hljs-string">&quot;newData&quot;</span>.getBytes()); <span class="hljs-comment">// 指定路径和新数据，执行操作。</span><br></code></pre></td></tr></table></figure></li><li><p>delete()：用于删除 ZNode。可以指定版本号，也可以递归删除子节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java">client.delete()<br>      .withVersion(<span class="hljs-type">int</span> version)   <span class="hljs-comment">// 指定版本号（可选）</span><br>      .guaranteed()               <span class="hljs-comment">// 保证删除成功。即使客户端连接丢失，Curator 也会在后台持续重试，直到节点被删除。</span><br>      .deletingChildrenIfNeeded() <span class="hljs-comment">// 如果节点有子节点，则递归删除（原生客户端不支持）。</span><br>      .forPath(<span class="hljs-string">&quot;/path/to/node&quot;</span>);  <span class="hljs-comment">// 指定路径，执行操作。</span><br></code></pre></td></tr></table></figure></li><li><p>getChildren()：用于获取某个 ZNode 下的所有子节点名称列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">List&lt;String&gt; children = client.getChildren().forPath(<span class="hljs-string">&quot;/path/to/parent&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>checkExists()：检查节点是否存在，返回 Stat 对象（存在）或 null（不存在）。</p></li><li><p>inTransaction()：开始是原子ZooKeeper事务. 可以复合create, setData, check, and&#x2F;or delete 等操作然后调用commit()作为一个原子操作提交</p></li></ul><h4 id="Curator事件监听"><a href="#Curator事件监听" class="headerlink" title="Curator事件监听"></a>Curator事件监听</h4><p>在 Curator 中，事件监听主要通过 CuratorCache 缓存组件实现，这些组件内部封装了对 ZooKeeper 原生 Watcher 的使用，并提供了更友好、更强大的事件模型，解决了Watcher<strong>一次性注册、触发即失效</strong>的问题。在Curator中事件监听的两种方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 使用：CuratorListener</span><br>client.getCuratorListenable()<br>      .addListener((curatorFramework, curatorEvent) -&gt; System.out.println(<span class="hljs-string">&quot;事件： &quot;</span> + curatorEvent));<br><br><span class="hljs-comment">// 使用：Watcher</span><br>client.getChildren()<br>      .usingWatcher((Watcher) watchedEvent -&gt; System.out.println(<span class="hljs-string">&quot;监听： &quot;</span> + watchedEvent)).forPath(<span class="hljs-string">&quot;/cache&quot;</span>);<br></code></pre></td></tr></table></figure><p>CuratorListenable中CuratorEventType触发返回的数据如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs text">事件类型         事件返回数据<br>CREATE          getResultCode() and getPath()<br>DELETE          getResultCode() and getPath()<br>EXISTS          getResultCode(), getPath() and getStat()<br>GET_DATA        getResultCode(), getPath(), getStat() and getData()<br>SET_DATA        getResultCode(), getPath() and getStat()<br>CHILDREN        getResultCode(), getPath(), getStat(), getChildren()<br>SYNC            getResultCode(), getStat()<br>GET_ACL         getResultCode(), getACLList()<br>SET_ACL         getResultCode()<br>TRANSACTION     getResultCode(), getOpResults()<br>WATCHED         getWatchedEvent()<br>GET_CONFIG      getResultCode(), getData()<br>RECONFIG        getResultCode(), getData()<br></code></pre></td></tr></table></figure><p>Curator提供了如下几个策略:</p><ul><li>ExponentialBackoffRetry:重试一定次数，每次重试sleep更多的时间</li><li>RetryNTimes:重试N次</li><li>RetryOneTime:重试一次</li><li>RetryUntilElapsed:重试一定的时间</li></ul><h2 id="服务注册与发现-curator-x-discovery"><a href="#服务注册与发现-curator-x-discovery" class="headerlink" title="服务注册与发现 - curator-x-discovery"></a>服务注册与发现 - curator-x-discovery</h2><p>curator-x-discovery 是 Apache Curator 库的一个扩展组件，专门用于在分布式系统中实现服务注册与发现功能。它构建在 ZooKeeper 之上，提供了一套高级 API，简化了使用 ZooKeeper 进行服务管理的复杂性。</p><p>curator-x-discovery 核心功能：<br><strong>服务注册 (Service Registration)</strong>：服务注册是指将一个服务实例的信息（如服务名、地址、端口、健康状态等）发布到 Zookeeper 集群中。Curator-X-Discovery 利用 Zookeeper 的节点来存储这些信息，每个服务实例在注册时会创建一个临时节点（ephemeral node）。这些节点只要对应的服务实例还在运行，就会存在；当实例下线或不可用时，Zookeeper 会自动删除这些节点。服务注册信息通常包含 <strong>服务名称（例如 service_name）、服务地址（如 IP 或主机名）和其他元数据</strong>。使用方法：discovery.registerService(instance)。</p><p><strong>服务发现 (Service Discovery)</strong>：服务发现是指让客户端能够查询到已注册的服务实例的位置，从而进行调用。Curator-X-Discovery 使用 Zookeeper 中的目录结构（路径）来组织服务。例如，&#x2F;services&#x2F;<service_name> 下的每个节点代表一个服务实例。通过监听 Zookeeper 节点的变化来实现服务的动态发现。当一个服务实例被注册或移除时，客户端能够接收到通知，自动更新可用服务列表。discovery.queryForInstances(serviceName);</p><p><strong>负载均衡策略 (Provider Strategies)</strong>：Curator-X-Discovery 还可以与负载均衡机制配合使用，确保客户端能够均匀地分配请求到不同的服务实例。通过 ServiceInstance（服务实例）类，Curator 可以将多个服务节点的信息提供给客户端，客户端可以选择不同的服务实例进行负载均衡。内置的负载均衡策略：</p><ul><li>RandomStrategy</li><li>RoundRobinStrategy</li><li>StickyStrategy</li></ul><p><strong>健康检查 (Health Checking)</strong>：为了确保服务的健康状态，Curator-X-Discovery 可以通过 Zookeeper 节点的 TTL（生存时间）机制来实现健康检查。同时，通过设置心跳机制或定期检查服务实例的健康状态，确保服务实例是可用的。当服务失效时，相关的临时节点会被清除，系统会自动剔除不可用的服务。</p><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>服务注册与发现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ZkRegistry</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Registry</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServiceDiscovery&lt;ServiceMeta&gt; discovery;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ZkRegistry</span><span class="hljs-params">(RegistryProperties properties)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">CuratorFramework</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> CuratorFrameworkFactory.newClient(properties.getRegisterAddress(),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExponentialBackoffRetry</span>(properties.getSleepTime(), properties.getMaxRetries()));<br>    client.start();<br><br>    JsonInstanceSerializer&lt;ServiceMeta&gt; serializer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonInstanceSerializer</span>&lt;&gt;(ServiceMeta.class);<br>    <span class="hljs-built_in">this</span>.discovery = ServiceDiscoveryBuilder.builder(ServiceMeta.class)<br>        .client(client)<br>        .serializer(serializer)<br>        .basePath(<span class="hljs-string">&quot;/&quot;</span> + properties.getNamespace())<br>        .build();<br>    <span class="hljs-built_in">this</span>.discovery.start();<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(ServiceMeta serviceMeta)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    ServiceInstance&lt;ServiceMeta&gt; instance = ServiceInstance.&lt;ServiceMeta&gt;builder()<br>        .name(buildNamespace(serviceMeta.getGroup(), serviceMeta.getApplication(),<br>            serviceMeta.getVersion()))<br>        .address(serviceMeta.getHost())<br>        .port(serviceMeta.getPort())<br>        .payload(serviceMeta)<br>        .build();<br>    discovery.registerService(instance);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unregister</span><span class="hljs-params">(ServiceMeta serviceMeta)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    ServiceInstance&lt;ServiceMeta&gt; serviceInstance = ServiceInstance<br>        .&lt;ServiceMeta&gt;builder()<br>        .name(buildNamespace(serviceMeta.getGroup(), serviceMeta.getApplication(),<br>            serviceMeta.getVersion()))<br>        .address(serviceMeta.getHost())<br>        .port(serviceMeta.getPort())<br>        .payload(serviceMeta)<br>        .build();<br>    discovery.unregisterService(serviceInstance);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> ServiceMeta <span class="hljs-title function_">lookup</span><span class="hljs-params">(String group, String serviceName,</span><br><span class="hljs-params">      String version, <span class="hljs-type">int</span> hashCode)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>    Collection&lt;ServiceInstance&lt;ServiceMeta&gt;&gt; instances = discovery<br>        .queryForInstances(buildNamespace(group, serviceName, version));<br><br>    ServiceInstance&lt;ServiceMeta&gt; instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConsistentHashLoadBalancer</span>()<br>        .select((List&lt;ServiceInstance&lt;ServiceMeta&gt;&gt;) instances, hashCode);<br><br>    <span class="hljs-keyword">if</span> (instance != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> instance.getPayload();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> String <span class="hljs-title function_">buildNamespace</span><span class="hljs-params">(String group, String application, String version)</span> &#123;<br>    <span class="hljs-keyword">return</span> group + <span class="hljs-string">&quot;#&quot;</span> + application + <span class="hljs-string">&quot;#&quot;</span> + version;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>负载均衡策略：这里自定义实现ConsistentHash</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsistentHashLoadBalancer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">LoadBalancer</span>&lt;ServiceInstance&lt;ServiceMeta&gt;&gt; &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">VIRTUAL_NODE_SPLIT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;#&quot;</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">VIRTUAL_NODE_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> ServiceInstance&lt;ServiceMeta&gt; <span class="hljs-title function_">select</span><span class="hljs-params">(List&lt;ServiceInstance&lt;ServiceMeta&gt;&gt; instances,</span><br><span class="hljs-params">      <span class="hljs-type">int</span> hashCode)</span> &#123;<br>    <span class="hljs-keyword">if</span> (instances == <span class="hljs-literal">null</span> || instances.isEmpty()) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    TreeMap&lt;Integer, ServiceInstance&lt;ServiceMeta&gt;&gt; circle = buildConsistentHashRing(instances);<br>    <span class="hljs-keyword">return</span> allocateNode(circle, hashCode);<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> ServiceInstance&lt;ServiceMeta&gt; <span class="hljs-title function_">allocateNode</span><span class="hljs-params">(</span><br><span class="hljs-params">      TreeMap&lt;Integer, ServiceInstance&lt;ServiceMeta&gt;&gt; circle, <span class="hljs-type">int</span> hashCode)</span> &#123;<br>    Map.Entry&lt;Integer, ServiceInstance&lt;ServiceMeta&gt;&gt; entry = circle.ceilingEntry(hashCode);<br>    <span class="hljs-keyword">if</span> (entry == <span class="hljs-literal">null</span>) &#123;<br>      entry = circle.firstEntry();<br>    &#125;<br>    <span class="hljs-keyword">return</span> entry.getValue();<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> TreeMap&lt;Integer, ServiceInstance&lt;ServiceMeta&gt;&gt; <span class="hljs-title function_">buildConsistentHashRing</span><span class="hljs-params">(</span><br><span class="hljs-params">      List&lt;ServiceInstance&lt;ServiceMeta&gt;&gt; servers)</span> &#123;<br>    TreeMap&lt;Integer, ServiceInstance&lt;ServiceMeta&gt;&gt; ring = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (ServiceInstance&lt;ServiceMeta&gt; instance : servers) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; VIRTUAL_NODE_SIZE; i++) &#123;<br>        ring.put((buildServiceInstanceKey(instance) + VIRTUAL_NODE_SPLIT + i).hashCode(), instance);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ring;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> String <span class="hljs-title function_">buildServiceInstanceKey</span><span class="hljs-params">(ServiceInstance&lt;ServiceMeta&gt; instance)</span> &#123;<br>    <span class="hljs-type">ServiceMeta</span> <span class="hljs-variable">payload</span> <span class="hljs-operator">=</span> instance.getPayload();<br>    <span class="hljs-keyword">return</span> String.join(<span class="hljs-string">&quot;:&quot;</span>, payload.getHost(), String.valueOf(payload.getPort()));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面更标准的做法是实现 curator-x-discovery内置 ProviderStrategy 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsistentHashStrategy</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ProviderStrategy</span>&lt;T&gt; &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> ServiceInstance&lt;T&gt; <span class="hljs-title function_">getInstance</span><span class="hljs-params">(InstanceProvider&lt;T&gt; instance)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 这里实现</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>  <span class="hljs-type">RegistryProperties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegistryProperties</span>();<br>  properties.setNamespace(<span class="hljs-string">&quot;test&quot;</span>);<br>  properties.setMaxRetries(<span class="hljs-number">5</span>);<br>  properties.setSleepTime(<span class="hljs-number">1000</span>);<br>  properties.setRegisterAddress(<span class="hljs-string">&quot;127.0.0.1:2181&quot;</span>);<br><br>  <span class="hljs-type">ZkRegistry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZkRegistry</span>(properties);<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">11</span>; i++) &#123;<br>    <span class="hljs-type">ServiceMeta</span> <span class="hljs-variable">serviceMeta</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceMeta</span>();<br>    serviceMeta.setApplication(<span class="hljs-string">&quot;order-service&quot;</span>);<br>    serviceMeta.setGroup(<span class="hljs-string">&quot;A&quot;</span>);<br>    serviceMeta.setVersion(<span class="hljs-string">&quot;1.0&quot;</span>);<br>    serviceMeta.setHost(<span class="hljs-string">&quot;192.168.0.&quot;</span> + i);<br>    serviceMeta.setPort(<span class="hljs-number">8080</span>);<br>    registry.register(serviceMeta);<br>  &#125;<br><br>  <span class="hljs-type">ServiceMeta</span> <span class="hljs-variable">meta</span> <span class="hljs-operator">=</span> registry.lookup(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;order-service&quot;</span>, <span class="hljs-string">&quot;1.0&quot;</span>, <span class="hljs-number">2126277029</span>);<br>  System.out.println(meta.getApplication() + <span class="hljs-string">&quot;#&quot;</span> + meta.getHost() + <span class="hljs-string">&quot;:&quot;</span> + meta.getPort());<br>  <span class="hljs-type">ServiceMeta</span> <span class="hljs-variable">meta1</span> <span class="hljs-operator">=</span> registry.lookup(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;order-service&quot;</span>, <span class="hljs-string">&quot;1.0&quot;</span>, <span class="hljs-number">113466687</span>);<br>  System.out.println(meta1.getApplication() + <span class="hljs-string">&quot;#&quot;</span> + meta1.getHost() + <span class="hljs-string">&quot;:&quot;</span> + meta1.getPort());<br>&#125;<br></code></pre></td></tr></table></figure><p>小结：<br>Curator-X-Discovery 提供了一种基于 Zookeeper 的服务注册与发现机制，简化了与 Zookeeper 的交互。它的工作原理是通过 Zookeeper 的临时节点、目录结构和监听机制来实现服务的动态注册、发现以及健康检查。通过使用 Curator 库，开发者可以更容易地实现一个高可用、动态可扩展的分布式服务发现系统。</p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>Apache Curator 提供的分布式锁实现主要依赖于 ZooKeeper 的 <strong>临时顺序节点（Ephemeral Sequential Nodes）</strong> 特性，其核心原理是<strong>利用 ZooKeeper 保证数据一致性、强顺序性和高可用的特点，模拟出一个分布式环境下的“公平锁”</strong>。以下两个特性是实现分布式锁的关键点：</p><ul><li>临时节点 (Ephemeral): 锁持有者与 ZooKeeper 的会话断开后，该节点会自动删除，从而避免死锁。</li><li>顺序节点 (Sequential): 每次创建的子节点都会有一个全局唯一的、单调递增的序号，这保证了锁的公平性（先到先得）。</li></ul><p>Curator 提供了如下几种类型的分布式锁：</p><ul><li>InterProcessMutex：可重入的排他锁（最常用）</li><li>InterProcessSemaphoreMutex：不可重入的排他锁</li><li>InterProcessReadWriteLock：读写锁（包含读锁和写锁）</li><li>InterProcessMultiLock：组合多个锁为一个逻辑锁</li></ul><h3 id="加锁过程"><a href="#加锁过程" class="headerlink" title="加锁过程"></a>加锁过程</h3><ul><li>创建锁根节点: Curator 会指定一个持久节点作为所有锁的父节点（例如 &#x2F;locks&#x2F;mylock），这个节点需要预先存在。</li><li>创建临时顺序子节点: 客户端 A 在父节点下创建一个子节点，例如 &#x2F;locks&#x2F;mylock&#x2F;lock-0000000001。</li><li>获取子节点列表: 客户端 A 读取父节点 &#x2F;locks&#x2F;mylock 下的所有当前子节点列表，并按序号升序排序。</li><li>判断是否为最小节点: 客户端 A 检查自己创建的节点是否是当前列表中序号最小的那个节点。<ul><li>如果是: 说明客户端 A 成功获取到锁。它可以执行临界区代码。</li><li>如果不是: 说明前面有其他客户端正在等待或持有锁。客户端 A 不能获取锁。</li></ul></li><li>监听前一个节点: 客户端 A 找到列表中位于它前面的那个节点（例如 &#x2F;locks&#x2F;mylock&#x2F;lock-0000000000），并给这个节点设置一个 ZooKeeper Watcher（监听器），然后进入等待状态。</li></ul><h3 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DistributeLock</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AutoCloseable</span>&#123;<br>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> Exception;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ZkDistributeLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DistributeLock</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicBoolean</span> <span class="hljs-variable">locked</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicBoolean</span>(<span class="hljs-literal">false</span>);<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> InterProcessMutex lock;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ZkDistributeLock</span><span class="hljs-params">(CuratorProperties properties)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">CuratorFramework</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> CuratorFrameworkFactory.builder()<br>        .connectString(properties.getAddress())<br>        .connectionTimeoutMs(properties.getConnectionTimeout())<br>        .sessionTimeoutMs(properties.getSessionTimeout())<br>        .retryPolicy(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExponentialBackoffRetry</span>(properties.getSleepTime(), properties.getMaxRetries()))<br>        .build();<br>    client.start();<br>    <span class="hljs-built_in">this</span>.lock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterProcessMutex</span>(client, properties.getBasePath() + <span class="hljs-string">&quot;/inter-mutex&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">if</span> (timeout &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-type">boolean</span> <span class="hljs-variable">acquired</span> <span class="hljs-operator">=</span> lock.acquire(timeout, unit);<br>      <span class="hljs-keyword">if</span> (acquired) &#123;<br>        locked.compareAndSet(<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      lock.acquire();<br>      locked.compareAndSet(<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> locked.get();<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">releaseLock</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">if</span> (locked.compareAndSet(<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>)) &#123;<br>      lock.release();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    releaseLock();<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isLocked</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> locked.get();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ZkLockExample</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">CuratorProperties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CuratorProperties</span>();<br>    properties.setBasePath(<span class="hljs-string">&quot;/locks&quot;</span>);<br>    properties.setAddress(<span class="hljs-string">&quot;127.0.0.1:2181&quot;</span>);<br>    properties.setSessionTimeout(<span class="hljs-number">10000</span>);<br>    properties.setConnectionTimeout(<span class="hljs-number">1000</span>);<br>    properties.setMaxRetries(<span class="hljs-number">3</span>);<br>    properties.setSleepTime(<span class="hljs-number">3000</span>);<br>    <span class="hljs-comment">// try-with-resource 自动 release</span><br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">ZkDistributeLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZkDistributeLock</span>(properties)) &#123;<br>      lock.tryLock(<span class="hljs-number">3000</span>, TimeUnit.MILLISECONDS);<br>    &#125;<br><br>    <span class="hljs-comment">// 手动release</span><br>    <span class="hljs-type">ZkDistributeLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZkDistributeLock</span>(properties);<br>    <span class="hljs-keyword">try</span> &#123;<br>      lock.tryLock(<span class="hljs-number">3000</span>, TimeUnit.MILLISECONDS);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      lock.releaseLock();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Curator 提供的分布式锁实现基于 ZooKeeper 的临时顺序节点，通过监听节点删除事件实现锁的获取与释放，保证了分布式环境下的可靠性和公平性。不过，需要注意的是，ZooKeeper 的性能限制可能影响系统的扩展性，尤其是在高并发场景下。</p>]]></content>
    
    
    <categories>
      
      <category>架构</category>
      
      <category>分布式</category>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>架构</tag>
      
      <tag>分布式</tag>
      
      <tag>中间件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式中件间-zookeeper原理分析</title>
    <link href="/2025/08/02/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E4%BB%B6%E9%97%B4-zookeeper%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <url>/2025/08/02/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E4%BB%B6%E9%97%B4-zookeeper%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>Zookeeper 是一个开源的分布式协调框架，基于ZAB协议来确保在分布式环境下的数据一致性和可靠性，实现了一个高可用的、小型的、树形结构（类似文件系统）的数据存储。通常用于分布式系统中的配置管理、同步服务、命名服务等，Zookeeper 主要用于以下几种场景：</p><ul><li>分布式锁：通过 Zookeeper 提供的节点机制，可以实现分布式环境中的锁机制。</li><li>配置管理：Zookeeper 用作分布式系统的配置中心，客户端可以从 Zookeeper 获取共享的配置信息。</li><li>命名服务：Zookeeper 可以作为一个高效的命名服务，提供唯一的命名空间。</li><li>集群管理：Zookeeper 可以用来管理分布式系统中节点的健康状况和成员变更。</li></ul><span id="more"></span><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>ZooKeeper 的架构设计旨在提供一个高可用、高性能、强一致性的分布式协调服务。其架构可以清晰地分为两个主要视角：逻辑架构（系统分层） 和 物理架构（部署模式）。</p><h3 id="逻辑架构（系统分层）"><a href="#逻辑架构（系统分层）" class="headerlink" title="逻辑架构（系统分层）"></a>逻辑架构（系统分层）</h3><table><thead><tr><th align="left">层次</th><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><strong>API 层</strong></td><td align="left">Client Interface</td><td align="left">提供客户端访问接口，支持 Java、C 等多种语言，封装了网络通信、会话管理、数据操作和 Watcher 注册等逻辑。</td></tr><tr><td align="left"><strong>服务层</strong></td><td align="left">Services</td><td align="left">ZooKeeper 的核心业务逻辑层。负责处理客户端请求（读写分离）、管理会话 (Session)、处理 Watcher 事件通知、以及权限控制 (ACL) 等。</td></tr><tr><td align="left"><strong>一致性层</strong></td><td align="left">Distributed Consensus</td><td align="left">实现了 Zab (ZooKeeper Atomic Broadcast) 协议，是 ZooKeeper 保证数据一致性的关键。负责 Leader 选举、原子广播、数据同步和事务提交。</td></tr><tr><td align="left"><strong>数据层</strong></td><td align="left">Data Registry</td><td align="left">负责数据存储和持久化。数据存储在内存的 DataTree 中，同时通过事务日志（Transaction Log）和快照（Snapshot）确保数据持久性。</td></tr></tbody></table><h3 id="物理架构（部署模式）"><a href="#物理架构（部署模式）" class="headerlink" title="物理架构（部署模式）"></a>物理架构（部署模式）</h3><p>在物理部署上，ZooKeeper 集群通常采用主备（Master-Replica）架构，由一组互相协作的服务器构成（通常建议部署奇数个节点，如 3、5、7 个）。集群中的每个节点根据 Zab 协议的角色，处于以下三种状态之一：</p><ul><li><strong>Leader (领导者):</strong> 整个集群中唯一一个具有写权限的节点，负责处理所有的写请求（事务请求）。将写请求通过 Zab 协议广播给所有 Follower。负责集群内部的协调和管理，如管理 Session 超时、发起心跳等。</li><li><strong>Follower (跟随者)</strong>: 具有读权限，可以处理客户端的读请求（读取本地内存数据）。参与 Leader 选举的投票过程，同时接收 Leader 的提案（Proposal），参与事务的多数派确认。</li><li><strong>Observer (观察者)</strong>: 可选角色，ZooKeeper 3.x 版本引入。具有读权限，不参与 Leader 选举投票，也不参与事务的多数派确认。主要用于扩展集群的读性能，同时避免影响集群写操作的性能和可用性。</li></ul><p><strong>物理架构特点：</strong></p><ul><li>读写分离: 所有写操作都由 Leader 协调，读操作可以在任何 Follower&#x2F;Observer 上执行，大大提高了系统的并发处理能力。</li><li>高可用性: 只要集群中大多数节点（超过半数）存活，集群就能正常对外提供服务（N个节点容忍 (N-1)&#x2F;2 个节点失效）。</li><li>数据一致性: 依赖 Zab 协议保证所有客户端看到的数据视图是一致的、有序的。</li></ul><h2 id="Zookeeper核心原理分析"><a href="#Zookeeper核心原理分析" class="headerlink" title="Zookeeper核心原理分析"></a>Zookeeper核心原理分析</h2><p>ZooKeeper 的实现原理核心在于其分布式协调机制，主要依赖于<strong>原子广播（Zab 协议）、Leader 选举、数据模型和 Watcher 机制</strong> 来确保分布式系统中的数据一致性和高可用性。其中，<a href="https://ares081.github.io/2025/07/30/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95ZAB%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/">Zab 协议</a> 是 ZooKeeper 保证数据一致性的核心算法，它要求所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的（原子性），并且保证事务的顺序一致性。</p><h3 id="数据模型-Znode"><a href="#数据模型-Znode" class="headerlink" title="数据模型-Znode"></a>数据模型-Znode</h3><p>ZooKeeper 的数据模型是一种层次化的、树形结构，类似于一个精简版的文件系统，每个节点为一个 ZNode。ZooKeeper 的数据模型围绕着 ZNode（ZooKeeper Node）构建，形成一个类似于 Unix 文件系统的倒立树状结构，根节点为 &#x2F;。<br><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E4%BB%B6%E9%97%B4-zookeeper%E5%9F%BA%E7%A1%80_znode%E7%BB%93%E6%9E%84.png"></p><ul><li>路径（Path）：ZNode 在层次结构中的唯一标识，由斜杠（&#x2F;）分隔的路径元素组成，类似于文件系统路径。</li><li>数据（Data）：ZNode 存储的字节数组形式的数据。ZooKeeper 的设计初衷是存储协调数据，而非大规模数据，因此单个 ZNode 的数据大小通常限制在 1MB 以内。</li><li>ACL（访问控制列表）：类似于文件权限，用于控制谁可以对 ZNode 执行读、写、创建、删除等操作。</li><li>元数据（Stat）：包含 ZNode 的详细状态信息，是实现分布式协调的关键。</li></ul><h4 id="Znode类型"><a href="#Znode类型" class="headerlink" title="Znode类型"></a>Znode类型</h4><hr><p>Znode 的类型是 ZooKeeper 数据模型中最具特色的部分，也是它实现各种协调功能（如服务发现、分布式锁）的基石。Znode 根据其生命周期和命名特性，可以组合成四种类型：</p><ul><li><strong>PERSISTENT（持久节点）</strong>：一旦创建，该节点将永久存在于 ZooKeeper 中，直到被显式删除。它不依赖于创建它的客户端会话。通常用于存储需要持久化的信息，如服务配置、ACL 规则等。</li><li><strong>EPHEMERAL（临时节点）</strong>：临时节点的生命周期与创建它的客户端 Session（会话） 严格绑定。当客户端的 Session 启动时，它可以创建临时节点；当 Session 正常关闭（客户端主动 close）时，该临时节点被删除；当 Session 异常终止（例如客户端宕机、网络分区导致心跳超时）时，ZooKeeper 服务器会在 sessionTimeout 之后自动删除该临时节点。另外临时节点是不能有子节点的。临时节点通常用于服务发现和Leader 选举，服务提供者启动时，在 &#x2F;services&#x2F;my-service&#x2F; 目录下创建一个代表自己的临时节点（如 &#x2F;services&#x2F;my-service&#x2F;provider-01）。服务消费者监听 &#x2F;services&#x2F;my-service 的子节点列表。当服务提供者宕机时，Session 超时，临时节点自动删除，消费者会立即收到通知，从而知道该服务已下线，同时集群中的其他节点可以通过检查(health-check)某个临时节点是否存在，来判断对应的服务是否存活。</li><li><strong>PERSISTENT_SEQUENTIAL（持久顺序节点）</strong>：在创建时，ZooKeeper 会自动在客户端指定的路径后附加一个单调递增的 10 位数字序号，其具有持久节点的特性（永久存在）。通常应用于分布式ID和分布式锁，利用单调递增的特性可以生成全局唯一的、有序的 ID。在实现分布式锁（公平锁）时所有尝试获取锁的客户端都在锁节点下创建持久顺序节点，序号最小的节点获得锁。</li><li><strong>EPHEMERAL_SEQUENTIAL（临时顺序节点）</strong>：同时具备临时节点（生命周期绑定 Session）和顺序节点（路径自动附加序号）的特性，这是实现分布式公平锁的完美模型。<ul><li>获取锁：在 &#x2F;locks&#x2F;my-lock&#x2F; 下创建临时顺序节点。</li><li>判断：获取 &#x2F;locks&#x2F;my-lock&#x2F; 下的所有子节点，如果自己创建的节点序号最小，则获得锁。</li><li>释放锁（优雅）：<ul><li>如果客户端宕机，临时节点自动删除（防止死锁）。</li><li>如果客户端正常完成任务，主动删除该节点。</li></ul></li></ul></li><li><strong>容器节点 (Container)</strong>：3.5.x+ 新增，当所有子节点被删除后，自身会被自动清理。通常用于动态集群管理。</li></ul><blockquote><p>注意：在使用EPHEMERAL_SEQUENTIAL（临时顺序节点）实现分布式锁时应当避免“羊群效应”：如果自己不是序号最小的，不需要监听锁节点本身，而是只监听自己序号前一个的那个节点。当前一个节点被删除时（即前一个锁释放了），自己会收到通知，此时再次检查自己是否为最小序号。</p></blockquote><h4 id="Znode数据结构"><a href="#Znode数据结构" class="headerlink" title="Znode数据结构"></a>Znode数据结构</h4><hr><p>每个 Znode 不仅仅是一个路径，它还包含了三个关键部分：Data（数据）、Stat（元数据）、ACL（访问控制列表）。</p><p><strong>Data（数据）</strong>：每个 Znode 都可以存储一小段数据（默认最大 1MB），ZooKeeper 的设计不是用来做大数据存储的，而是用来存储“协调数据”，如配置信息、状态标识、元数据等。1MB 的限制就是为了防止滥用，保证 ZK 的高性能和低延迟。另外，Znode数据的读写是原子性的，要么读取全部数据，要么写入全部数据，没有部分读写的概念。</p><p><strong>Stat（元数据）</strong>：Stat 结构包含了多个字段，这些字段共同提供了 ZNode 的完整生命周期信息，是 ZooKeeper 实现高一致性和乐观锁机制的基础。Stat对象关键属性如下：</p><table><thead><tr><th align="left">字段名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>czxid</code></td><td align="left"><strong>创建 ZNode 的事务 ID（zxid）</strong>。每当 ZooKeeper 的状态发生改变，都会分配一个全局唯一的 zxid。<code>czxid</code> 记录了创建该 ZNode 的操作对应的 zxid。</td></tr><tr><td align="left"><code>mzxid</code></td><td align="left"><strong>最后修改 ZNode 的事务 ID（zxid）</strong>。每当 ZNode 的数据发生变化，该字段都会更新。</td></tr><tr><td align="left"><code>pzxid</code></td><td align="left"><strong>最后修改 ZNode 子节点的事务 ID（zxid）</strong>。当 ZNode 的子节点被添加或删除时，<code>pzxid</code> 字段会更新。<code>pzxid</code> 对于数据缓存和事件通知非常重要。</td></tr><tr><td align="left"><code>ctime</code></td><td align="left"><strong>ZNode 的创建时间</strong>，以毫秒为单位。</td></tr><tr><td align="left"><code>mtime</code></td><td align="left"><strong>ZNode 的最后修改时间</strong>，以毫秒为单位。</td></tr><tr><td align="left"><code>version</code></td><td align="left"><strong>数据版本号</strong>。每当 ZNode 的数据被修改一次，<code>version</code> 的值就会加 1。这是实现乐观锁的核心机制，客户端在更新数据时需要提供期望的版本号。</td></tr><tr><td align="left"><code>cversion</code></td><td align="left"><strong>子节点版本号</strong>。每当 ZNode 的子节点列表发生变化（增加或删除子节点），<code>cversion</code> 的值就会加 1。</td></tr><tr><td align="left"><code>aversion</code></td><td align="left"><strong>ACL 版本号</strong>。每当 ZNode 的 ACL 发生变化，<code>aversion</code> 的值就会加 1。</td></tr><tr><td align="left"><code>ephemeralOwner</code></td><td align="left"><strong>临时节点的会话 ID</strong>。如果该 ZNode 是临时节点，该字段记录了拥有它的客户端的会话 ID。如果客户端断开连接，会话结束，该临时节点就会被自动删除。对于持久节点，该值为 0。</td></tr><tr><td align="left"><code>dataLength</code></td><td align="left"><strong>ZNode 数据内容的长度</strong>。</td></tr><tr><td align="left"><code>numChildren</code></td><td align="left"><strong>ZNode 的子节点数量</strong>。</td></tr></tbody></table><p><strong>关键元数据字段的作用说明：</strong></p><ul><li><strong>ZXID（事务 ID）</strong>：一个 64 位的数字，由两部分组成。高 32 位表示当前的 epoch（时代），每次进行 Leader 选举时都会增加。低 32 位表示该 epoch 内的事务计数器，每次写操作都会增加。ZXID 暴露了所有变更的全局顺序性，较小的 ZXID 总是先于较大的 ZXID 发生，这是保证一致性的关键。</li><li><strong>版本号（version、cversion、aversion）</strong>：版本号机制是实现乐观锁的基础。客户端在更新或删除 ZNode 时，可以指定期望的版本号，如果服务器上的 ZNode 版本号与客户端提供的版本号不一致，操作就会失败，从而避免了并发修改导致的数据不一致问题。</li><li><strong>临时节点和 ephemeralOwner：临时节点是实现分布式锁、服务发现和 Leader 选举的核心</strong>。ephemeralOwner 字段确保了当客户端会话过期或断开连接时，相关的临时节点能被自动清理，从而释放资源或触发重新选举。 </li><li><strong>ACL（访问控制列表）</strong>：ZooKeeper 提供了一套 ACL 机制来控制对 Znode 的访问（读、写、创建、删除、管理）。这为 ZooKeeper 上的敏感数据（如配置信息）提供了安全保障。</li></ul><h3 id="Zookeeper-数据存储"><a href="#Zookeeper-数据存储" class="headerlink" title="Zookeeper 数据存储"></a>Zookeeper 数据存储</h3><p>ZooKeeper 的数据存储原理是它实现高性能、高可用和一致性的保证，与传统数据库（如 MySQL）主要依赖磁盘存储不同，ZooKeeper 的存储原理是以内存为中心，辅以持久化的事务日志和快照。ZK 数据存储主要有三个核心：内存数据 (DataTree)、事务日志 (Transaction Log)、数据快照 (Snapshot)。</p><h4 id="内存数据-DataTree"><a href="#内存数据-DataTree" class="headerlink" title="内存数据 (DataTree)"></a>内存数据 (DataTree)</h4><hr><p>Zookeeper 集群中的每个节点（Leader 或 Follower）都维护一个内存中的数据树，称为 内存数据存储树（In-memory Data Tree）。这个数据树保存了所有 ZNode 的结构和数据。这种设计使得 Zookeeper 在读取操作时非常快速，因为数据直接从内存中读取。当客户端发起一个读请求（如 get &#x2F;path 或 ls &#x2F;path）时，ZooKeeper 服务器直接从内存中读取数据并返回，这个过程不涉及任何磁盘 I&#x2F;O，因此速度极快，这也是 ZK 适合作为“协调”服务（读多写少）的原因。</p><p>DataTree 的主要组成部分：</p><ul><li><strong>DataNode</strong>：代表 ZNode，每个 DataNode 对象对应于树中的一个 ZNode。DataNode 中包含 ZNode 的所有数据，包括路径、字节数组形式的数据内容（data）、ACL 信息和 Stat 元数据，每个 DataNode 维护对其父节点和子节点列表的引用，从而构建出完整的树形结构。</li><li><strong>ConcurrentHashMap</strong>：为了提高查找效率，DataTree 使用一个 ConcurrentHashMap来映射 ZNode 的完整路径（String path）到其对应的 DataNode 对象。客户端可以通过 ZNode 的路径快速定位到内存中的 DataNode，而无需遍历整个树。</li><li>其他信息：DataTree 还维护了关于会话、观察者（Watcher）和临时节点（ephemeral nodes）的信息，这些都存储在内存中，以便快速访问和管理。</li></ul><p>ZooKeeper 定义了一个内存数据ZKDatabase，它封装了 DataTree，是Zookeeper数据管理工具。ZKDatabase 除了管理 DataTree 外，还负责事务日志（WAL）和数据快照的管理，从而实现内存数据与磁盘数据的同步。</p><h4 id="事务日志-Transaction-Log-保证持久化"><a href="#事务日志-Transaction-Log-保证持久化" class="headerlink" title="事务日志 (Transaction Log) - 保证持久化"></a>事务日志 (Transaction Log) - 保证持久化</h4><hr><p>ZooKeeper 的事务日志（Transaction Log），也称为 预写日志（Write-Ahead Log, WAL），是其实现数据持久化和故障恢复的核心机制之一。尽管 ZooKeeper 的数据主要在内存中操作以保证高性能，但事务日志确保了即使在服务器崩溃的情况下，所有已提交的事务也不会丢失。 事务日志是 ZooKeeper 用来记录所有写操作（如创建、修改、删除 ZNode）的日志文件。其工作流程遵循 <strong>“先写日志，再执行操作”</strong> 的原则。</p><p><strong>事务流程如下：</strong></p><ul><li>写请求到达：当客户端发起一个写请求时，该请求首先被 Leader 服务器接收。</li><li>生成事务：Leader 为该请求分配一个唯一的事务ID（zxid），并生成相应的事务（Txn），其中包含操作类型和数据变更内容。</li><li>Follower ACK：Leader 在将事务应用到内存中的 DataTree 之前，会广播到Follower节点。Follower会将该事务以日志条目的形式追加写入到磁盘上的事务日志文件中(预提交)。写入成功后，Follower 会向 Leader 发送一个确认（Ack）消息，表示它已经记录了这个事务，并准备好提交。</li><li>多数派提交：当 Leader 收到集群中多数 Follower 的确认后，Leader 会向所有 Follower 广播一个 Commit 消息，要求所有Follower节点提交该 ZXID 对应的事务。最终，Leader 也在本地提交该事务，并响应客户端。</li></ul><p><strong>事务日志的关键特性</strong></p><ul><li><strong>顺序写入</strong>：事务日志采用追加写入的方式，这是一种顺序 I&#x2F;O 操作。顺序写入比随机写入磁盘的性能高很多，保证了 ZooKeeper 对写请求的高吞吐量。</li><li><strong>高性能要求</strong>：由于所有写操作都需要先写入事务日志并同步到磁盘，因此磁盘的性能是影响 ZooKeeper 性能的关键因素。官方推荐将事务日志和数据快照目录配置在不同的磁盘设备上，以避免相互影响。</li><li><strong>文件名与zxid</strong>：事务日志文件以 log.<zxid> 格式命名，其中 <zxid> 代表该日志文件中第一条记录的 zxid。这使得系统能够快速定位需要回放的日志文件。</li></ul><h4 id="数据快照-Snapshot-优化恢复速度"><a href="#数据快照-Snapshot-优化恢复速度" class="headerlink" title="数据快照 (Snapshot) - 优化恢复速度"></a>数据快照 (Snapshot) - 优化恢复速度</h4><hr><p>ZooKeeper 的数据快照（Snapshot）是其持久化存储机制的重要组成部分，它与事务日志（Transaction Log）协同工作，共同确保数据的可靠性和服务器的快速恢复。</p><p><strong>数据快照作用</strong>：</p><ul><li>记录内存状态：数据快照是 ZooKeeper 在特定时间点对内存中 DataTree（ZNode 树）的完整状态进行序列化，并将其写入磁盘文件的过程。它相当于对 ZooKeeper 内存数据的一次“全量备份”。</li><li>加速恢复：当 ZooKeeper 服务器启动或重启时，如果只依赖事务日志来恢复数据，就需要从头开始回放所有历史事务。随着时间的推移，日志文件会非常庞大，导致恢复时间过长。通过数据快照，服务器只需要加载最新的快照文件，然后回放自该快照生成之后产生的新事务日志，从而大大缩短恢复时间。</li><li>防止日志无限增长：快照机制允许 ZooKeeper 在生成新快照后，安全地清理掉旧的快照和其之前的事务日志，防止存储空间被无限增长的日志文件耗尽。</li></ul><p><strong>快照触发机制</strong></p><ul><li>事务日志计数：当事务日志记录的写操作数量达到一个预设的阈值（通过配置项 snapCount 控制，默认为100,000）时，ZooKeeper 会触发一次快照。</li><li>新 Leader 数据同步：在新 Leader 选举完成后，新 Leader 会向 Follower 同步数据。这个过程也可能涉及快照的生成和传输。</li></ul><p>快照文件存储在 ZooKeeper 配置中 dataDir 参数指定的目录下。每个快照文件以 <code>snapshot.&lt;zxid&gt;</code> 格式命名，其中 <code>&lt;zxid&gt;</code> 代表该快照所对应的最后一次事务的 ID。在生成快照的过程中，ZooKeeper 仍然会继续处理客户端的请求。因此，快照文件记录的是一个“模糊”的时间点的数据，它并不完全精确地对应某一瞬间，但由于事务日志会继续记录，后续可以基于快照和日志完成精确恢复。 </p><h3 id="Session与Watcher"><a href="#Session与Watcher" class="headerlink" title="Session与Watcher"></a>Session与Watcher</h3><p>ZooKeeper 的 Session（会话）是客户端与 ZooKeeper 集群之间的逻辑连接，管理着客户端连接状态和Znode生命周期，其核心在于心跳检测、超时管理和状态同步。</p><p><strong>Session的生命周期：</strong></p><ul><li>创建（Establish）：当客户端第一次连接到Zookeeper集群时，会尝试与集群中的一个服务器建立TCP连接，并向服务器发送连接请求，服务器会为客户端分配一个唯一的Session ID，并设置一个Session Timeout。客户端会与服务器之间会建立一个心跳机制，客户端会周期性地向服务器发送PING请求，服务器也周期性地响应。</li><li>维持（Maintain）：在Session Timeout时间内，只要客户端与服务器保持心跳，Session就会一直保持活跃状态。如果客户端连接的服务器宕机，Zookeeper客户端会自动尝试连接集群中的其他服务器，并重用当前的Session ID。</li><li>过期（Expire）：如果在Session Timeout时间内，Zookeeper服务器没有收到客户端的任何心跳或请求，服务器就会认为客户端已经断开连接，服务器会触发Session过期，删除该Session创建的所有临时节点（包括临时有序节点），同客户端会收到SessionExpiredException异常。</li><li>关闭（Close）：客户端主动调用close()方法关闭连接，Session会被关闭，同时服务器也会删除该Session创建的所有临时节点。</li></ul><p>Watcher（观察者）是Zookeeper实现事件通知机制的核心，它允许客户端订阅Znode的变化，并在变化发生时收到异步通知。Watcher的触发事件类型主要由Watcher.Event.EventType枚举定义：</p><ul><li>数据变化事件（Data Changed Events）：<ul><li>NodeDataChanged：Znode的数据内容发生变化。</li><li>NodeDeleted：Znode被删除。</li></ul></li><li>子节点变化事件（Child Changed Events）：<ul><li>NodeChildrenChanged：Znode的子节点列表发生变化（增加或删除子节点）。</li></ul></li><li>节点创建事件（Node Created Events）：<ul><li>NodeCreated：Znode被创建。（通常通过exists()方法注册Watcher来监听。）</li></ul></li><li>连接状态变化事件（Connection State Events）：<ul><li>None：这是一个特殊事件类型，通常用于表示连接状态的变化，如SyncConnected（成功连接）、Disconnected（连接断开）、Expired（Session过期）。</li></ul></li></ul><p>Watcher工作流程可以概括为以下三个过程：客户端注册 Watcher、服务端处理 Watcher 注册与事件触发、以及客户端回调 Watcher：</p><ul><li>客户端注册 Watcher<ul><li>随读取操作注册: 客户端不能随意注册 Watcher，必须伴随 getData()、getChildren() 或 exists() 等读取操作进行注册。</li><li>本地存储: 当客户端发起带有 Watch 请求的读取操作时，它会做两件事：向服务器发送带有 Watch 标记的请求，同时客户端会将本地的 Watcher 对象存储在一个名为 ZKWatchManager (或类似的结构) 的本地管理器中，等待服务端的事件通知。</li></ul></li><li>服务端处理 Watcher 与事件触发<ul><li>服务器存储: 服务端（通常是 Leader 节点，或由 Leader 转发）接收到客户端的注册请求后，会将该客户端的会话信息和它要监听的 ZNode 路径存储在服务端的 DataTree 结构中，具体存储在 dataWatches（数据变化）或 childWatches（子节点变化）列表中。</li><li>事件触发: 当被监听的 ZNode 发生改变（数据更新、节点创建、删除、子节点变更等）时，服务端会触发相应的 Watcher 事件。</li><li>异步通知: 服务端会异步地向注册了 Watcher 的客户端发送一个通知包 (packet)，包含事件类型、状态等信息。</li></ul></li><li>客户端回调 Watcher<ul><li>接收通知: 客户端与服务端保持着长连接。当客户端收到服务端的事件通知后，客户端的后台线程会将该事件放入一个等待处理的队列中。</li><li>查找并执行: 客户端的主处理线程会从 ZKWatchManager 中取出对应的本地 Watcher 对象，执行其定义的回调逻辑 (process(WatchedEvent event) 方法)。</li><li>一次性触发: 默认情况下，Watcher 是一次性触发的（”one-time trigger”）。一旦 Watcher 被触发并发送通知给客户端，该 Watcher 在服务端的注册就会被移除。客户端如果想继续监听该 ZNode，必须在收到通知后重新注册 Watcher。</li></ul></li></ul><p>Watcher特性：</p><ul><li>一次性触发：Watcher一旦被触发，就会从服务器的WatchManager中移除。如果需要持续监听，客户端必须重新注册。</li><li>异步通知：事件通知是异步发送给客户端的，不能保证立即到达。</li><li>轻量级：Zookeeper的Watcher机制是事件驱动的，只在Znode发生变化时才通知，避免了客户端频繁轮询的开销。</li><li>一致性：Zookeeper保证Watcher事件的顺序性，即事件的发送顺序与Znode的实际变化顺序一致。</li><li>可能丢失事件：在极少数情况下（如网络分区、客户端长时间断开连接），客户端可能会错过某些事件。因此，客户端在收到事件通知后，通常会再次读取最新的数据以确保数据是最新的。</li></ul><p>Watcher 机制的实现完全依赖Session：</p><ul><li><p>生命周期绑定：Session 结束，Watcher 失效</p><ul><li>会话是前提: 所有 Watcher 的注册都是基于一个活动的客户端会话 (Session) 进行的。当客户端连接到 ZooKeeper 服务时，会建立一个会话。</li><li>失效机制: 如果客户端因为网络问题、进程崩溃等原因导致心跳超时，ZooKeeper 服务端会判定该 Session 过期。</li><li>Watcher 清理: 当 Session 过期时，服务端会自动清除该客户端会话注册的所有 Watcher。 客户端也会收到一个特殊的 SessionExpiredException 通知（本地触发），此时之前注册的所有 Watcher 都将失效。客户端必须重新建立连接、开启新会话，并重新注册 Watcher。</li></ul></li><li><p>连接状态管理与通知：Session 机制负责维护客户端与服务端的连接状态。当连接状态发生变化时，客户端会收到相应的 Watcher 事件通知：</p><ul><li>SyncConnected: 成功建立连接并创建会话。</li><li>Disconnected: 连接暂时断开（会话可能仍然有效，客户端会自动尝试重连）。</li><li>Expired: 会话彻底过期。<br>这些连接相关的事件会通过客户端预设的默认 Watcher（在 ZK 客户端初始化时指定的 Watcher 实例）进行通知。</li></ul></li><li><p>一次性触发机制的协同：Watcher 默认是“一次性触发”的。这个设计与 Session 管理协同工作，确保了通知的可靠性：</p><ul><li>Watcher 被触发后，服务端会立即将通知发送给客户端，并从自己的存储中移除该 Watcher 注册。<br>0 如果客户端在收到通知之前与服务器断开连接（Session 未过期），客户端重连后，仍然有机会收到之前未送达的通知（ZooKeeper 尽力保证在 Session 存活期内将通知送达）。</li><li>一旦收到通知，或者 Session 过期，Watcher 便失效了。</li></ul></li></ul><p>Session 是 Watcher 存在的容器和生命线。Watcher 依赖于一个活动的 Session 才能有效注册和接收通知。Session 机制提供了可靠的连接管理，而 Watcher 机制则利用这些连接状态来保证数据变更通知的可靠性和及时性。</p><h2 id="Zookeeper一致性保证"><a href="#Zookeeper一致性保证" class="headerlink" title="Zookeeper一致性保证"></a>Zookeeper一致性保证</h2><p>ZooKeeper 通过一套精心设计的机制和协议来保证数据的一致性，这主要包括以下几个核心要素：Zab 协议、单领导者模型、多数派提交和版本控制。</p><p><strong>ZAB 协议（ZooKeeper Atomic Broadcast）</strong><br>Zab 协议是 ZooKeeper 保证数据一致性的核心，它是一种原子广播协议，确保了所有写操作在集群中以相同的顺序、原子性地被处理。Zab 协议主要包含两个阶段： </p><ul><li>领导者选举：当 ZooKeeper 集群启动或 Leader 出现故障时，集群会进入选举阶段。<ul><li>所有服务器都会进入 LOOKING 状态，并通过互相交换选票来选举新的 Leader。</li><li>选票中包含服务器的 ID 和它所见过的最新事务 ID（zxid）。zxid 最大的服务器更有可能成为 Leader。</li><li>当一台服务器获得了集群中大多数服务器（即法定人数，Quorum）的选票时，它就会成为新的 Leader。</li></ul></li><li>原子广播：一旦 Leader 选举完成，系统就进入原子广播阶段，开始处理客户端的写请求。<ul><li>所有写请求都由 Leader 处理。</li><li>Leader 为每个写请求分配一个唯一的 zxid，并将其封装成一个“提议”（Proposal）广播给所有 Follower。</li><li>Follower 接收到提议后，会将其写入自己的日志，并向 Leader 发送确认（ACK）。</li><li>当 Leader 收到多数 Follower 的确认后，就会向所有 Follower 发送“提交”（COMMIT）消息，指示它们应用该事务。</li><li>原子性：Zab 协议保证，一个事务要么被集群中的所有服务器应用，要么不被应用。如果 Leader 在提交前崩溃，新选举的 Leader 会接管未完成的事务，并完成提交。</li><li>顺序性：所有事务都严格按照 zxid 的顺序执行，确保了全局的有序性。</li></ul></li></ul><p><strong>单领导者模型</strong><br>在任何时刻，ZooKeeper 集群中都只有一个 Leader 服务器，负责处理所有客户端的写请求。 </p><ul><li>集中式写入：这种模型避免了分布式环境下多点写入可能导致的数据冲突，简化了数据同步逻辑。</li><li>读写分离：读请求可以由任何服务器处理（包括 Leader、Follower 和 Observer），大大提高了读操作的性能和吞吐量。</li><li>一致性保证：虽然读请求可以从 Follower 处读取，但 ZooKeeper 保证了“顺序一致性”。这意味着客户端看到的更新会以发送的顺序应用，且一个客户端总能看到自己之前的写操作。</li></ul><p><strong>多数派提交（Quorum）</strong> <br>ZooKeeper 的多数派提交机制是其容错性的核心。 </p><ul><li>一个写操作必须得到集群中过半服务器（即 Quorum）的认可才能被提交。</li><li>容错性：在一个包含 (2n+1) 台服务器的集群中，只要有 (n+1) 台服务器正常工作，系统就可以正常提供服务。这意味着 ZooKeeper 可以容忍最多 (n) 台服务器的故障。</li><li>数据持久化：Leader 在收到多数派确认后，会将事务写入本地的预写日志（Write-Ahead Log, WAL），然后才发送提交命令。这确保了即使所有服务器都宕机，重启后也能恢复到最后一次成功提交的状态。</li></ul><p> </p><p><strong>版本控制（Version）</strong><br>ZooKeeper 的每个 ZNode 都维护一个 Stat 结构，其中包含了三个版本号：version(数据版本号)、cversion(子节点版本号)、aversion（ACL 版本号）。</p><ul><li>CAS 操作：客户端在进行 setData 或 delete 等修改操作时，可以指定期望的版本号。</li><li>乐观锁：如果服务器上的 ZNode 版本号与客户端提供的版本号不一致，说明数据已被其他客户端修改，操作就会失败。这有效避免了并发修改导致的数据覆盖问题。</li></ul><p><strong>一致性小结</strong></p><ul><li>单一入口：所有写操作都通过唯一的 Leader 服务器进行，确保了全局的写入顺序。</li><li>原子广播：Zab 协议确保所有写操作以原子、有序的方式广播到所有服务器。</li><li>多数派机制：写操作需要获得多数服务器的确认，保障了高可用性和数据的可靠性。</li><li>版本控制：乐观锁机制通过版本号，在客户端层面防止并发冲突。</li><li>持久化：预写日志保证了即使发生崩溃，数据也能从存储中恢复。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>ZAB 协议：ZooKeeper 的灵魂。通过 ZAB，ZK 在“Leader 选举”（崩溃恢复）和“原子广播”（正常运行）两种模式间切换，保证了数据在集群中的一致性和顺序性。</li><li>ZXID：实现 ZAB 协议的基础，保证了所有事务的全局顺序。</li><li>Quorum (大多数) 机制：这是 ZK 实现高可用（容错）和高性能（不需要等待所有节点）之间的平衡点。无论是选举 Leader 还是提交事务，都只需要超过半数的节点同意。</li><li>临时节点 + Watcher：这是 ZK 实现分布式协调（如服务发现、分布式锁）的具体手段。通过 Session 管理临时节点的生命周期，通过 Watcher 机制异步通知数据变更。</li></ul>]]></content>
    
    
    <categories>
      
      <category>架构</category>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>架构</tag>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式共识-ZAB协议分析</title>
    <link href="/2025/07/30/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95ZAB%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"/>
    <url>/2025/07/30/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95ZAB%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="https://classpages.cselabs.umn.edu/Fall-2020/csci8211/Papers/Distributed%20Systems%20Zab-%20High-performance%20broadcast%20for%20primary-backup%20systems.pdf">ZAB（ZooKeeper Atomic Broadcast）协议</a>是专为 ZooKeeper 设计的一种支持崩溃恢复的原子广播协议，是 ZooKeeper 保证分布式数据一致性的核心算法。其核心原理是<font color=red>通过一个主备模型来处理所有事务性请求，并确保这些请求以全局一致的顺序在所有节点上执行和提交</font>。ZAB 协议主要包含两种基本工作模式：<strong>消息广播（Message Broadcast）和崩溃恢复（Crash Recovery）</strong>，并通过三个核心阶段来要求每个 Leader 的工作：<strong>发现（Discovery）、同步（Synchronization）和广播（Broadcast）</strong>。 </p><span id="more"></span><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>ZAB 协议运行在一个由奇数个服务器组成的集合（法定人数，Quorum）之上，以保证在部分服务器宕机时仍能进行领导者选举和数据同步。<strong>服务节点主要有三种角色：</strong></p><ul><li>领导者 (Leader)：负责处理所有客户端的写请求，并将数据变更（事务）以广播的形式同步给所有 Follower。其核心职责如下：<ul><li>事务处理的唯一核心：在一个 ZooKeeper 集群中，同一时间只存在一个领导者。它负责接收并处理所有改变系统状态的客户端写请求（事务）。</li><li>生成全局唯一的事务 ID (zxid)：领导者为每个事务分配一个全局唯一且严格递增的 64 位事务 ID（zxid）。zxid 的高 32 位是 epoch（纪元），代表领导者的任期；低 32 位是一个单调递增的计数器。这种结构确保了所有事务的全局有序性。</li><li>发起提案和提交：领导者将带有 zxid 的事务作为提案（Proposal）广播给所有跟随者，并负责收集确认（ACK），在收到法定数量（Quorum）的确认后，再广播提交（Commit）消息。</li></ul></li><li>跟随者 (Follower)：接收 Leader 的事务提议 (Proposal)，参与投票，并在 Leader 确认提交后执行事务。其核心职责如下：<ul><li>接收并处理领导者的提案：跟随者接收来自领导者的事务提案，并将其持久化到本地的事务日志中。</li><li>参与投票：在持久化提案后，跟随者会向领导者发送 ACK，表示自己已成功接收并记录该提案，这是投票过程的一部分。</li><li>提交事务：接收到领导者的 Commit 消息后，跟随者才会将对应的事务应用到自己的内存状态机中，使其对客户端可见。</li><li>处理读请求：跟随者可以直接处理客户端的读请求，从而分担领导者的压力，提高系统的读性能。</li></ul></li><li>观察者 (Observer)：接收 Leader 的事务提议，执行事务，但不参与投票过程。其核心职责如下：<ul><li>增强读性能的特殊角色：观察者接收并同步来自领导者的事务，但它们不参与提案的投票过程，也不构成 Quorum 的一部分[1]</li><li>扩展集群的读能力：引入观察者的主要目的是在不影响写性能的情况下，扩展系统的读能力。因为增加跟随者会增加领导者在广播和收集 ACK 时的开销，而增加观察者则不会。</li></ul></li></ul><p>ZAB 协议的运行时，集群中的每个节点（服务器）都会处于以下四种状态之一: </p><ul><li>LOOKING (选举状态)：这是集群启动时或 Leader 崩溃、失联时所有节点最初进入的状态。在此状态下，节点之间会相互通信，进行 Leader 选举投票，试图选出一个新的 Leader。状态切换：<ul><li>从LOOKING到LEADER：如果一个节点在选举过程中收到超过半数节点的支持，它将成为Leader，切换到LEADER状态。</li><li>从LOOKING到FOLLOWER：如果一个节点在选举过程中成为某个Leader的追随者，它将进入FOLLOWER状态。</li></ul></li><li>FOLLOWING (跟随状态)：当节点发现已经选举出 Leader 后（可能是它自己投选的，也可能是收到了多数节点的确认消息），它会切换到此状态，成为一个 Follower。Follower 负责接收 Leader 的提案（Proposal）、记录事务日志、参与投票确认，并向 Leader 汇报心跳和状态。状态切换：<ul><li>从LOOKING到FOLLOWER：在Leader选举阶段，节点会进入LOOKING状态，并根据选举过程的结果，切换到FOLLOWER状态，成为某个Leader的追随者。</li><li>从LEADER到FOLLOWER：当Leader节点崩溃或进行切换时，Follower节点通过Leader选举机制选举一个新的Leader，切换为新的Leader的追随者。</li></ul></li><li>LEADING (领导状态)：被选举为 Leader 的节点进入此状态。Leader 负责处理所有客户端的写请求，将请求转换为事务提案并广播给 Follower，并在获得多数确认后通知提交。状态切换：<ul><li>从LOOKING到LEADER：当节点在选举过程中（LOOKING状态）收到大多数节点的投票，并且确认自己作为Leader时，就会进入LEADER状态。</li><li>从FOLLOWER到LEADER：如果Follower节点在Leader崩溃时被选为新的Leader，它会从Follower状态切换为Leader状态。</li></ul></li><li>OBSERVING (观察状态)：观察者（Observer）是 ZooKeeper 集群中的一种特殊角色，它可以接收客户端连接和读请求，将写请求转发给 Leader，不参与 Leader 选举投票和事务的投票确认过程。观察者通常由管理员配置，在集群中明确指定为观察者，并且与Follower节点状态不直接互换。观察者节点不参与Leader选举，因此它们不会从LOOKING状态直接转换为LEADER状态。</li></ul><h2 id="ZAB协议的工作原理"><a href="#ZAB协议的工作原理" class="headerlink" title="ZAB协议的工作原理"></a>ZAB协议的工作原理</h2><p>ZAB协议是Zookeeper为了保证高可用性和强一致性而设计的协议，它通过Leader选举、日志广播、数据一致性和故障恢复机制，确保了分布式系统中数据的一致性和可靠性。</p><h3 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h3><p>当集群启动或 Leader 出现故障时，所有节点会进入 LOOKING 状态，并通过 Fast Leader Election (FLE) 算法开始新一轮的 Leader 选举。核心流程如下：</p><ul><li>自增选举轮次（Epoch）：每个参与选举的节点会自增本地的逻辑时钟（logicalClock 或 electionEpoch），标识新一轮选举的开始。</li><li>发送初始投票：每个节点将自己的服务器 ID（sid）和其记录的最新事务 ID（zxid）封装为一个初始选票，广播给集群中的其他所有节点，每个节点默认投给自己。</li><li>接收与处理选票:<ul><li>节点会持续接收来自其他节点的选票，并将这些选票放入一个接收队列中。</li><li>收到选票后，节点会拿自己的当前投票与收到的投票进行比较。首先会比较zxid，拥有更大 zxid（即数据越新）的节点更有资格成为 Leader；如果 zxid 相同，则比较sid，拥有更大 sid 的节点获胜（这是一个平局打破规则）。</li><li>如果收到的选票优于自己的当前选票，节点会更新自己的投票，并将新投票广播给集群中其他节点。</li></ul></li><li>统计选票与确定 Leader：当某个节点的选票信息（包括它自己投给自己的，以及其他节点同意的）获得集群中半数以上节点的支持时，该节点就被确定为“准 Leader”，这个多数共识的机制确保了选举出的 Leader 拥有最新的已提交数据。</li><li>状态转换与数据同步：<ul><li>一旦确定了 Leader，所有节点退出 LOOKING 状态，进入恢复模式的后续阶段，其他参与投票的节点切换至 FOLLOWING 状态，Observer 切换至 OBSERVING 状态。</li><li>Leader 强制所有 Follower 将数据同步到与自己一致的状态（SYNCHRONIZATION 阶段）。当半数以上的 Follower 完成同步后，集群才正式进入 <strong>消息广播（BROADCAST）</strong> 模式，开始对外提供正常的读写服务。</li></ul></li></ul><h3 id="原子广播-事务"><a href="#原子广播-事务" class="headerlink" title="原子广播(事务)"></a>原子广播(事务)</h3><p>ZAB 协议的原子广播（Atomic Broadcast）是其在正常运行阶段（广播阶段）保证数据一致性和全局有序性的核心机制。它确保所有节点以相同的顺序接收和提交所有事务性消息，实现了一种全序广播（Total Order Broadcast）。ZAB 的广播过程类似于一个简化的两阶段提交（2PC），移除了中断逻辑，依赖 Leader 的崩溃恢复机制来处理异常情况，整个过程基于 Leader-Follower 模型进行：</p><ul><li><p><strong>提案生成 (Propose)</strong>：当客户端发送写请求，这时写请求会被转发到 Leader 节点。Leader 接收到写请求后，不会立即执行，而是生成一个全局唯一的 ZXID (ZooKeeper Transaction ID)，即提案ID，ZXID 是一个 64 位整数，高 32 位代表 Leader 的周期（Epoch），低 32 位代表事务递增计数器，ZXID 的单调递增性确保了事务的全局有序性。最后，Leader 会将这个提案（包含 ZXID 和具体数据变更）通过 FIFO（先进先出）的 TCP 通道广播给所有 Follower 节点。</p></li><li><p><strong>追随者确认 (Acknowledge - Ack)</strong>：Follower 接收到 Leader 的提案后，会将其写入本地的事务日志（预提交）。写入成功后，Follower 会向 Leader 发送一个确认（Ack）消息，表示它已经记录了这个提案，并准备好提交。</p></li><li><p><strong>领导者提交 (Commit)</strong>：Leader 会收集来自 Follower 的确认消息，当 Leader 收到半数以上（quorum）Follower 的确认后，即认为该提案可以安全提交。在完成确认可以提交后，Leader 会向所有 Follower 广播一个 Commit 消息，要求所有Follower节点提交该 ZXID 对应的事务。同时，Leader 也在本地提交该事务，并响应客户端。</p></li></ul><p><strong>ZAB原子性、持久性、顺序性保证</strong>：ZAB 事务的“原子性”和“持久性”完全依赖于 “收到半数以上 (Quorum) 的 Ack” 这一机制。</p><ul><li><p>原子性保证：原子性保证主要依赖ACK机制，如果 Leader 成功收到了 Quorum 的 Ack 并发送了 Commit，那么这个事务一定会被提交。即使 Leader 宕机，新选出的 Leader 也必然包含这个已提交的事务（因为选举规则要求新 Leader 必须拥有最新数据，而 Quorum 中至少有一个节点存有该事务）。如果 Leader 在收到 Quorum Ack 之前就宕机了，那么这个事务被视为从未发生过，新 Leader 也不会包含它，最终它会被丢弃。</p></li><li><p>持久性保证： Follower 必须在发送 Ack 之前，将事务 Proposal 写入磁盘上的事务日志 (WAL)。这确保了即使 Follower 宕机重启，它也能通过日志恢复该事务，不会丢失已确认的数据。</p></li><li><p>顺序性保证：ZAB 事务的严格顺序性由 Zxid (ZooKeeper 事务 ID) 保证。</p><ul><li>全局有序：Leader 为每个事务分配一个全局递增的 Zxid (高 32 位是 Leader 周期 Epoch，低 32 位是计数器)。</li><li>按序应用：所有节点 (Leader 和 Follower) 必须严格按照 Zxid 的顺序将事务应用到内存数据树 (DataTree) 中。如果一个节点发现它收到的 Commit (例如 Zxid&#x3D;5) 在它已执行的 Zxid (例如 Zxid&#x3D;3) 之后，但它缺少 Zxid&#x3D;4，它会等待 Zxid&#x3D;4 的 Commit 到达并执行后，才会执行 Zxid&#x3D;5。</li></ul></li></ul><p>总的来说：<font color=red>ZAB 原子广播的核心在于基于多数派确认的二阶段提交和利用 ZXID 保证全局有序，并通过 Leader 选举和数据同步的崩溃恢复机制来弥补简化二阶段提交模型中移除中断逻辑带来的数据不一致风险。</font></p><h3 id="故障恢复"><a href="#故障恢复" class="headerlink" title="故障恢复"></a>故障恢复</h3><p>ZAB 协议的故障恢复机制是其保证分布式数据一致性的关键，旨在确保在 Leader 崩溃、网络分区或节点重启等异常情况下，集群能够恢复到一个一致的状态，并继续提供服务。主要由以下三个紧密衔接的阶段组成：</p><ul><li>发现阶段 (Discovery) - 领导者选举：当集群启动时、Leader 宕机时，或者集群中少于半数节点与 Leader 保持正常通信时，集群会进入 LOOKING 状态，启动新一轮的 Leader 选举，目标是选举出一个新的 Leader，该 Leader 必须拥有集群中最新已提交的事务记录（即最大的 ZXID）。选举机制从根本上保证了所有已经提交的事务都不会丢失，因为最新的数据副本被选为了 Leader。</li><li>同步阶段 (Synchronization) - 数据同步：新 Leader 选举产生后，进入同步阶段。此时，集群还没有准备好处理新的写请求。这个阶段是Leader强制所有 Follower 的数据状态与新 Leader 的数据状态保持一致。这个阶段 ZAB 协议需要确保两件事：<ul><li>已提交事务的最终提交: 故障发生前在旧 Leader 上已提交（但部分 Follower 未收到 Commit 消息）的事务，会在同步阶段被新 Leader 强制提交到所有节点。</li><li>未提交事务的丢弃: 故障发生前在旧 Leader 上未完成半数确认的事务，在新 Leader 上不会被提交，而是被丢弃，Follower 会删除这些事务日志。</li></ul></li><li>广播阶段 (Broadcast) - 恢复正常运行：只有当集群中超过半数的节点完成了与新 Leader 的数据同步后，ZAB 协议才会退出恢复模式，进入正常的消息广播模式。当进入到广播阶段后，会恢复对外提供正常、一致的读写服务。</li></ul><p>总之：ZAB 的故障恢复机制通过选举拥有最新数据的节点和强制全量数据同步这两个步骤，保证了无论发生何种崩溃，集群最终都能达到一个全局一致的状态，并且不会丢失任何已提交的数据。 </p><h3 id="安全性保证"><a href="#安全性保证" class="headerlink" title="安全性保证"></a>安全性保证</h3><p>ZAB 的安全性保证由 <strong>原子广播机制（基于多数派的两阶段简化提交）和崩溃恢复机制（基于最新日志的 Leader 选举和数据同步）</strong> 共同实现：</p><ul><li>强一致性与数据完整性：<ul><li>原子性：ZAB 协议提供了强一致性（Strong Consistency），所有的事务提案要么被集群中的所有节点提交，要么一个都不提交，不存在部分节点提交而其他节点不提交的情况。在事务中，</li><li>持久性：一旦 Leader 确认一个事务已被提交（即获得了多数派确认），那么该事务的状态将是持久的，即使 Leader 宕机，新的 Leader 也会确保所有节点最终提交该事务。</li></ul></li><li>全序性与因果一致性 (Total Order and Causal Order)：ZAB 协议确保所有节点以相同的、确定的顺序应用事务，这是实现复制状态机（Replicated State Machine）的关键。<ul><li>全序性（Total Order）: 如果一个服务器先交付（提交）了消息 A，再交付消息 B，那么集群中的所有其他服务器也必须按照先 A 后 B 的顺序交付这两个消息。ZAB 通过 Leader 统一分配 ZXID（事务 ID）来保证这个全局唯一的顺序。</li><li>因果顺序性（Causal Order）: 如果一个事务 B 是在事务 A 提交后才发起的（A导致B），那么在所有节点上，A 一定在 B 之前被处理和提交。</li></ul></li><li>领导者选举的安全性：Leader 选举机制是故障恢复的核心，其安全性保证是整个系统安全的基础。<ul><li>选举的正确性: 选举出的新 Leader 必须是那个拥有集群中最完整、最新已提交事务日志的节点（即拥有最大的 ZXID）。</li><li>防止旧数据重新出现: ZAB 协议确保丢弃那些在旧 Leader 上未完成提交的事务提案，防止未提交的、可能导致不一致的数据再次出现并污染集群状态。</li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ZAB协议是Zookeeper为了保证高可用性和强一致性而设计的协议，它通过Leader选举、日志广播、数据一致性和故障恢复机制，确保了分布式系统中数据的一致性和可靠性。ZAB协议的两阶段提交机制，结合Leader的控制，能够有效地保证在故障恢复时数据不丢失。</p>]]></content>
    
    
    <categories>
      
      <category>架构</category>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>架构</tag>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式共识-Raft协议分析</title>
    <link href="/2025/07/28/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95Raft%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"/>
    <url>/2025/07/28/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95Raft%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p><a href="https://ongardie.net/static/raft/userstudy/raft.pdf">Raft 协议</a>是分布式系统中最重要的共识算法之一，被广泛应用于 etcd、TiDB、CockroachDB 等知名项目中。Raft 的核心设计目标就是易于理解（Understandability），它通过将复杂的一致性问题分解为几个相对独立的子问题来实现这一目标。Raft 算法是对“状态机复制” (SMR) 模型一个非常清晰和易于理解的实现。</p><p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9FSMR%E6%A8%A1%E5%9E%8B.png"></p><p>Raft 的重要特性：</p><ul><li>一致性：Raft 保证集群中所有节点的数据一致性。日志条目一旦被提交并且被大多数节点复制，便成为最终一致的。</li><li>简易性：Raft 的设计比 Paxos 更直观，易于理解和实现。通过引入明确的领导者角色和日志复制机制，Raft 确保了系统的一致性。</li><li>高可用性：Raft 通过选举机制和日志复制机制保证系统在节点发生故障时依然能够继续工作。</li><li>可扩展性：Raft 适用于较大的分布式系统，能够在多个节点之间保持一致性，并且在节点增加时，系统能够扩展。</li></ul><span id="more"></span><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>Raft 通过一个有领导者的协议来保证一致性，并通过心跳机制和日志复制确保所有节点最终达成一致。Raft 的核心思想可以概括为：<font color=green>一个强一致的领导者（Leader）控制日志的提交和复制，集群中的节点通过领导者来保证一致性。</font>在Raft算法中定义了节点角色或状态：</p><ul><li>Leader：负责管理集群，处理客户端请求，向其他节点（Follower）复制日志条目以及状态机应用，所有客户端请求都会先发送到 Leader。同时，Leader会定期向所有 Follower 发送心跳 (Heartbeat)，以维持其领导地位并告知 Follower 自己“还活着”。</li><li>Follower：完全被动节点，接受 Leader 的命令。它不处理客户端请求，所有请求都重定向到 Leader。唯一的职责是响应 Leader 和 Candidate 的 RPC 请求（如接收日志、投票）。另外，如果Election Timeout周期没有收到 Leader 的心跳，它会认为 Leader 已宕机，并转变为 Candidate。</li><li>Candidate：选举过程中的临时角色。在选举过程中，如果一个Follower节点没有接收到 Leader 的心跳消息，它就会变成 Candidate，向集群中的其他服务器发送投票请求 (RequestVote)，如果它获得了超过半数 (Majority) 的选票，它就晋升为 Leader。</li></ul><p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95Raft%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90_Raft%E5%8D%8F%E8%AE%AE%E5%86%85%E9%83%A8%E7%8A%B6%E6%80%81.png"></p><p>在一个 Raft 集群中，任何时候都有且仅有一个服务器是领导者 (Leader)。所有的数据变更（写操作）都必须经过 Leader。Leader 负责接收客户端的请求，将其作为日志条目（Log Entry）复制到其他跟随者 (Follower) 节点，并在“安全”的时候通知 Follower 将日志条目应用到它们的状态机。</p><p>Raft集群中Leader生命周期被划分为一个个连续的、单调递增的<strong>任期（Term）</strong>，它充当了集群的逻辑时钟。每个任期从一次选举开始，成功选举出的领导者在任期内负责管理集群。任期的作用：</p><ul><li>识别过时的 Leader：如果一个 Leader 发现来自其他服务器的 RPC 中（无论是投票请求还是日志请求）包含一个比自己当前任期号更新 (更大) 的任期号，它会立即降级 (Step Down) 为 Follower。</li><li>拒绝过时的 Candidate：如果一个 Follower 收到一个任期号比自己旧 (更小) 的投票请求，它会直接拒绝。</li></ul><h2 id="Raft算法原理分析"><a href="#Raft算法原理分析" class="headerlink" title="Raft算法原理分析"></a>Raft算法原理分析</h2><p>Raft算法是Multi-Paxos算法的变种，与其类似在集群运行时会选取一个Leader节点，当集群稳定后Leader负责管理集群，处理客户端请求，同时向其他节点（Follower）复制日志条目以及状态机应用，当Leader节点失联后会选取新的Leader实现集群的容错性。</p><h3 id="领导者选举-Leader-Election"><a href="#领导者选举-Leader-Election" class="headerlink" title="领导者选举 (Leader Election)"></a>领导者选举 (Leader Election)</h3><hr><p>Raft 中每个节点都有三种状态：<strong>Leader、Follower 和 Candidate</strong>。初始状态为 Follower。Leader 负责接收客户端请求，并通过日志复制将命令传递给集群中的其他节点。如果一个 Follower 长时间(随机化的时间)没有接收到 Leader 的心跳（心跳是 Leader 定期发送的消息，用来维持集群的健康），会发起选举。</p><h4 id="Leader选举流程"><a href="#Leader选举流程" class="headerlink" title="Leader选举流程"></a>Leader选举流程</h4><ul><li>当前节点状态由Follower变为Candidate。</li><li>由Candidate 节点发起选举，它会为自己投票，增加自己的任期编号，并将选票请求（请求选举）广播给其他节点。</li><li>每个 Follower 节点收到请求后，会根据当前日志的最新情况决定是否投票给该 Candidate。<ul><li>如果该节点的日志版本更高，它会投票给自己，否则投票给请求的候选人。</li><li>任期编号相同时，日志完整性高的Follower（也就是最后一条日志项对应的任期编号值更大，索引号更大），该Follower节点会拒绝投票给日志完整性低的Candidate。</li></ul></li><li>等待是否成为Leader:<ul><li>Candidate 接收到了来自超过半数 (N&#x2F;2 + 1) 服务器的选票，立即转变为 Leader 角色。成为 Leader 后，它立刻向所有 Follower 发送心跳包（空的 AppendEntries RPC），广播选举成功并阻止新的选举。</li><li>在等待投票期间，Candidate 收到了一个来自新 Leader（必须是不小于自己任期的 Leader）的 AppendEntries RPC（心跳）。响应并承认新 Leader 的合法性，立即转变为 Follower。</li><li>在选举超时时间内，没有 Candidate 获得过半数选票（例如，多个 Candidate 同时发起选举，导致“分票”）。Candidate 会保持 Candidate 状态，增加任期号，并发起新一轮的选举。为了避免无限期的“分票”，Raft 的“选举超时”时间必须是随机的。这确保了总有一个 Candidate 会先超时并发起选举，从而有很大概率赢得选票。</li></ul></li></ul><h4 id="选举小结："><a href="#选举小结：" class="headerlink" title="选举小结："></a>选举小结：</h4><p>安全性：每次选举周期内最多只允许一个Leader被选举出：</p><ul><li>每台服务器每届只投一票（结果保存在磁盘上）</li><li>同一届内，两位不同的候选人不能同时获得多数票</li></ul><p>终止性：最终必须有一位候选人获胜</p><ul><li>选举超时时间随机设定在 [T, 2T] 范围内</li><li>通常情况下，一台服务器会在其他服务器唤醒之前超时并赢得选举</li><li>如果超时时间远大于广播时间，则此方法效果良好</li></ul><h3 id="日志复制（Log-Replication）"><a href="#日志复制（Log-Replication）" class="headerlink" title="日志复制（Log Replication）"></a>日志复制（Log Replication）</h3><hr><p>Raft 的核心是复制状态机 (Replicated State Machine)，日志就是这个复制状态机的<strong>操作记录</strong>。在Raft集群中日志是Append-Only的，除了在发生不一致时被 Leader 强行覆盖外不能被修改，集群中所有节点都以“日志”为唯一标准，确保最终执行相同的命令序列。Raft 中定义的每个Log Entry都必须包含以下关键信息：</p><ul><li>term (任期号)：记录这个条目是由哪个任期的 Leader 创建的。这是 Raft 日志一致性检查（Log Matching Property）的核心。Leader 在发送 AppendEntries RPC 时，会用这个 term 值来和 Follower 的日志进行比对。</li><li>command (命令)：包含客户端请求的、需要被状态机执行的具体操作（例如 SET x &#x3D; 5 或 DEL y）。</li><li>日志的索引 (Index) 通常是隐式的，即它在日志数组中的位置，但在 RPC 通信中会显式地作为参数传递。</li></ul><p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95Raft%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90_Raftf%E7%AE%97%E6%B3%95%E6%97%A5%E5%BF%97%E9%A1%B9.png"></p><h4 id="日志复制流程"><a href="#日志复制流程" class="headerlink" title="日志复制流程"></a>日志复制流程</h4><p>当 Leader 接收到客户端请求时，它会将请求转换为LogEntry，并将该日志同步复制到所有的 Follower 节点，每个日志都有一个唯一的索引和所属的任期（Term）。日志同步完整流程：</p><ul><li>客户端请求到达领导者: 所有客户端的写请求都必须先发送给当前的领导者。</li><li>领导者追加到本地日志: 领导者将客户端请求封装成一个带有当前任期号和日志索引的日志条目，并追加到自己的本地日志末尾。</li><li>并行发送 AppendEntries RPC: 领导者并行地向所有跟随者（Follower）发送 AppendEntries RPC。这个 RPC 包含新的日志条目以及一些元信息（如领导者的任期号、前一个日志条目的索引和任期号等）。</li><li>跟随者响应:<ul><li>跟随者收到 AppendEntries 请求后，首先进行一致性检查（见下文）。</li><li>如果检查通过，跟随者将日志条目追加到自己的日志中，并回复领导者一个成功的确认（Success: True）。</li><li>如果检查失败（例如，日志不匹配），跟随者回复领导者一个失败的响应（Success: False）。</li></ul></li><li>领导者确认多数派: 领导者等待来自多数节点（N&#x2F;2 + 1）的成功确认。一旦确认，领导者就知道该日志条目已经被安全复制。</li><li>提交并应用到状态机:<ul><li>领导者将该日志条目标记为“已提交”（Committed），并应用到本地的状态机（如执行数据库操作）。</li><li>领导者回复客户端请求成功。</li><li>在后续的 AppendEntries RPC（包括心跳）中，领导者会通知跟随者更新它们的 commitIndex，使跟随者也能安全地应用这些已提交的日志到它们各自的状态机。</li></ul></li></ul><h4 id="日志修复流程"><a href="#日志修复流程" class="headerlink" title="日志修复流程"></a>日志修复流程</h4><p>Raft 算法能够自动处理节点崩溃、网络延迟等导致的日志不一致情况。修复流程也是通过 AppendEntries RPC 来实现的：</p><ul><li>一致性检查: 领导者在每次发送 AppendEntries RPC 时，会包含它认为的跟随者应匹配的前一个日志条目的索引 (prevLogIndex) 及其任期号 (prevLogTerm)。</li><li><strong>跟随者日志匹配</strong>: 跟随者检查自己的日志中是否存在与 prevLogIndex 和 prevLogTerm 匹配的条目。<ul><li>如果匹配，则说明日志在该点之前是一致的，跟随者接受新的日志条目。</li><li>如果不匹配，跟随者拒绝该 AppendEntries 请求。</li></ul></li><li>领导者回溯并重试: 领导者收到失败响应后，会递减记录的该跟随者的 nextIndex（下一个应发送的日志索引），并重试发送 AppendEntries RPC。</li><li>强制一致: 这个过程持续回溯，直到找到领导者和跟随者日志中第一个一致的点。然后，领导者会发送所有后续的日志条目，强制覆盖跟随者本地冲突的日志，使跟随者与领导者保持一致。</li></ul><p>通过这种机制，Raft 确保了即使在出现故障和网络分区后，所有节点的日志最终都能收敛到一致的状态。</p><h3 id="安全性保证（Safety）"><a href="#安全性保证（Safety）" class="headerlink" title="安全性保证（Safety）"></a>安全性保证（Safety）</h3><hr><p>Raft 算法的安全性保证确保了分布式系统在任何故障情况下都能维护数据一致性，核心目标是 <strong>永不返回错误的结果</strong>。Raft 的安全性机制设计精巧，主要围绕<strong>已提交日志的不可变性和领导者角色的正确性</strong>展开。</p><p><strong>选举安全性 (Election Safety)</strong>: 在一个给定的任期（Term）内，最多只能选举出一个领导者（Leader）。候选人只有在收到集群中多数节点的投票时才能成为领导者，即多数派原则。另外，在任期内每个节点在一个给定的任期内最多只能投出一张票。结合多数派原则和单次投票机制，即使出现网络分区导致多个候选人竞争，也不可能同时有两个候选人在同一个任期内获得多数票。</p><p><strong>领导者只追加原则 (Leader Append-Only)</strong>：领导者永远不会覆盖或删除其日志中的条目，只会在日志末尾追加新条目。当领导者发现跟随者的日志与自己不一致时，它会强制跟随者截断其错误的日志，然后从正确的一致点开始复制领导者的日志，领导者自己的日志作为“事实的来源”是不可修改的。</p><p><strong>日志匹配原则 (Log Matching Property)</strong>：确保不同节点日志的一致性起点是相同的。</p><ul><li>一致性检查: 在 AppendEntries RPC 中，领导者会发送前一个日志条目的索引和任期号。</li><li>连锁一致性: 如果跟随者能够匹配这个前一个条目的索引和任期号，Raft 保证在该点之前的所有日志都是完全一致的。如果不匹配，日志会在该点或更早的点上存在分歧，领导者将启动修复流程。</li></ul><p><strong>已提交状态机一致原则 (State Machine Safety &#x2F; Committed Entries Must Be Applied)</strong>：如果一个日志条目已被集群中的多数节点提交，那么所有节点最终都会提交并应用该条目，并且不会有任何节点应用一个被丢弃的（未提交）日志。</p><ul><li>多数派提交: 日志条目只有在被复制到多数节点后才被标记为已提交。</li><li>不可改变性: Raft 保证一旦一个条目被提交，它就是持久且不可更改的。随后的所有领导者都必须包含这个已提交的条目。</li></ul><p><strong>领导者完整性原则 (Leader Completeness Property)</strong>：如果一个日志条目在某个任期内被提交了，那么后续所有任期的领导者都必须拥有这个日志条目，这个原则确保了新当选的领导者一定包含了所有先前已提交的日志，从而防止已提交数据丢失。</p><ul><li>选举限制: 这是最关键的安全性机制之一。在选举过程中，Raft 只允许拥有集群中最完整日志的节点成为领导者。</li><li>投票要求: 候选人在请求投票时，需要提供自己的最新日志信息。投票者只有在确认候选人的日志“至少和自己一样新”（根据最新日志的任期号和索引判断）时，才会投票给它。</li></ul><h3 id="容错性实现"><a href="#容错性实现" class="headerlink" title="容错性实现"></a>容错性实现</h3><hr><p>Raft 算法的容错性主要依赖于法定人数机制 (Quorum) 和领导者驱动的状态同步来实现。只要集群中多数节点正常运行并能相互通信，系统就能在少数节点发生故障、网络延迟或分区的情况下保持可用性和数据一致性。 </p><p><strong>法定人数机制（Quorum System）</strong>：这是 Raft 容错的基石。所有重要的决策（如领导者选举、日志提交）都需要获得集群中多数节点的同意。 对于一个包含 (N) 个节点的集群，只要至少有 ((N&#x2F;2)+1) 个节点正常工作，系统就可以容忍最多 ((N-1)&#x2F;2) 个节点的故障。即使少数节点宕机，多数节点依然可以达成共识并持续提供服务，确保了系统的高可用性。 </p><p><strong>强领导者模型与任期（Term）机制</strong>：Raft 采用强领导者模型，所有数据变更都必须通过领导者。任期机制是解决潜在“脑裂”（Split-Brain，即多个节点认为自己是领导者）问题的关键，每个领导者都有一个唯一的、递增的任期号。当一个节点收到一个带有更大任期号的 RPC 请求时，它会立即更新自己的任期号并退回跟随者状态。这确保了在任何一个任期内，只会有一个领导者拥有权威，避免了冲突更新。</p><p><strong>领导者选举与自动故障转移</strong>：当领导者失效时，Raft 能够快速自动选举出新的领导者。 </p><ul><li>心跳与超时: 跟随者通过心跳超时机制检测领导者故障。</li><li>选举过程: 如果超时，跟随者成为候选人并发起选举。获得多数票的候选人成为新领导者。</li><li>恢复速度: 新领导者通常能在几百毫秒内被选出，最大程度减少停机时间。</li></ul><p><strong>日志复制与一致性保证</strong>：Raft 确保已提交的日志永远不会丢失，即使领导者在提交后立即崩溃。 </p><ul><li>持久化: 关键的 Raft 状态（当前任期号、投票信息、日志条目）在响应 RPC 之前必须持久化到稳定存储（磁盘）。这确保了服务器重启后能恢复正确的状态。</li><li>日志匹配与修复: 领导者通过一致性检查和回溯机制（如前所述的 nextIndex 调整）自动修复跟随者不一致的日志，强制所有节点日志收敛到一致的状态。</li></ul><p>Raft 算法通过多数派原则来容忍节点故障，通过任期机制来解决脑裂和一致性冲突，通过领导者选举实现故障转移，并通过日志持久化和自动修复确保数据的安全性和一致性。这些机制使得 Raft 成为构建可靠、容错的分布式系统的实用选择。 </p><h4 id="Raft-故障恢复原理"><a href="#Raft-故障恢复原理" class="headerlink" title="Raft 故障恢复原理"></a>Raft 故障恢复原理</h4><hr><p>Raft 算法的故障恢复是其核心容错能力的一部分，它旨在确保在节点崩溃、网络分区等故障发生后，系统能够自动恢复一致性并继续提供服务。恢复过程主要依赖于领导者选举、持久化存储和日志同步机制。</p><p><strong>领导者故障恢复</strong>：当领导者节点崩溃或网络中断时，集群会触发新的选举流程：</p><ul><li>超时检测: 跟随者节点通过检测心跳超时来判断领导者是否失效。</li><li>触发选举: 超时的跟随者将状态转换为候选人，增加当前任期号（Term），并向其他节点请求投票。</li><li>选举新领导者: 获得多数节点投票的候选人成为新的领导者。</li><li>安全性保证: Raft 确保只有拥有最完整、最新的已提交日志的节点才能当选为领导者。这防止了已提交数据在领导者切换过程中丢失。</li></ul><p><strong>跟随者故障恢复（节点重启）</strong>：跟随者节点的故障恢复相对简单，因为领导者会主动管理日志同步。</p><ul><li>持久化状态: Raft 要求节点在响应 RPC 前将关键状态（当前任期号、已投票对象、日志条目）持久化到磁盘。当节点重启时，它会从持久化存储中恢复这些状态。</li><li>重新加入集群: 重启后的节点以跟随者身份重新加入集群，并联系领导者。</li><li>日志同步与修复: 领导者使用 AppendEntries RPC 机制自动修复该跟随者的日志，领导者通过找到与跟随者日志一致的最后一个点，并强制覆盖跟随者所有不一致的日志条目，使其日志与领导者一致。</li></ul><p><strong>网络分区恢复</strong>：网络分区可能导致集群分裂成多个子集。Raft 使用多数派原则来处理这种情况：</p><ul><li>多数派存活: 只有在拥有多数节点的分区中，才能成功选举出领导者，并继续处理客户端请求和提交新的日志条目。</li><li>少数派停滞: 少数派分区中的节点无法达成多数共识，因此无法提交新的日志条目，也无法响应客户端写请求。可能会有节点尝试发起选举，但无法获得多数票。</li><li>网络恢复: 当网络分区愈合时，少数派分区的节点会收到来自多数派领导者的心跳或日志同步请求。它们会发现领导者的任期号更大，从而退回跟随者状态，并通过日志同步机制快速与领导者日志保持一致。</li></ul><p>总之：Raft 算法的故障恢复核心在于：</p><ul><li>快速选举：确保系统能迅速选出新的领导者以恢复可用性。</li><li>日志同步：领导者负责强制使所有跟随者的日志与其保持一致，修复任何不一致或缺失的日志条目。</li><li>多数派原则：确保在任何时候只有单一权威能提交数据，防止数据冲突或丢失。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Raft 算法通过将一致性问题分解为领导者选举、日志复制和安全性三个子问题，并围绕一个强领导者模型来构建，实现了高度的可理解性和可实现性。</p><ul><li>任期 (Term) 是逻辑时钟，用于识别过时的服务器。</li><li>领导者选举 确保只有一个 Leader，并且 Leader 拥有最新的日志。</li><li>日志复制 确保所有 Follower 的日志最终都与 Leader 一致，通过“日志匹配特性”和 Leader 强行覆盖来实现。</li><li>安全性限制 确保了数据的正确性，如“已提交”的日志永不丢失。</li></ul>]]></content>
    
    
    <categories>
      
      <category>架构</category>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>架构</tag>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式共识-Paxos算法分析</title>
    <link href="/2025/07/26/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95Paxos%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"/>
    <url>/2025/07/26/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95Paxos%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>上一篇<a href="https://ares081.github.io/2025/07/25/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/#%E7%8A%B6%E6%80%81%E6%9C%BA%E5%A4%8D%E5%88%B6%E6%A8%A1%E5%9E%8B">分布式共识理论基础</a>中分析了SMR模型，SMR模型是分布式系统中实现容错性和强一致性的最重要、最基础的范式之一，它提供了一种机制，使得一组服务器能够像一个单一、可靠的、高性能的服务器一样运行，即使其中一些服务器发生故障，实现 SMR 通常需要依赖一个分布式共识算法来管理操作日志的同步，其中Paxos、Raft、ZAB等分布式共识算法就是其具体的实现。</p><span id="more"></span><h2 id="Paxos算法"><a href="#Paxos算法" class="headerlink" title="Paxos算法"></a>Paxos算法</h2><p><a href="https://ongardie.net/static/raft/userstudy/paxos.pdf">Paxos算法</a>，是由Leslie Lamport提出的一种基于消息传递的协商共识算法，是第一个被证明能在允许节点故障和网络不可靠的异步系统中实现共识的算法。通常用于解决在一个可能发生消息丢失、延迟、重复，但节点不会恶意篡改（即“非拜占庭”）的异步分布式系统中，如何就单个值（例如，谁是主节点，下一个操作是什么）达成 <strong>一致（Consensus）</strong> 的问题。</p><h2 id="Basic-Paxos"><a href="#Basic-Paxos" class="headerlink" title="Basic Paxos"></a>Basic Paxos</h2><p>在 Basic Paxos 中，一个节点可以同时扮演一个或多个角色，主要由三种角色组成：</p><ul><li>Proposers（提议者）：它们向系统提交提案，提案包含一个值（Value）和一个全局唯一的、递增的提案编号（Proposal Number, N）。</li><li>Acceptors（接受者）：它们对提案进行投票，接受或拒绝一个提案。负责在多个提案中进行权衡，并最终接受或拒绝一个值。达成共识的关键在于 Acceptor 的多数派，最终一致性的保证来自于接受者对提案的接受。</li><li>Learners（学习者）：它们用于学习已被接受的提案的结果，通常是系统的客户端。</li></ul><p>在Basic Paxos算法系统中总共有 N 个 Acceptor。一个多数派（Majority &#x2F; Quorum）指的是至少 floor(N&#x2F;2) + 1 个 Acceptor。任意两个“多数派”集合必然至少有一个共同的 Acceptor 成员，这是 Paxos 安全性的数学基础。</p><h3 id="算法流程：两阶段提交（Basic-Paxos）"><a href="#算法流程：两阶段提交（Basic-Paxos）" class="headerlink" title="算法流程：两阶段提交（Basic Paxos）"></a>算法流程：两阶段提交（Basic Paxos）</h3><p>基本的 Paxos 算法通过一个两阶段提交过程来确保即使有多个提议者同时竞争，也能最终选定一个唯一值。这个过程在每一轮共识中重复进行：</p><p><strong>阶段一：准备阶段 (Prepare Phase)</strong>：目标是选择一个唯一的提案编号，并保证不会有编号更小的提案被接受。</p><ul><li>提议者发起准备请求: 提议者选择一个全局唯一的、单调递增的提案编号 N（通常由时间戳或递增计数器加上节点ID生成），并向多数接受者发送一个“准备 (Prepare)”请求。</li><li>接受者响应: 接受者收到编号为 N 的 Prepare 请求后，如果其尚未向任何编号大于 N 的 Prepare 请求作出过承诺，则：<ul><li>承诺 ( Promise) 不再接受任何编号小于 N 的提案。</li><li>如果接受者之前已经接受过某个提案，它必须返回其已接受的编号最大的提案的值 V 和对应的编号 M (M &lt; N)。</li><li>如果接受者已经对编号大于 N 的请求做出了承诺，它将忽略该请求或返回一个拒绝消息。</li></ul></li></ul><p><strong>阶段二：接受阶段 (Accept Phase)</strong>：目标是让多数接受者接受提议者的值。</p><ul><li><p>提议者发送接受请求: 提议者在收到多数（法定人数）接受者的  Promise 响应后，开始准备发送“接受 (Accept)”请求。</p><ul><li>如果所有响应的接受者都没有返回任何已接受的值，提议者可以使用自己最初想要提出的值 V。</li><li>如果响应中存在“已经接受过的值”，Proposer 必须选择那个<strong>accepted_N 编号最大</strong>的 accepted_V，作为自己这次要提议的值（保证已选定的值不会被覆盖）。</li><li>Proposer 选定了值（我们称之为 Final_V）后，它向所有（至少是那些回应了的多数派）Acceptor 发送 Accept(N, Final_V) 请求。</li><li>如果 Proposer 未能获得“多数派”的 Promise（比如超时或收到了太多 Nack）：它必须放弃此次尝试，在未来选择一个更大的提案编号，重新从阶段一开始。</li></ul></li><li><p>接受者接受提案: 当一个 Acceptor (A) 收到 Accept(N, Final_V) 请求时，它会检查这个 N 是否“足够新”。</p><ul><li>N &gt;&#x3D; max_promised_N (这个提案编号 N 至少和我承诺过的一样大)，Acceptor 接受这个提议。它将自己的 accepted_N 更新为 N，accepted_V 更新为 Final_V。同时向 Proposer 和所有 Learner 发送 Accepted(N, Final_V) 消息。</li><li>N &lt; max_promised_N (这个提案已经过时了)，Acceptor 拒绝这个 Accept 请求。</li></ul></li><li><p>学习者获知结果: 一旦一个值被多数接受者接受，该值即被确定（Chosen）。Learner 负责发现这个被“选择”的值，它会监听来自所有 Acceptor 的 Accepted 消息，一旦 Learner 发现有多数派的 Acceptor 都宣称接受了同一个值 V，它就知道 V 已经成为共识。接受者或提议者会将此信息通知给学习者，学习者从而得知最终的共识值。</p></li></ul><p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80_basic-paxos%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B.png"></p><p>Paxos的核心特性是通过多数接受（quorum）来确保一致性，即一个提议必须被大多数接受者接受才能成为最终决定的值：</p><ul><li>Safety（安全性）：Paxos 确保任何时刻只有一个提议会被接受并作为决策。即使系统出现故障，只要仍然有多数接受者存活，就能够达成一致。</li><li>Liveness（终止性）：只要系统有足够的提议者和接受者，Paxos会最终达成一致。也就是说，只要有足够的消息传递，系统会最终决定一个值。</li></ul><h3 id="Basic-Paxos问题分析"><a href="#Basic-Paxos问题分析" class="headerlink" title="Basic Paxos问题分析"></a>Basic Paxos问题分析</h3><p>假设一个分布式系统有五个节点，分别是S1、S2、S3、S4和S5；全部节点都同时扮演着提案节点和决策节点的角色。此时，有两个并发的请求希望将同一个值分别设定为X（由S1作为提案节点提出）和Y（由S5作为提案节点提出）；我们用P代表准备阶段、用A代表批准阶段，这时候可能发生下面四种情况。</p><p>情况一: 已选值被新值替换。如下图，S1的提案被大多数授受，当S5发起提案时，同样可以被大多数授，最终系统会使用S5的提案Y。<br><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80_basic-paxos%E5%88%86%E6%9E%90%E6%83%85%E5%86%B5%E4%B8%80.png"></p><p>情况二：两个节点发起提案，前一个提案未被大多数授受，后发起的提案在的某个Accept节点包含前一个提案的Accept值，这种情况尽管后一个节点的提案N更大，但是不会被选为共识值。如下同，S5发起提案的Prepare请求时，X并未获得多数派批准，但由于S3已经批准的关系，最终共识的结果仍然是X。<br><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80_basic-paxos%E5%88%86%E6%9E%90%E6%83%85%E5%86%B5%E4%BA%8C.png"></p><p>情况三：先前的值未被选中，新的提议者Accept节点未包含前一个提案值，最终会被授受的提案为后一个提案值。如下图，应答S5提案时，节点S1、S2已经批准了X，S3未批准但返回了Promise应答，此时S5以更大的提案ID获得了S3、S4和S5的Promise。这三个节点均未批准过任何值，那么S3将不会再接受来自S1的Accept请求，因为它的提案ID已经不是最大的了，这三个节点将批准Y的取值，整个系统最终会对“取值为Y”达成一致。<br><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80_basic-paxos%E5%88%86%E6%9E%90%E6%83%85%E5%86%B5%E4%B8%89.png"></p><p>情况四：活锁问题，两个 Proposer 轮流用更高的提案编号打断对方的阶段 1，导致没有提案能成功进入阶段 2。如下图，从情况三可以推导出另一种极端的情况，如果两个提案节点交替使用更大的提案ID使得准备阶段成功，但是批准阶段失败的话，这个过程理论上可以无限持续下去，形成活锁（Live Lock）。在算法实现中，会引入随机超时时间来避免活锁的产生。<br><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80_basic-paxos%E5%88%86%E6%9E%90%E6%B4%BB%E9%94%81%E9%97%AE%E9%A2%98.png"></p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>虽然Paxos在理论上非常强大，但是它的实际实现较为复杂，主要有如下挑战：</p><ul><li>消息复杂性：Paxos 需要多个阶段的消息交换（准备、提议、决定），这会导致系统的延迟和消息量增加。</li><li>活跃性问题：虽然Paxos保证安全性，但它可能出现无法达成一致的情况，尤其是在提议者或接受者出现故障时。为了增强活跃性，Paxos通常需要配合其他机制（如领导选举、超时重试等）来处理。</li><li>高可用性：为了保证一致性和高可用性，Paxos要求系统中的大多数节点（超过半数）必须正常工作。这就要求系统有较高的容错能力。</li></ul><h2 id="Multi-Paxos"><a href="#Multi-Paxos" class="headerlink" title="Multi Paxos"></a>Multi Paxos</h2><p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9FSMR%E6%A8%A1%E5%9E%8B.png"><br>Basic Paxos 只用于就单个值达成一次共识，同时每次决策都需要完整的两阶段（Prepare + Accept），如果每次都执行完整的协议步骤，会导致非常高的通信开销和性能问题，特别是当系统需要多次达成一致时，而且容易产生“活锁”。在实际系统实现中需要对一系列值（Log Entry 1, 2, 3…）快速连续地达成共识，Multi-Paxos 的引入是为了在多次决策中减少通信开销，并确保在多个连续的决策过程中只需要执行最少的操作，最大化效率。</p><p>如果说 Basic Paxos 像一个混乱的议会，任何人（Proposer） 都可以随时发起提案（Prepare），导致“活锁”；那么 Multi-Paxos 就引入了一个“总统”——Leader（领导者）。<font color=red>Multi-Paxos 的核心就是选举一个唯一的、稳定的 Leader，并让这个 Leader 成为系统中唯一的 Proposer。</font> 通过这个核心思想，Multi-Paxos 解决了 Basic Paxos 的两大痛点：</p><ul><li>效率问题： 避免了对每一个日志条目都执行完整的两阶段（Prepare&#x2F;Accept）。</li><li>活锁问题： 因为只有一个 Proposer（Leader），杜绝了 Proposer 之间相互“打架”导致活锁的可能性。</li></ul><h3 id="Multi-Paxos原理分析"><a href="#Multi-Paxos原理分析" class="headerlink" title="Multi-Paxos原理分析"></a>Multi-Paxos原理分析</h3><p><strong>Leader 选举 (Leader Election)</strong>：在 Multi-Paxos 集群启动或当前领导者失效时，节点会触发领导者选举流程，这个过程本质上就是运行一轮标准的 Basic Paxos 算法，就“谁是当前领导者”达成共识。</p><ul><li>发起选举： 任何一个节点（Proposer）如果发现当前没有 Leader（例如，通过心跳超时检测），它都可以发起一轮 Leader 选举。</li><li>提案内容： 这次 Basic Paxos 提案的“值（Value）”不再是具体的操作，而是Proposer 自己的 ID。</li><li>达成共识： 节点们运行 Basic Paxos 的两阶段（Prepare&#x2F;Accept）。最终，如果一个节点（比如 Node A）的 ID 被“选择”（Chosen）为 Leader，那么它就获得了 Leader 身份。</li><li>提案编号 (N)： 赢得选举的 Leader 会使用它在 Basic Paxos 中胜出的那个提案编号 N 作为自己的“任期号”(term)或“时代号”（Epoch）。</li></ul><p>Leader 在刚当选时，会先执行一次完整的 Basic Paxos（Prepare + Accept）。Leader 向所有 Acceptor 广播 Prepare(N)，让所有 Acceptor 承诺（Promise）“不再接受任何小于 N 的提案”。这实质上“罢免”了所有旧的 Leader。同时，Leader 会检查 Promise 响应中返回的 accepted_V（之前已接受的值），来发现并补全自己可能缺失的日志（称为“日志空洞填充”）。一旦上述 Prepare 阶段成功，Leader 就获得了“多数派”的 Promise 承诺，只要 Leader 不变，它在为新的日志条目（Log Entry）发起提议时，就可以完全跳过 Prepare 阶段！</p><p><strong>日志复制</strong>：一旦领导者被选出并稳定运行，Multi-Paxos 进入高效的常态运行阶段，处理客户端请求并复制日志。</p><ul><li>客户端请求与日志追加：客户端向领导者发送一个操作请求。领导者将请求封装成一个日志条目，包含一个值 (Value)（即客户端指令）和一个唯一的日志索引 (Log Index &#x2F; Slot Number)。这个日志索引对应于一个特定的 Paxos 实例。 </li><li><strong>简化的 Accept 阶段 (一阶段提交)</strong>：在 Basic Paxos 中，每一个值都需要完整的 Prepare&#x2F;Accept 两阶段。在 Multi-Paxos 中，由于领导者已经预先获得了多数派的承诺，可以直接跳过 Prepare 阶段：<ul><li>发送 Accept: 领导者直接向多数接受者发送一个Accept 请求，其中包含当前的任期编号 N、日志索引 I 和值 V。</li><li>接受者响应: 接受者收到 Accept 请求后，如果请求的任期编号 N 不小于它之前承诺或看到的任何编号，它会立即接受该值，并将其写入本地日志，然后回复领导者一个确认（ACK）。</li></ul></li><li>学习与提交 (Learn&#x2F;Commit 阶段)：领导者收到多数接受者的确认响应后，即可确定该日志条目已经达成共识（Chosen）。这时领导者会通知所有节点（包括学习者和其他接受者）该日志条目已提交，通常这个提交信息会搭载在后续的心跳包或下一个 Accept 请求中发送。最终，所有节点将已提交的日志条目按顺序应用到本地的状态机（如数据库），从而实现全系统的强一致性。</li></ul><p><strong>失败恢复</strong>：Multi-Paxos 也面临着系统中节点失败的挑战，特别是 Leader 失败时。为了保证系统能继续运行，Multi-Paxos 需要能够快速恢复，确保系统能够选举出新的 Leader 并继续达成一致。</p><ul><li>Leader 失败后的恢复：当当前的 Leader 发生故障时，系统需要通过选举过程选出新的 Leader，并且新的 Leader 会继续使用合适的提议编号发起新的提议，直到恢复一致性。</li><li>恢复策略：可以通过超时机制（比如 Paxos 的超时机制）来启动选举。新的 Leader 可能需要进行一些额外的协调，特别是如果在 Leader 失败期间出现了其他提议。</li></ul><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>Multi-Paxos 的本质是通过 Basic Paxos 选举出一个 Leader，然后将共识的执行过程（Propose）和 Leader 的租期（Lease）绑定。</p><ul><li>只要 Leader 的“租期”（由其提案编号 N 代表）有效，它就可以绕过 Basic Paxos 繁琐的 Prepare 阶段，实现高效的“一阶段提交”共识（Fast Path）。</li><li>当 Leader 失败时，系统通过新一轮的 Basic Paxos（使用 N+1）来“抢占”租期，选举出新 Leader，从而实现容错。</li></ul><p>Multi-Paxos 极大地提高了 Paxos 的实用性，但其实现（特别是 Leader 切换和日志空洞填充）非常复杂。这也催生了后来更易于理解和实现的 Raft 算法。</p>]]></content>
    
    
    <categories>
      
      <category>架构</category>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>架构</tag>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式共识理论基础</title>
    <link href="/2025/07/25/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/07/25/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>分布式系统是将一个大型计算任务分解为多个子任务，并分布到多台通过网络连接的计算机上执行的系统。这些独立的计算机节点协同工作，共同提供一个统一的服务或完成一个共同的目标。分布式系统是现代高并发、高可用互联网服务的基础架构，旨在通过协同多台廉价机器来提供稳定、高效、可扩展的服务。</p><span id="more"></span><p>分布式系统具有以下几个关键特征：</p><ul><li>并行性 (Concurrency)：系统中的多个节点可以同时执行任务，提高了整体的处理能力。</li><li>透明性 (Transparency)：用户通常不需要知道任务是在哪台具体的机器上执行、数据存储在哪里。系统从外部看起来像一个单一的整体。</li><li>容错性 (Fault Tolerance)：即使系统中的部分节点出现故障（崩溃、网络中断），整个系统仍能继续运行并提供服务。</li><li>可扩展性 (Scalability)：可以通过增加更多的机器节点来提高系统的处理能力和存储容量，而不需要对现有系统架构进行大规模修改。</li></ul><p>在分布式系统中存在诸多挑战，主要集中在以下几个方面：</p><ul><li>网络不可靠：网络延迟、消息丢失、连接中断是常态，必须设计机制来处理这些情况。</li><li>节点故障：节点可能随时崩溃或暂停，需要故障检测和恢复机制。</li><li>一致性与协调：多个节点需要就数据状态、操作顺序或领导者选举达成一致，这就是“分布式共识问题”。这通常需要 Paxos、Raft 等复杂算法来解决。</li><li>时间与顺序：在分布式系统中难以确定事件发生的绝对时间顺序，需要逻辑时钟（如 Lamport 时间戳）等机制来辅助排序。</li></ul><p>在诸多挑战中，一致性与协调问题即分布式共识问题是分布式系统中的核心挑战，旨在确保在存在节点故障、网络延迟或消息丢失等不可靠因素的情况下，系统中的多个节点能够就某个单一值或操作顺序达成一致性，<strong>一致性描述的是结果状态，即多个节点对外界呈现的状态</strong>。在不可靠的分布式环境中实现共识非常棘手，主要问题包括：</p><ul><li>异步性：节点之间的消息传递存在不可预测的延迟。</li><li>故障容错：节点可能随时崩溃、暂停或发生故障。</li><li>网络不可靠：消息可能丢失、乱序、重复或延迟。</li><li>脑裂（Split Brain）：两个或多个节点同时认为自己是领导者，导致系统状态不一致。</li></ul><p>共识机制是构建可靠、高可用分布式系统的基础，通过达成共识，应用程序可以忽略底层的许多分布式系统问题。</p><h2 id="一致性模型"><a href="#一致性模型" class="headerlink" title="一致性模型"></a>一致性模型</h2><p>在分布式系统中，<font color=red>分布式共识主要目标是保证系统中的多个节点能够就某个单一值或操作顺序达成一致性</font>。如何保证系统中的数据中状态一致性，常见的操作有：<strong>状态转移与操作转移</strong>。状态转移（State Transfer）和操作转移（Operation Transfer，有时也称为操作日志复制）是分布式系统中用于维护副本一致性的两种基本方法，它们都旨在将主节点（Primary&#x2F;Leader）的更新同步到备份节点（Replica&#x2F;Follower），但在实现方式、数据量和性能特性上有着显著区别。</p><p><strong>状态转移 (State Transfer)</strong>：状态转移是一种基于全量数据的同步方法。其核心思想是当一个副本需要更新时，主节点会将当前整个系统的完整状态（或数据快照）发送给该副本，使其直接达到最新的状态。状态转移通常用于节点加入集群、故障恢复或初次同步时。比如，当有新节点加入时，新节点需要从头开始同步数据时，必须使用状态转移获取系统的初始状态。</p><p><strong>操作转移（Operation Transfer &#x2F; Log Transfer）</strong>：复制的不是最终状态，而是导致状态改变的操作序列或命令日志（例如，SQL 语句、键值对的Put&#x2F;Delete操作、Raft日志）。接收方节点接收到操作后，在本地执行相同的操作以改变自己的状态。要求操作必须具有确定性（幂等性）且在所有副本上以相同顺序执行，这是 <strong>状态机复制（SMR）</strong> 模型的核心要求。</p><h3 id="常见一致性模型"><a href="#常见一致性模型" class="headerlink" title="常见一致性模型"></a>常见一致性模型</h3><p>在分布式系统中，一致性模型定义了客户端在不同时间、从不同节点读写数据时，所能观察到的数据行为规则，它是一种契约或保证。主要的一致性类型（或模型）可以分为三大类：强一致性、弱一致性和介于两者之间的混合一致性模型，每种模型都在数据准确性、系统性能和可用性之间进行权衡。 </p><ul><li><p>强一致性 (Strong Consistency) ：强一致性模型确保所有节点在任何时刻看到的数据都是一致的，当一个写操作完成时，后续任何节点的读操作都必须返回最新的已写入值。</p><ul><li>线性一致性 (Linearizability &#x2F; Strict Consistency)：这是最强的一致性模型。它保证系统的行为就如同所有操作都在一个单一的时间线上按顺序执行一样，并且这个顺序与实际发生的时间顺序一致。这意味着操作的可见性是即时的。实现成本最高，系统延迟较高，但数据完整性最高。</li><li>顺序一致性 (Sequential Consistency)：要求所有进程以相同的顺序看到所有内存操作，但这个顺序不一定需要与实际的物理时间顺序一致，只要满足单个进程内的操作顺序即可。它比线性一致性弱，但仍然提供了所有客户端对所有事件的全局一致视角。</li></ul></li><li><p>弱一致性 (Weak Consistency) ：弱一致性允许系统在一段时间内处于不一致状态，最终会达到一致状态。它优先考虑系统的可用性和低延迟。</p><ul><li><strong>最终一致性 (Eventual Consistency)</strong>：这是弱一致性中最常见的形式。它保证，如果不再有新的更新操作发生，系统的所有副本最终都会收敛到同一个值。数据副本之间的同步是异步的。例如，DNS 系统和许多 NoSQL 数据库（如 Cassandra、DynamoDB 的默认模式）都使用最终一致性。</li><li>PRAM 一致性 (Pipelined Random Access Memory Consistency)：要求由同一进程执行的写操作按其编程顺序被所有其他进程看到，但不同进程的写操作顺序可以不同。</li></ul></li><li><p>混合一致性&#x2F;客户端中心一致性 (Hybrid&#x2F;Client-Centric Consistency)：这些模型旨在提供比最终一致性更强的保证，同时避免强一致性的性能开销，通常针对特定客户端的需求进行优化。</p><ul><li>因果一致性 (Causal Consistency)：这是一种比顺序一致性弱、但比最终一致性强的模型。它区分有因果关系的操作和无因果关系的操作。如果事件 A 导致了事件 B（因果关系），那么所有客户端都会以 A 在 B 之前发生的顺序看到这两个事件。对于无因果关系（并发）的事件，不同客户端看到的顺序可能不同。</li><li>读己之所写一致性 (Read Your Writes Consistency)：保证一个客户端在执行写操作后，其后续的读操作总能看到自己最近写入的值，即使其他客户端可能暂时还看不到。</li><li>单调读一致性 (Monotonic Reads Consistency)：保证如果一个客户端读取了某个值，那么它后续对同一数据项的读操作不会读到该值之前的旧版本。</li><li>会话一致性 (Session Consistency)：在特定用户会话的生命周期内，结合了“读己之所写”和“单调读”的特性，提供了对用户体验友好的保证。</li></ul></li></ul><h3 id="复制模型"><a href="#复制模型" class="headerlink" title="复制模型"></a>复制模型</h3><p>在上面提到的诸多一致性模型，但最终都是通过<strong>状态转移或操作转移</strong>来实现，即复制。复制模型是实现一致性的技术基础，没有数据复制，就没有一致性问题。复制的存在带来了数据不一致的挑战，需要通过一致性模型来规范行为。分布式系统中的复制模型主要有以下几种常见模型：</p><ul><li><p><strong>主从复制模型 (Leader-Follower &#x2F; Primary-Backup)</strong> ：这是最直观和常见的复制模型。一个副本被指定为主副本（Leader&#x2F;Primary），负责处理所有写请求。主副本将数据更改以日志或变更流的形式发送给其他从副本（Follower&#x2F;Backup）。读请求可以由主副本或从副本承担，从而提高了系统的读取扩展性和负载均衡能力。主从复制可以实现同步复制或异步复制。同步复制能提供更强的一致性（例如，保证在主副本返回成功前，至少一个从副本已接收数据），但会增加写入延迟；异步复制延迟低，但在主副本发生故障时可能会丢失部分已确认但未同步到从副本的数据。MySQL、PostgreSQL等数据库系统的传统复制方式多采用此模型。 </p></li><li><p><strong>多主复制模型 (Multi-Leader Replication)</strong>：该模型扩展了主从复制，允许多个节点同时充当主副本，处理写请求。每个主副本都可以独立接受写入，然后将其写入操作传播给所有其他主副本。这种模型提高了写入可用性和吞吐量，尤其适用于跨地域分布的系统，因为客户端可以向本地的主副本写入，减少了网络延迟。这种模型的主要挑战在于如何解决冲突，当同一数据在不同主副本上同时被修改时，需要有特定的冲突解决机制（如基于时间戳、版本号或自定义规则）来确保最终一致性。 </p></li><li><p><strong>无主复制模型 (Leaderless Replication)</strong>：在这种模型中，没有固定的主副本角色，任何副本都可以直接接受读写请求。为了保证一致性，通常采用 <strong>Quorum</strong> 机制（法定人数机制）。<strong>Quorum</strong> 机制是，对于一个具有 N 个副本的系统，写入操作需要至少 W 个副本确认成功才算完成，读取操作需要至少 R 个副本响应。只要满足 (W+R&gt;N)，就能确保至少有一个读取的副本包含了最新的写入数据。那么如何实现一致性？通常结合读修复（Read Repair, 客户端在读取时发现数据不一致则进行修复）和&#x2F;或反熵过程（Anti-entropy, 后台进程周期性地同步数据）来维护数据一致性。典型的实现包括 Amazon DynamoDB 和 Apache Cassandra 等 NoSQL 系统。 </p></li><li><p><strong>状态机复制模型 (State Machine Replication, SMR)</strong>：相比于上述主要关注数据复制的模型，SMR 更侧重于通过复制操作日志来保证确定性的状态一致。所有副本都是确定性的状态机，它们从一个共享的、有序的日志中以完全相同的顺序执行相同的操作（命令）。共识算法（如 Paxos 或 Raft）用于维护这个一致的共享日志。SMR提供了非常强的一致性保证（通常是线性一致性），适用于需要严格顺序和一致性的场景，例如分布式协调服务（ZooKeeper, etcd）。</p></li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>在分布式系统中复制模型与状态转移（State Transfer）或操作转移（Operation Transfer，即日志或操作复制）之间存在密切关系。主从复制和多主复制都会在初始同步时使用状态转移，无主复制也可能在读修复或反熵过程中使用状态差异（一种小型的状态转移）来同步个别不一致的数据块。<strong>状态机复制（SMR）</strong> 则严格依赖于操作转移。它通过共识算法（如 Paxos, Raft）确保操作日志的顺序和一致性，然后在所有副本上顺序执行这些日志，从而保证所有副本最终状态一致。那么状态转移或操作转移该如何选择：</p><ul><li>如果模型需要强一致性和操作的全局有序性，那么它通常采用操作转移（日志复制）作为核心同步机制，典型代表是状态机复制和使用物理日志的主从复制。</li><li>如果模型更关注高可用性和灵活性（可能提供最终一致性），则更倾向于使用状态转移（数据块、完整状态）或依赖于冲突解决机制来同步状态差异，典型代表是无主复制和多主复制。</li></ul><p>复制模型是实现一致性的技术基础，没有数据复制，就没有一致性问题。一致性目标决定了复制策略，如果目标是强一致性，系统通常需要采用同步主从复制或复杂的共识算法（如 Paxos、Raft），确保所有节点或法定数量的节点在操作完成前达成一致。如果可以容忍弱一致性，系统可以使用异步复制或多主&#x2F;去中心化复制，以提高性能和可用性。它们共同体现了 CAP 理论（一致性、可用性、分区容错性）的权衡，选择一个特定的复制模型通常意味着在某些一致性级别上做出妥协，反之亦然。总之，<font color=red>复制模型是如何分发数据副本的工程实现，而一致性模型是对客户端可见的行为规范，系统实现应该根据业务需求选择一致性目标，再采用适当的复制模型和协议来实现这一目标。</font></p><h2 id="状态机复制模型"><a href="#状态机复制模型" class="headerlink" title="状态机复制模型"></a>状态机复制模型</h2><p><strong>状态机复制（State Machine Replication, SMR）</strong> 模型是分布式系统中实现容错性和强一致性的最重要、最基础的范式之一。它提供了一种机制，使得一组服务器能够像一个单一、可靠的、高性能的服务器一样运行，即使其中一些服务器发生故障。SMR 的核心思想是将分布式系统建模为一个确定性的状态机（Deterministic State Machine），并在多个节点上复制这个状态机。其原理包括两个关键要素：</p><ul><li>确定性状态机: 所有的副本（Replica）都运行相同的应用程序逻辑，并且这个逻辑对于相同的输入操作会产生完全相同的输出状态。</li><li>有序且一致的输入: 副本接收到客户端的请求后，这些请求必须在所有副本上以完全相同的顺序执行。</li></ul><p>SMR模型实现了，如果所有副本（Actors）都从相同的初始状态开始，并且都以相同的顺序执行相同的指令 (Log &#x2F; 剧本)，那么它们将永远保持在相同的状态，并产生相同的输出。即，无论从哪个初始状态开始，所有健康的副本最终都会达到完全相同的最新状态，从而实现强一致性。下图是SMR模型架构：<br><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80_%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9FSMR%E6%A8%A1%E5%9E%8B.png"></p><ul><li><strong>consensus module（共识模块）- 决策者</strong>：在不可信的分布式节点间，对要执行哪些操作以及顺序如何达成一致（即达成对日志条目顺序的共识），它不关心条目的语义（不关心怎么执行），只负责同意一条条目的顺序并把它可靠地复制到多数节点，并对某一事件达成一至。它是具体算法（如 Raft, Paxos, Zab）的实现，允许多个节点在一个“值”（在这里，这个“值”就是下一条日志条目）上达成一致，并能容忍部分节点失败。</li><li><strong>log（日志）- 指令集</strong>：按照顺序记录客户端请求（或命令）的持久结构，并且以只能追加 (append-only)方式记录严格有序的指令序列(term, index, command)。日志的一致性和顺序是SMR的命脉，如果两个副本的日志不一致（比如顺序颠倒或内容不同），它们的状态机执行后状态就会分歧。它包含了状态机将要执行的所有操作，是共识达成的载体——共识模块保证每个节点最终拥有相同的前缀日志（至少对已提交的部分）。</li><li><strong>state machine（状态机）- 执行者</strong>：状态机是一个计算模型，在每个节点上独立存在的本地状态机，它接收一个“输入”（或“指令”），然后根据当前状态和输入，执行操作，最后转换到一个“新状态”。在实现上通过按日志顺序把日志里的命令依次应用来改变状态机的状态，执行时只对被 <strong>提交（committed）</strong> 的日志条目进行应用。在SMR中，状态机必须是确定性 (Deterministic) 的，在给定相同的状态和相同的输入，它必须总是产生相同的新状态和相同的输出。</li></ul><p>在SMT模型中，共识模块 (Consensus Module) 的唯一职责，就是确保所有节点上的 日志 (Log) 保持一致，而每个节点上的状态机 (State Machine) 则严格地、按顺序地执行这份日志。</p><p><strong>SMR 关键特征</strong>：</p><ul><li>强一致性 (Strong Consistency): SMR 通常提供线性一致性（Linearizability），这是最强的一致性模型之一。客户端读取到的数据永远是最新已提交的数据。</li><li>容错性 (Fault Tolerance): 只要集群中有大多数节点存活并保持连接（例如，5个节点允许2个节点故障），系统就能继续正常运行。</li><li>透明性 (Transparency): 客户端与集群交互时，感觉就像在与一个单一、可靠的服务器交互，不需要关心底层的复制细节。</li><li>普适性 (Generality): 只要应用程序逻辑是确定性的，SMR 就可以复制任何类型的服务（数据库、文件系统、协调服务等）。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>分布式共识问题要求系统中的节点在不可靠环境中对某个值达成一致。解决这个问题对于构建容错、高可用的分布式系统至关重要，而 Paxos、Raft 等算法提供了实现这一目标的有效手段。</p>]]></content>
    
    
    <categories>
      
      <category>架构</category>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>架构</tag>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于redis实现延时任务队列实现</title>
    <link href="/2025/07/25/redis-%E5%BB%B6%E6%97%B6%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0/"/>
    <url>/2025/07/25/redis-%E5%BB%B6%E6%97%B6%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>业务中经常需要做某个操作， 然后一定时间之后看这个操作的执行结果。要么使用定时任务扫描，要么使用延时队列(任务)来实现。延时队列的核心是让消息在未来某个时间点才被消费。常用于如下场景：</p><ul><li>发送延时消息（如订单未支付超时取消）</li><li>定时执行任务（如定时推送通知）</li><li>限流、分布式定时任务等</li></ul><span id="more"></span><h2 id="常见的实现方案"><a href="#常见的实现方案" class="headerlink" title="常见的实现方案"></a>常见的实现方案</h2><h3 id="基于消息中间件-RabbitMQ与RocketMQ"><a href="#基于消息中间件-RabbitMQ与RocketMQ" class="headerlink" title="基于消息中间件:RabbitMQ与RocketMQ"></a>基于消息中间件:RabbitMQ与RocketMQ</h3><h4 id="基于RabbitMQ"><a href="#基于RabbitMQ" class="headerlink" title="基于RabbitMQ"></a><strong>基于RabbitMQ</strong></h4><p>RabbitMQ 可以从两种维度设置消息过期时间，分别是队列和消息本身</p><ul><li>设置队列过期时间，那么队列中所有消息都具有相同的过期时间。</li><li>设置消息过期时间，对队列中的某一条消息设置过期时间，每条消息TTL都可以不同。</li></ul><p>如果同时设置队列和队列中消息的TTL，则TTL值以两者中较小的值为准。而队列中的消息存在队列中的时间，一旦超过TTL过期时间则成为Dead Letter（死信）。</p><p>使用 RabbitMQ 做延时队列是比较常见的一种方式，而实际上RabbitMQ 自身并没有直接支持提供延迟队列功能，而是通过 RabbitMQ 消息队列的 TTL和 DXL这两个属性间接实现的。</p><ul><li>TTL 指的是消息的存活时间，RabbitMQ可以通过x-message-tt参数来设置指定Queue（队列）和 Message（消息）上消息的存活时间，它的值是一个非负整数，单位为微秒。</li><li>DLX即死信交换机，绑定在死信交换机上的即死信队列。RabbitMQ的 Queue（队列）可以配置两个参数x-dead-letter-exchange 和 x-dead-letter-routing-key（可选），一旦队列内出现了Dead Letter（死信），则按照这两个参数可以将消息重新路由到另一个Exchange（交换机），让消息重新被消费。当消息进入死信队列后可以使用下面两个参数进行重新路由：</li><li>x-dead-letter-exchange：队列中出现Dead Letter后将Dead Letter重新路由转发到指定 exchange（交换机）。</li><li>x-dead-letter-routing-key：指定routing-key发送，一般为要指定转发的队列。</li></ul><hr><h4 id="基于RocketMQ"><a href="#基于RocketMQ" class="headerlink" title="基于RocketMQ"></a><strong>基于RocketMQ</strong></h4><p>RocketMQ原生支持延迟消息，可以在发送消息时指定延迟级别。正常的消息在投递后会立马被消费者所消费，而延时消息在投递时，需要设置指定的延时级别（不同延迟级别对应不同延迟时间），即等到特定的时间间隔后消息才会被消费者消费。RocketMQ支持发送延迟消息，但不支持任意时间的延迟消息的设置，仅支持内置预设值的延迟时间间隔的延迟消息，预设值的延迟时间间隔为：<strong>1s、 5s、 10s、 30s、 1m、 2m、 3m、 4m、 5m、 6m、 7m、 8m、 9m、 10m、 20m、 30m、 1h、 2h</strong>。在消息创建的时候，调用 setDelayTimeLevel(int level) 方法设置延迟时间。</p><p>在Broker端，会为每个固定的延时级别启动一个定时任务，轮询检查其对应的延时队列中的消息是否到期。一旦消息到期，就被重新构建并投递到其原始主题和队列，等待消费者消费。 </p><p><strong>工作流程</strong></p><ol><li>生产者发送消息时：在发送带有延时属性的消息时，实际上是发送一个普通消息，但生产者会设置消息属性中的 delayLevel 字段（延时级别）。</li><li>Broker端处理：Broker在收到消息后，会判断 delayLevel 是否大于0，如果消息是延时消息，Broker会 <strong>备份原始消息的topic和queueId</strong> 到消息属性中，然后将消息的主题修改为SCHEDULE_TOPIC_XXXX，队列ID改为delayLevel-1。消息最终会落盘到CommitLog文件，并复制到其他副本，保证可靠性。</li><li>后台定时任务调度：RocketMQ在Broker端会启动一个后台定时任务（ScheduleMessageService）。该任务为每个延时级别创建一个定时器，每秒（或其他固定时间间隔）执行一次拉取操作。它会根据每个延时级别的消费偏移量，从SCHEDULE_TOPIC_XXXX的对应队列中拉取消息。</li><li>消息恢复与投递：拉取到消息后，服务会根据消息的存储时间戳、物理偏移量等信息计算出消息的实际到期时间。当消息的到期时间到达时，服务会构建一条新的消息。在新消息中，清除延时属性，恢复原始的topic和queueId。最后，将这条恢复后的消息重新投递到目标主题的队列中，供消费者消费。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span>&#123;<br>  <span class="hljs-type">DefaultMQProducer</span> <span class="hljs-variable">producer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultMQProducer</span>(<span class="hljs-string">&quot;please_rename_unique_group_name&quot;</span>);<br>  <span class="hljs-comment">//设置namesrv地址</span><br>  producer.setNamesrvAddr(<span class="hljs-string">&quot;111.231.110.149:9876&quot;</span>);<br>  <span class="hljs-comment">//启动生产者</span><br>  producer.start();<br>  <span class="hljs-comment">//发送10条消息</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-string">&quot;TopicTest&quot;</span> <span class="hljs-comment">/* Topic */</span>,<br>          <span class="hljs-string">&quot;TagA&quot;</span> <span class="hljs-comment">/* Tag */</span>,<br>          (<span class="hljs-string">&quot;test message&quot;</span> + i).getBytes(RemotingHelper.DEFAULT_CHARSET) <span class="hljs-comment">/* Message body */</span><br>      );<br>      <span class="hljs-comment">//设置消息延时级别 3对应10秒后发送, 延时级别1对应延时1秒后发送消息,延时级别2对应延时5秒后发送消息,延时级别3对应延时10秒后发送消息,以此类推。</span><br>      msg.setDelayTimeLevel(<span class="hljs-number">3</span>);<br>      <span class="hljs-type">SendResult</span> <span class="hljs-variable">sendResult</span> <span class="hljs-operator">=</span> producer.send(msg);<br>      System.out.printf(<span class="hljs-string">&quot;%s%n&quot;</span>, sendResult);<br>  &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="基于-Redis"><a href="#基于-Redis" class="headerlink" title="基于 Redis"></a>基于 Redis</h3><p>基于redis实现有如下三种方式：</p><ul><li>Sorted Set (zset): 将任务的执行时间戳（作为 Score）和任务信息（作为 Value）存储在 zset 中。使用一个后台线程定时轮询 zset，取出最早到期的任务进行处理。</li><li>键空间通知（Keyspace Notifications）: 为键设置过期时间，并监听 Redis 的键过期事件。当键过期时，触发回调函数处理延时任务。</li><li>Redisson 框架: Redisson 客户端提供了原生的延时队列支持，底层也是基于 Redis 的数据结构实现，使用更方便。</li></ul><hr><h4 id="基于-Sorted-Set-zset-的实现"><a href="#基于-Sorted-Set-zset-的实现" class="headerlink" title="基于 Sorted Set (zset) 的实现"></a><strong>基于 Sorted Set (zset) 的实现</strong></h4><p>这是最主流、最可靠的 Redis 延时队列实现方式。流程如下：</p><ul><li>将任务内容作为 member，将任务的执行时间戳（Unix timestamp）作为 score，使用 ZADD 命令将任务添加到 Sorted Set 中。</li><li>启动一个或多个后台线程&#x2F;消费者，使用 ZRANGEBYSCORE 命令周期性地查询 Sorted Set，查找 score 小于等于当前时间戳的所有任务（即已到期的任务）。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ZADD delay_queue delay_time &quot;任务ID&quot;  # 添加延时任务<br>ZRANGEBYSCORE delay_queue 0 now LIMIT 0 1  # 获取到期任务 <br></code></pre></td></tr></table></figure><p>注意：</p><ul><li>并发竞争：在多线程或多进程环境下，可能存在多个消费者同时尝试处理同一个延迟消息的情况。虽然Redis的ZREM操作是原子的，但在实际的应用场景中，我们还需要确保任务处理逻辑的原子性。这通常可以通过在业务层加锁或者使用Redis的事务（multi&#x2F;exec）来实现。对于大多数延迟队列的使用场景而言，直接在Redis层面处理并发已经足够，因为每个任务ID在队列中是唯一的，且ZREM会确保只移除一个元素。但在某些复杂场景下，如任务需要基于其他数据状态来决策是否执行时，就需要在业务逻辑层面加锁了。</li><li>容错处理：<ul><li>Redis持久化：确保Redis配置了合适的持久化策略（如RDB或AOF），以防止系统崩溃导致的数据丢失。</li><li>失败重试机制：消费者程序应该具备重试机制，当处理任务失败时，能够将任务重新加入队列等待再次处理。</li><li>监控与告警：监控Redis服务器的性能指标（如内存使用率、CPU使用率、网络延迟等），并设置相应的告警阈值，以便及时发现并解决问题。</li></ul></li><li>性能优化：<ul><li>批量处理：可以通过增加每次查询的时间范围（即增加zrangeByScoreWithScores的max参数），来一次性处理多个即将到期的任务，减少Redis的访问次数，提高性能。</li><li>减少网络开销：使用Redis的pipeline特性，将多个命令打包发送到Redis服务器，减少网络往返时间（RTT）。</li><li><strong>分桶策略</strong>: 对于大量任务，可以按照时间范围创建多个 Sorted Set，减少单个集合中的元素数量。</li><li><strong>使用 Redis Lua 脚本</strong>: 确保获取和删除任务的原子性。</li></ul></li></ul><hr><h4 id="基于键空间通知-Keyspace-Notifications-的实现"><a href="#基于键空间通知-Keyspace-Notifications-的实现" class="headerlink" title="基于键空间通知 (Keyspace Notifications) 的实现"></a><strong>基于键空间通知 (Keyspace Notifications) 的实现</strong></h4><p>这种方式利用了 Redis 的过期事件机制。开启键空间通知需要在 Redis 服务器配置中开启键空间通知功能，设置 notify-keyspace-events Ex，表示监听键过期事件。流程如下：</p><ul><li>入队: 将任务内容作为 value，设置一个唯一的 key（如 task:{orderId}），并使用 EXPIRE 或 SETEX 命令给 key 设置一个过期时间，即延时时间。</li><li>消费: 客户端订阅 Redis 的 <strong>keyevent@*</strong>:expired 或特定数据库的 <strong>keyevent@<db></strong>:expired 频道。当 key 过期时，Redis 会发布一个过期事件消息到该频道，订阅的消费者收到消息后即可执行相应的任务。</li></ul><p>keyspace notifications 键空间通知对应的channel被分为两类：</p><ul><li>以<code>__keyspace@&lt;db&gt;__</code>: 为前缀，后面跟的是key的名称，表示监听跟这个key有关的事件。如 <code>__keyspace@&lt;db&gt;__:order_id</code>，就是表示当 order_id这个key过期时，消费者会收到这个key过期的消息。</li><li>以<code>__keyevent@&lt;db&gt;__</code>: 为前缀，后面跟的是消息事件类型，表示监听某个事件。如<code>__keyspace@&lt;db&gt;__:expired</code>，表示监听一个过期事件。</li></ul><p>注意：</p><ol><li><strong>key过期机制问题：</strong> key过期事件的时效性问题，首先提到了Redis过期key的两种清除策略：</li></ol><ul><li>惰性清除。当这个key过期之后，访问时，这个Key才会被清除</li><li>定时清除。后台会定期检查一部分key，如果有key过期了，就会被清除</li></ul><p>key的过期事件发布时机并不是当这个key的过期时间到了之后就发布，而是这个key在Redis中被清理之后，也就是真正被删除之后才会发布。只要两种清除策略都不满足，没人访问需要过期的key，后台的定时清理的任务也没扫描到要过期key，那么就不会发布key过期的事件，自然而然也就监听不到了，会造成一定时间消息的延迟。</p><ol start="2"><li><p>丢消息问题：Redis的丢消息跟MQ不一样，因为MQ都会有消息的持久化机制，可能只有当机器宕机了，才会丢点消息，但是Redis丢消息就很离谱，比如说你的服务在重启的时候就消息会丢消息。</p></li><li><p>消息消费只有广播模式：Redis的发布订阅模式消息消费只有广播模式一种。 如果通过监听channel来获取延迟任务，那么一旦服务实例有多个的话，还得保证消息不能重复处理，额外地增加了代码开发量。</p></li></ol><p>总之：<font color=red>Redis keyspace notifications不保证事件的实时性和可靠性（事件可能会丢失，尤其是在主从切换或网络分区时）。Pub&#x2F;Sub 机制没有消息确认（ACK）机制，消费者接收到消息后处理失败，消息就丢失了,不适合高可靠性要求的场景。 </font></p><hr><h4 id="基于-Redisson-客户端-RDelayedQueue-的实现"><a href="#基于-Redisson-客户端-RDelayedQueue-的实现" class="headerlink" title="基于 Redisson 客户端 RDelayedQueue 的实现"></a><strong>基于 Redisson 客户端 RDelayedQueue 的实现</strong></h4><p>Redisson 的 RDelayedQueue 实际上是基于 Sorted Set（zset）实现的封装。它抽象了底层的 ZSet 操作（如 ZADD、ZRANGEBYSCORE、ZREM），使得可以像操作普通 Java 队列一样使用延时队列。</p><p>Redisson 定期使用 zrangebyscore 命令扫描 SortedSet 中过期的元素，然后将这些过期元素从 SortedSet 中移除，并将它们加入到就绪消息列表中。就绪消息列表是一个阻塞队列，有消息进入就会被消费者监听到。这样做可以避免消费者对整个 SortedSet 进行轮询，提高了执行效率。相比于 Redis 过期事件监听实现延时任务功能，这种方式具备下面这些优势：</p><ul><li>减少了丢消息的可能：DelayedQueue 中的消息会被持久化，即使 Redis 宕机了，根据持久化机制，也只可能丢失一点消息，影响不大。当然了，你也可以使用扫描数据库的方法作为补偿机制。</li><li>消息不存在重复消费问题：每个客户端都是从同一个目标队列中获取任务的，不存在重复消费的问题</li></ul><p>跟 Redisson 内置的延时队列相比，消息队列可以通过保障消息消费的可靠性、控制消息生产者和消费者的数量等手段来实现更高的吞吐量和更强的可靠性，实际项目中首选使用消息队列的延时消息这种方案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DelayQueueService</span> &#123;<br><br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> RedissonClient redissonClient;<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DELAY_QUEUE_KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;my:delay:queue&quot;</span>;<br>  <br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 添加延时任务</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> message 消息内容</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> delay 延迟时间</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> timeUnit 时间单位</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addDelayTask</span><span class="hljs-params">(String message, <span class="hljs-type">long</span> delay, TimeUnit timeUnit)</span> &#123;<br>    <span class="hljs-type">DelayedMessage</span> <span class="hljs-variable">delayedMessage</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedMessage</span>();<br>    delayedMessage.setId(UUID.randomUUID().toString());<br>    delayedMessage.setBody(message);<br>    delayedMessage.setCreateTime(LocalDateTime.now());<br>    delayedMessage.setExecuteTime(LocalDateTime.now().plus(delay, toChronoUnit(timeUnit)));<br>    <br>    <span class="hljs-comment">// 使用Redisson的延迟队列</span><br>    RDelayedQueue&lt;DelayedMessage&gt; delayedQueue = redissonClient.getDelayedQueue(=redissonClient.getBlockingQueue(DELAY_QUEUE_KEY));<br>    <br>    delayedQueue.offer(delayedMessage, delay, timeUnit);<br>    log.info(<span class="hljs-string">&quot;添加延时任务成功，任务ID：&#123;&#125;，延迟：&#123;&#125; &#123;&#125;&quot;</span>, delayedMessage.getId(), delay, timeUnit);<br>  &#125;<br>  <br>  <span class="hljs-comment">// 工具方法：将TimeUnit转换为ChronoUnit</span><br>  <span class="hljs-keyword">private</span> ChronoUnit <span class="hljs-title function_">toChronoUnit</span><span class="hljs-params">(TimeUnit timeUnit)</span> &#123;<br>    <span class="hljs-keyword">switch</span> (timeUnit) &#123;<br>      <span class="hljs-keyword">case</span> DAYS: <span class="hljs-keyword">return</span> ChronoUnit.DAYS;<br>      <span class="hljs-keyword">case</span> HOURS: <span class="hljs-keyword">return</span> ChronoUnit.HOURS;<br>      <span class="hljs-keyword">case</span> MINUTES: <span class="hljs-keyword">return</span> ChronoUnit.MINUTES;<br>      <span class="hljs-keyword">case</span> SECONDS: <span class="hljs-keyword">return</span> ChronoUnit.SECONDS;<br>      <span class="hljs-keyword">case</span> MILLISECONDS: <span class="hljs-keyword">return</span> ChronoUnit.MILLIS;<br>      <span class="hljs-keyword">case</span> MICROSECONDS: <span class="hljs-keyword">return</span> ChronoUnit.MICROS;<br>      <span class="hljs-keyword">case</span> NANOSECONDS: <span class="hljs-keyword">return</span> ChronoUnit.NANOS;<br>      <span class="hljs-keyword">default</span>: <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Unsupported time unit: &quot;</span> + timeUnit);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>消费：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DelayQueueConsumer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InitializingBean</span> &#123;<br><br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> RedissonClient redissonClient;<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DELAY_QUEUE_KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;delay:queue&quot;</span>;<br>  <br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-built_in">this</span>::consumeDelayMessage).start();<br>  &#125;<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">consumeDelayMessage</span><span class="hljs-params">()</span> &#123;<br>    RBlockingQueue&lt;DelayedMessage&gt; blockingQueue = redissonClient.getBlockingQueue(DELAY_QUEUE_KEY);<br>    <span class="hljs-comment">// 将阻塞队列设置为延迟队列的目标队列</span><br>    RDelayedQueue&lt;DelayedMessage&gt; delayedQueue = redissonClient.getDelayedQueue(blockingQueue);<br>    <br>    <span class="hljs-keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">DelayedMessage</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> blockingQueue.take();<br>        log.info(<span class="hljs-string">&quot;消费延时消息：&#123;&#125;&quot;</span>, message);<br>        <span class="hljs-comment">// 这里添加您的业务处理逻辑</span><br>        processMessage(message);<br>      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        Thread.currentThread().interrupt();<br>        log.error(<span class="hljs-string">&quot;消费延时消息被中断&quot;</span>, e);<br>      &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        log.error(<span class="hljs-string">&quot;消费延时消息出错&quot;</span>, e);<br>      &#125;<br>    &#125;<br>      <br>      <span class="hljs-comment">// 不要忘记销毁延迟队列</span><br>      delayedQueue.destroy();<br>  &#125;<br>  <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processMessage</span><span class="hljs-params">(DelayedMessage message)</span> &#123;<br>    <span class="hljs-comment">// 实际的业务处理逻辑</span><br>    log.info(<span class="hljs-string">&quot;处理消息，ID: &#123;&#125;, 内容: &#123;&#125;&quot;</span>, message.getId(), message.getBody());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：对于生产环境中的分布式延时任务，基于 ZSet 的手动实现或使用功能更强大的 Redisson RDelayedQueue 是更可靠的选择。基于键空间通知的方式实现简单，但可靠性较差，仅适用于对延时任务丢失不敏感的非核心业务。</p><h3 id="基于时间轮算法-Time-Wheel"><a href="#基于时间轮算法-Time-Wheel" class="headerlink" title="基于时间轮算法 (Time Wheel)"></a>基于时间轮算法 (Time Wheel)</h3><p>时间轮是一种高效实现大量延时任务的算法，被 Netty、Kafka 等框架采用。拟时钟，将时间划分为多个槽位（Slot），每个槽位代表一个时间刻度。任务根据其到期时间被放置到相应槽位的链表中。通过一个指针周期性地移动，执行当前槽位的任务。对于超出一轮周期的任务，会增加一个轮数属性，待指针再次经过时判断是否执行。<br><img src="/images/redis-%E5%BB%B6%E6%97%B6%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0_HashWheelTimer.png"></p><h3 id="基于-JDK-DelayQueue"><a href="#基于-JDK-DelayQueue" class="headerlink" title="基于 JDK (DelayQueue)"></a>基于 JDK (DelayQueue)</h3><p>Java 开发中可以直接使用 java.util.concurrent.DelayQueue。DelayQueue 是一个基于优先级队列（PriorityQueue）实现的无界阻塞队列，只有当元素的延迟时间到期时才能从队列中取出元素。任务需要实现 Delayed 接口。使用简单、集成在 JDK 中、无需额外依赖、性能较好。但是只能在单机、单个 JVM 实例内使用，不支持分布式环境。 </p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>定义：延迟任务数据模型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title class_">DelayTask</span>&lt;T&gt;(String bizType, T payload, <span class="hljs-type">long</span> delayTime, <span class="hljs-type">long</span> expireTime) <span class="hljs-keyword">implements</span><br>    <span class="hljs-title class_">Serializable</span> &#123;<br>  <span class="hljs-meta">@Serial</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> -<span class="hljs-number">8097910962846184246L</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义: 执行器接口，执行器创建可以考虑使用 Factory 创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DelayQueueExecutor</span> &#123;<br><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="JDK-DelayQueue"><a href="#JDK-DelayQueue" class="headerlink" title="JDK DelayQueue"></a>JDK DelayQueue</h3><p>DelayQueue是JDK提供的API，是一个内置的延迟队列。</p><p><strong>定义任务模型</strong>：在使用DelayQueue实现延时任务，可以通过实现Delayed接口来定义任务数据模型，同时需要实现下面两个方法：</p><ul><li>getDelay方法返回这个任务还剩多久时间可以执行，小于0的时候说明可以这个延迟任务到了执行的时间了。</li><li>compareTo这个是对任务排序的，保证最先到延迟时间的任务排到队列的头。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title class_">JdkDelayElement</span>&lt;T&gt;(DelayTask&lt;T&gt; task) <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Delayed</span> &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getDelay</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> TimeUnit unit)</span> &#123;<br>    <span class="hljs-keyword">return</span> unit.convert(task.expireTime() - System.currentTimeMillis(), TimeUnit.MILLISECONDS);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(<span class="hljs-meta">@NotNull</span> Delayed o)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.getDelay(TimeUnit.MILLISECONDS) &gt; o.getDelay(TimeUnit.MILLISECONDS)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.getDelay(TimeUnit.MILLISECONDS) &lt; o.getDelay(TimeUnit.MILLISECONDS)) &#123;<br>      <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>jdk延迟任务执行实现(如果考虑扩展，可以增加一个抽象类 AbstractJdkDelayQueueExecutor, 增加 bizHandle(T obj) 处理具体的业务)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdkDelayQueueExecutor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DelayQueueExecutor</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(JdkDelayQueueExecutor.class);<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DelayQueue&lt;JdkDelayElement&lt;OrderInfo&gt;&gt; queue;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">JdkDelayQueueExecutor</span><span class="hljs-params">(DelayQueue&lt;JdkDelayElement&lt;OrderInfo&gt;&gt; queue)</span> &#123;<br>    <span class="hljs-built_in">this</span>.queue = queue;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        JdkDelayElement&lt;OrderInfo&gt; element = queue.take();<br>        DelayTask&lt;OrderInfo&gt; delayTask = element.task();<br>        <span class="hljs-type">OrderInfo</span> <span class="hljs-variable">orderInfo</span> <span class="hljs-operator">=</span> delayTask.payload();<br>        logger.info(<span class="hljs-string">&quot;orderId=&#123;&#125;, userId=&#123;&#125;, delayTime=&#123;&#125;, expireTime=&#123;&#125;&quot;</span>, orderInfo.getOrderId(),<br>            orderInfo.getUserId(), delayTask.delayTime(), delayTask.expireTime());<br>      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        logger.error(<span class="hljs-string">&quot;jdk delay task execute failed: &quot;</span>, e);<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>take()方法获取任务的时候，会拿到队列头部的元素，也就是队列中最早需要被执行的任务，通过getDelay返回值判断任务是否需要被立刻执行，如果需要的话，就返回任务，如果不需要就会等待这个任务到延迟时间的剩余时间，当时间到了就会将任务返回。</p><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdkDelayQueueExample</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">OrderInfo</span> <span class="hljs-variable">o1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderInfo</span>(<span class="hljs-number">10000L</span>, <span class="hljs-number">10000L</span>, <span class="hljs-number">100000L</span>, <span class="hljs-string">&quot;o1&quot;</span>);<br>    <span class="hljs-type">OrderInfo</span> <span class="hljs-variable">o2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderInfo</span>(<span class="hljs-number">10000L</span>, <span class="hljs-number">10000L</span>, <span class="hljs-number">100000L</span>, <span class="hljs-string">&quot;o2&quot;</span>);<br>    <span class="hljs-type">OrderInfo</span> <span class="hljs-variable">o3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderInfo</span>(<span class="hljs-number">10000L</span>, <span class="hljs-number">10000L</span>, <span class="hljs-number">100000L</span>, <span class="hljs-string">&quot;o3&quot;</span>);<br><br>    DelayTask&lt;OrderInfo&gt; d1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayTask</span>&lt;&gt;(<span class="hljs-string">&quot;order-service&quot;</span>, o1, <span class="hljs-number">5</span> * <span class="hljs-number">1000L</span>,<br>        System.currentTimeMillis() + <span class="hljs-number">5</span> * <span class="hljs-number">1000L</span>);<br>    DelayTask&lt;OrderInfo&gt; d2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayTask</span>&lt;&gt;(<span class="hljs-string">&quot;order-service&quot;</span>, o2, <span class="hljs-number">5</span> * <span class="hljs-number">1000L</span>,<br>        System.currentTimeMillis() + <span class="hljs-number">5</span> * <span class="hljs-number">1000L</span>);<br>    DelayTask&lt;OrderInfo&gt; d3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayTask</span>&lt;&gt;(<span class="hljs-string">&quot;order-service&quot;</span>, o3, <span class="hljs-number">5</span> * <span class="hljs-number">1000L</span>,<br>        System.currentTimeMillis() + <span class="hljs-number">5</span> * <span class="hljs-number">1000L</span>);<br><br>    DelayQueue&lt;JdkDelayElement&lt;OrderInfo&gt;&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayQueue</span>&lt;&gt;();<br>    queue.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JdkDelayElement</span>&lt;&gt;(d1));<br>    queue.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JdkDelayElement</span>&lt;&gt;(d2));<br>    queue.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">JdkDelayElement</span>&lt;&gt;(d3));<br><br>    <span class="hljs-type">JdkDelayQueueExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JdkDelayQueueExecutor</span>(queue);<br>    executor.execute();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>put()&#x2F;offer()方法在提交任务的时候，会通过根据compareTo的实现对任务进行排序，将最先需要被执行的任务放到队列头。</p><h3 id="基于redis实现"><a href="#基于redis实现" class="headerlink" title="基于redis实现"></a>基于redis实现</h3><p>实现抽象执行器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractRedisDelayQueueExecutor</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DelayQueueExecutor</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(<br>      AbstractRedisDelayQueueExecutor.class);<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">KEY_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;order:delay&quot;</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StringRedisTemplate redisTemplate;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> JsonMapper jsonMapper;<br><br>  <span class="hljs-keyword">protected</span> <span class="hljs-title function_">AbstractRedisDelayQueueExecutor</span><span class="hljs-params">(StringRedisTemplate redisTemplate,</span><br><span class="hljs-params">      JsonMapper jsonMapper)</span> &#123;<br>    <span class="hljs-built_in">this</span>.redisTemplate = redisTemplate;<br>    <span class="hljs-built_in">this</span>.jsonMapper = jsonMapper;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>      <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>      <span class="hljs-comment">// 每次取10个</span><br>      Set&lt;TypedTuple&lt;String&gt;&gt; delays = redisTemplate.opsForZSet()<br>          .rangeByScoreWithScores(KEY_PREFIX, <span class="hljs-number">0</span>, now, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>);<br>      <span class="hljs-keyword">if</span> (delays == <span class="hljs-literal">null</span> || delays.isEmpty()) &#123;<br>        <span class="hljs-keyword">continue</span>;<br>      &#125;<br><br>      <span class="hljs-keyword">for</span> (TypedTuple&lt;String&gt; delay : delays) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">strTaskValue</span> <span class="hljs-operator">=</span> delay.getValue();<br>        <span class="hljs-keyword">if</span> (strTaskValue == <span class="hljs-literal">null</span> || strTaskValue.isEmpty()) &#123;<br>          <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>          DelayTask&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">T</span>&gt; biz = jsonMapper.readValue(strTaskValue, DelayTask.class);<br>          bizHandle(biz.payload());<br>          redisTemplate.opsForZSet().remove(KEY_PREFIX, strTaskValue);<br>        &#125; <span class="hljs-keyword">catch</span> (JsonProcessingException e) &#123;<br>          logger.error(<span class="hljs-string">&quot;biz data to json failed: &quot;</span>, e);<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bizHandle</span><span class="hljs-params">(T obj)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体业务执行器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderDelayTaskExecutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractRedisDelayQueueExecutor</span>&lt;OrderInfo&gt; &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(OrderDelayTaskExecutor.class);<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">OrderDelayTaskExecutor</span><span class="hljs-params">(StringRedisTemplate redisTemplate, JsonMapper jsonMapper)</span> &#123;<br>    <span class="hljs-built_in">super</span>(redisTemplate, jsonMapper);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bizHandle</span><span class="hljs-params">(OrderInfo obj)</span> &#123;<br>    logger.info(<span class="hljs-string">&quot;order delay handle, orderId=&#123;&#125;, userId=&#123;&#125;, skuId=&#123;&#125;&quot;</span>, obj.getOrderId(),<br>        obj.getUserId(), obj.getSkuId());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
      <category>redis</category>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>redis</tag>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式事务原理与实践</title>
    <link href="/2025/07/23/%E4%BA%8B%E5%8A%A1-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <url>/2025/07/23/%E4%BA%8B%E5%8A%A1-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>分布式事务是分布式架构中的核心挑战之一，尤其在跨服务、跨数据库操作时保证数据一致性。在传统的单体应用（Monolithic App）中不同的模块，在同一个数据源上更新数据来完成一项业务，整个过程的数据一致性可以由数据库的本地事务来保证。随着业务需求和架构的变化，单体应用进行了服务化拆分，原来的多个模块被拆分为多个独立的服务，每个服务使用独立的数据源（Pattern: Database per service）。整个业务过程将由多个服务的调用来完成。此时，每个服务自身的数据一致性仍有本地事务来保证，但是整个业务层面的全局数据一致性要如何保障呢？这就是分布式系统所面临的典型分布式事务需求：<strong>分布式系统需要一个解决方案来保障对所有节点操作的数据一致性，这些操作组成一个分布式事务，要么全部执行，要么全部不执行。</strong> </p><span id="more"></span><p><strong>CAP理论</strong>:<br>CAP 定理（Consistency、Availability、Partition Tolerance Theorem），也称为 Brewer 定理，起源于在 2000 年 7 月，是加州大学伯克利分校的 Eric Brewer 教授于<strong>ACM 分布式计算原理研讨会（PODC）</strong> 上提出的一个猜想。</p><ul><li>一致性(Consistency) ：指的是客户端的每次读操作，不管访问哪个节点，要么读到的都是同一份最新数据，要么读取失败。</li><li>可用性(Availability) ：指的是客户端的请求，不管访问哪个节点，都能得到响应数据，但不保证是同一份最新数据。即<strong>我尽力给你返回数据，不会不响应你，但是我不保证每个节点给你的数据都是最新的</strong>，这个指标强调的是服务可用，但不保证数据的一致。</li><li>分区容错性(Partition tolerance) ：指的是当节点间出现消息丢失、高延迟或者已经发生网络分区时，系统仍然可以继续提供服务。也就是说，分布式系统在告诉访问本系统的客户端： <strong>不管我的内部出现什么样的数据同步问题，我会一直运行，提供服务</strong> 。</li></ul><p>在CAP理论中，分布式系统不可能同时满足以下三种，最多只能同时满足其中的两项，这是因为在分布式环境中网络分区是必然存在的，<strong>对于一个分布式系统而言，一致性（Consistency）、可用性（Availability）、分区容错性（Partition Tolerance）3 个指标不可兼得，只能在 3 个指标中选择 2 个</strong> ：</p><ul><li>CP (一致性与分区容错)： 放弃可用性。当发生网络分区时，为了保证数据一致性，系统会停止服务，等待分区恢复或数据同步完成。例如，ZooKeeper、etcd。</li><li>AP (可用性与分区容错)： 放弃强一致性。当发生网络分区时，系统会继续提供服务，但可能返回不一致的数据。当分区恢复后，系统会最终同步数据达到一致。例如，一些 NoSQL 数据库（如 Cassandra、DynamoDB）、大部分注册中心在设计上偏向 AP。</li><li>CA（一致性与可用性）： 放弃分区容错，在没有网络分区时表现良好，但无法处理分区故障。例如：单机数据库、传统RDBMS集群</li></ul><p><img src="/images/%E4%BA%8B%E5%8A%A1-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5_CAP.png"></p><p><font color=red>事实上，在不存在网络分区的情况下也就是分布式系统正常运行时，C 和 A 能够同时保证。只有当发生分区故障的时候，也就是说需要 P 时，才会在 C 和 A 之间做出选择。</font></p><p><strong>BASE理论</strong>：<br>在CAP理论中，我提到分布式系统理论上只能取 CP 或 AP，如果要实现强一致性必然会影响可用性。但是，大多数系统实际上不需要那么强的一致性，而是更关注可用性，所以生产环境，大多数系统都会采用可用性优先的 AP 模型。Base 理论是 CAP 理论中的 AP 的延伸，是对互联网大规模分布式系统的实践总结，强调可用性。BASE理论 是 <strong>基本可用（Basically Available）</strong> 、 <strong>软状态（Soft-state）</strong> 和 <strong>最终一致（Eventually Consistent）</strong> 三个短语的缩写：</p><ul><li>Basically Available（基本可用）：当分布式系统在出现不可预知的故障时，允许损失部分功能的可用性，保障核心功能的可用性。<strong>基本可用在本质上是一种妥协，也就是在出现节点故障或系统过载的时候，通过牺牲非核心功能的可用性，保障核心功能的稳定运行</strong> 。</li><li>Soft state（软状态）：描述的是实现服务可用性的时候系统数据的一种过渡状态，也就是说不同节点间，数据副本存在短暂的不一致。比如，分布式存储中一般一份数据至少会有N个副本，允许系统在不同节点的数据副本之间进行数据同步的过程中存在延时。</li><li>Eventually consistent（最终一致性）：分布式系统即使无法做到强一致性，但应当根据自身业务特点，采用适当的方式在一定时限后使各个节点的数据最终能够达到一致的状态。这个时限取决于网络延时，系统负载，数据复制方案设计等等因素。几乎所有的互联网系统采用的都是最终一致性，只有在实在无法使用最终一致性，才使用强一致性或事务。一般来说，在实际工程实践中有这样几种方式：</li></ul><ul><li><strong>读时修复：</strong> 在读取数据时，检测数据的不一致，进行修复。</li><li><strong>写时修复：</strong> 在写入数据时，检测数据的不一致，进行修复。</li><li><strong>异步修复：</strong> 这个是最常用的方式，通过定时对账检测副本数据的一致性，并修复。</li></ul><p>因为写时修复不需要做数据一致性对比，性能消耗比较低，对系统运行影响也不大，所以许多开源框架都是用这种方式实现最终一致性的。而读时修复和异步修复因为需要做数据的一致性对比，性能消耗比较多，所以需要尽量优化一致性对比的算法，降低性能消耗，避免对系统运行造成影响。</p><p><strong>小结</strong><br>BASE 理论是对 CAP 中一致性和可用性权衡的结果，它来源于对大规模互联网分布式系统实践的总结，是基于 CAP 定理逐步演化而来的。它的核心思想是： <strong>如果不是必须的话，不推荐实现事务或强一致性，鼓励可用性和性能优先，根据业务的特点，来实现非常弹性的基本可用，以及数据的最终一致性</strong> 。</p><h2 id="分布式事务实现方案"><a href="#分布式事务实现方案" class="headerlink" title="分布式事务实现方案"></a>分布式事务实现方案</h2><p>在CAP理论中CAP不可能同时满足三个条件，我们必须要有取舍，在事务中应该遵循ACID，对数据要求强一致性，那么我们必须选择 <code>CP——强一致性</code> ，即<strong>刚性事务</strong>：</p><ul><li>2PC （两阶段提交）</li><li>3PC（三阶段提交）</li></ul><p>刚性事务指的是强一致性，基础是XA协议，XA协议是一个基于数据库的分布式事务协议，其分为两部分：事务管理器（Transaction Manager）<strong>和</strong>本地资源管理器（Resource Manager）。事务管理器作为一个全局的调度者，负责对各个本地资源管理器统一号令提交或者回滚。相对于刚性事务还有<strong>柔性事务(AP + BASE)</strong>： 柔性事务追求的是最终一致性:</p><ul><li>TCC</li><li>Saga</li><li>本地消息表</li><li>MQ事务方案</li><li>最大努力通知</li></ul><h3 id="2PC（两阶段提交）"><a href="#2PC（两阶段提交）" class="headerlink" title="2PC（两阶段提交）"></a>2PC（两阶段提交）</h3><p>为了解决分布式事务的一致性问题，X&#x2F;Open组织（后来并入了The Open Group）提出了一套名为X&#x2F;Open XA（XA 是 eXtended Architecture 的缩写）的处理事务架构，其核心内容是<font color=blue>定义了全局的事务管理器（Transaction Manager，用于协调全局事务）和局部的资源管理器（Resource Manager，用于驱动本地事务）之间的通信接口</font>。XA 接口是双向的，能在一个事务管理器和多个资源管理器（Resource Manager）之间形成通信桥梁，通过协调多个数据源的一致动作，实现全局事务的统一提交或者统一回滚。</p><p><strong>2PC指的是 Prepare &amp; Commit</strong>，2PC 最早是用来实现数据库的分布式事务的，上面提到的 XA 协议是 X&#x2F;Open 国际联盟基于二阶段提交协议提出的，也叫作 X&#x2F;Open Distributed Transaction Processing（DTP）模型，比如 MySQL 就是通过 MySQL XA 实现了分布式事务。<br><img src="/images/%E4%BA%8B%E5%8A%A1-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5_XA-DTP%E6%A8%A1%E5%9E%8B.png"></p><ul><li>ApplicationProgram(AP) 应用程序定义了事务边界并指定构成事务的操作。</li><li>ResourceManager(RM) 资源管理器用来管理需要访问的共享资源，可以理解为关系数据库、文件存储系统、消息队列、打印机等。</li><li>TransactionManagger(TM) 事务管理器是一个独立的组件，他为事务分配标识符并监视事务的执行情况，负责事务完成和故障恢复。</li><li>CommunicationResourceManager(CRM) 通信资源管理器控制一个或多个 TM domain 之间分布式应用的通信。</li></ul><p><font color=green>2PC引入一个作为协调者（coordinator）的组件来统一掌控所有参与者（participant）的操作结果，并最终指示这些节点是否要把操作结果进行真正的提交：</font></p><ul><li>协调者节点（<code>coordinator</code>），一般也叫做 <strong>事务协调者</strong>。</li><li>参与者节点（<code>participant、cohort</code>），一般也叫做 <strong>事务参与者</strong>。</li></ul><h4 id="2PC处理流程："><a href="#2PC处理流程：" class="headerlink" title="2PC处理流程："></a><strong>2PC处理流程：</strong></h4><p>第一阶段：准备阶段：</p><ul><li>协调者向所有参与者发送REQUEST-TO-PREPARE；</li><li>当参与者收到REQUEST-TO-PREPARE消息后，它向协调者发送消息PREPARE或者NO，表示事务是否准备好，如果发送是NO，那么事务回滚。</li></ul><p>第二阶段：提交阶段</p><ul><li>协调者收集所有参与者的返回信息，如果所有参与者都回复PREPARED，那么协调者向所有参与者发送COMMIT消息，否则，协调者发送ABORT消息；</li><li>参与者收到协调者发来的Commit消息或Abort消息，它将执行提交或回滚，并向协调者发送DONE消息确认。</li></ul><p><img src="/images/%E4%BA%8B%E5%8A%A1-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5_2PC%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png"></p><p><strong>两阶段提交的缺点：</strong></p><ul><li>网络抖动导致数据不一致：第二阶段协调者向参与者发送commit命令后，如果发生网络抖动，有一部分参与者未收到commit请求，则无法执行事务提交，影响整个系统数据一致性；</li><li>超时导致的同步阻塞问题：2PC中所有参与者节点都是事务阻塞型，当一个节点通信超时，其余参与者都会被阻塞；</li><li>单点故障的风险：整个过程严重依赖协调者，如果协调者故障，参与者处于锁定资源的状态，无法完成事务commit的操作。即使重新选择一个协调者，也无法解决因前一个协调者宕机导致的阻塞问题；</li></ul><p>2PC分布式事务方案，比较适合单体应用跨多库的场景，一般用spring + JTA就可以实现。但是因为严重依赖于数据库层面来搞定复杂的事务，效率很低，所以绝对不适合高并发的场景。虽然是目前分布式事务的事实规范，但实际应用并不多。不过2PC是一种非常经典的思想，Paxos、Raft 等强一致性算法，都采用了二阶段提交操作。</p><hr><h3 id="3PC（三阶段提交）"><a href="#3PC（三阶段提交）" class="headerlink" title="3PC（三阶段提交）"></a>3PC（三阶段提交）</h3><p>为了缓解两段式提交协议的一部分缺陷，具体地说是协调者的单点问题和准备阶段的性能问题，后续又发展出了三段式提交协议(3PC)。3PC是在2PC的基础上，在第一阶段和第二阶段中插入一个准备阶段，把原本的两段式提交的准备阶段再细分为两个阶段：询问阶段(CanCommit)、准备阶段(PreCommit)以及提交阶段(DoCommit)。一方面新增一个 询问阶段（CanCommit），提前确认下各个参与者的状态是否正常，另一方面引入超时机制，解决资源阻塞问题；</p><p><strong>询问阶段：</strong> 事务协调者向事务参与者发送 CanCommit 请求，参与者如果可以提交就返回 Yes 响应，否则返回 No 响应。这样的话，询问阶段就可以确保尽早的发现无法执行操作的参与者节点，提升效率。该阶段参与者也不会取锁定资源。</p><ul><li>事务协调者发送事务询问指令（canCommit），询问事务参与者是否可以提交事务；</li><li>参与者如果可以提交就返回 Yes 响应，否则返回 No 响应，不需要做真正的操作。</li></ul><p>对于事务协调者，如果询问阶段有任一参与者返回NO或超时，则协调者向所有参与者发送 <strong>abort指令</strong>，对于返回NO的参与者，如果在指定时间内无法收到协调者的 <strong>abort指令</strong> ，则自动中止事务。</p><p><strong>准备阶段：</strong> 事务协调者根据事务参与者在询问阶段的响应，判断是执行事务还是中断事务：</p><ul><li>如果询问阶段所有参与者都返回YES，则协调者向参与者们发送 <strong>预执行指令（preCommit）</strong> ，参与者接受到preCommit指令后，写redo和undo日志，执行事务操作，占用资源，但是不会提交事务；</li><li>参与者响应事务操作结果，并等待最终指令： <strong>提交（doCommit）</strong> 或 <strong>中止（abort）</strong> 。</li></ul><p><strong>提交阶段：</strong></p><ul><li>如果每个参与者在准备阶段都返回ACK确认，则协调者向参与者发起 <strong>提交指令（doCommit）</strong> ，参与者收到指令后提交事务，并释放锁定的资源，最后响应ACK；</li><li>如果任意一个参与者在准备阶段返回NO（即执行事务操作失败），或者协调者在指定时间没收到全部的ACK响应，就会发起 <strong>中止（abort）</strong> 指令，参与者取消已经变更的事务，执行undo日志，释放锁定的资源。</li></ul><p>当参与者响应ACK后，即使在指定时间内没收到doCommit指令，也会进行事务的最终提交，一旦进入提交阶段，即使因为网络原因导致参与者无法收到协调者的doCommit或Abort请求，超时时间一过，参与者也会自动完成事务的提交。<br><img src="/images/%E4%BA%8B%E5%8A%A1-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5_3PC%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png"></p><p><strong>优点：</strong></p><ul><li>增加了一个询问阶段，询问阶段可以确保尽早的发现无法执行操作的参与者节点，提升效率；</li><li>在准备阶段成功以后，协调者和参与者执行的任务中都增加了超时，一旦超时，参与者都会继续提交事务，默认为成功，降低了阻塞范围。</li></ul><p><strong>缺点：</strong></p><ul><li>如果准备阶段执行事务后，某些参与者反馈执行事务失败，但是由于出现网络分区，导致这些参与者无法收到协调者的中止请求，那么由于超时机制，这些参与者仍会提交事务，导致出现不一致；</li><li>性能瓶颈，不适合高并发场景。</li></ul><p>三阶段提交协议，虽然针对二阶段提交协议的“协调者故障，参与者长期锁定资源”的痛点，通过引入了询问阶段和超时机制，来减少资源被长时间锁定的情况，但这也会导致集群各节点在正常运行的情况下，使用更多的消息进行协商，增加系统负载和响应延迟。也正是因为这些问题，三阶段提交协议很少被使用。</p><h3 id="TCC-Try-Confirm-Cancel"><a href="#TCC-Try-Confirm-Cancel" class="headerlink" title="TCC(Try-Confirm-Cancel)"></a>TCC(Try-Confirm-Cancel)</h3><p>2007年，Pat Helland 发表了一篇名为<a href="http://adrianmarriott.net/logosroot/papers/LifeBeyondTxns.pdf">《Life beyond Distributed Transactions: an Apostate’s Opinion》</a>的论文，提出了 <strong>TCC（Try-Confirm-Cancel）</strong> 的概念。TCC的核心思想是： <strong>针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作</strong> ，分为三个阶段：</p><ul><li><strong>Try：</strong> 这个阶段对各个服务的资源做检测以及对资源进行锁定或者预留；</li><li><strong>Confirm ：</strong> 执行真正的业务操作，不作任何业务检查，只使用Try阶段预留的业务资源，Confirm操作要求具备幂等设计，Confirm失败后需要进行重试；</li><li><strong>Cancel：</strong> 如果任何一个服务的业务方法执行出错，那么这里就需要进行补偿，即执行回滚操作，释放Try阶段预留的业务资源 ，Cancel操作要求具备幂等设计，Cancel失败后需要进行重试。</li></ul><p><img src="/images/%E4%BA%8B%E5%8A%A1-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5_TCC%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png"></p><p>从实现上来看，TCC仍然是一个两阶段提交协议。只是在执行出现问题的时候，有一定的自我修复能力，如果任何一个事务参与者出现了问题，协调者可以通过执行逆操作来取消之前的操作，达到最终的一致状态。从TCC的执行流程也可以看出，服务提供方需要提供额外的 <strong>补偿逻辑</strong> ，那么原来一个服务接口，引入TCC后可能要改造成3种逻辑：</p><ul><li>Try：先是服务调用链路依次执行Try逻辑；</li><li>Confirm：如果都正常的话，TCC分布式事务框架推进执行Confirm逻辑，完成整个事务；</li><li>Cancel：如果某个服务的Try逻辑有问题，TCC分布式事务框架感知到之后就会推进执行各个服务的Cancel逻辑，撤销之前执行的各种操作。</li></ul><h3 id="可靠消息队列事务"><a href="#可靠消息队列事务" class="headerlink" title="可靠消息队列事务"></a>可靠消息队列事务</h3><p><font color = blue>可靠事件队列（Reliable Event Queue）是一种基于最终一致性的分布式事务解决方案，通过异步事件驱动的方式，结合消息队列的可靠性机制，确保跨服务的事务最终一致。</font> 这个方式避免了像XA协议那样的性能问题。许多开源的消息中间件都支持分布式事务，比如RocketMQ、Kafka，其思想几乎是和本地消息表&#x2F;服务实一样的，只不过是将可靠消息服务和MQ功能封装在一起，屏蔽了底层细节，从而更方便用户的使用。以RocketMQ为例：</p><p><img src="/images/%E4%BA%8B%E5%8A%A1-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E8%B7%B5_RockMq%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1.png"></p><p>RocketMq分布式事务处理流程：</p><ul><li>生产者将消息发送至 RocketMQ 版服务端。</li><li>RocketMQ 服务端将消息持久化成功之后，向生产者返回Ack确认消息已经发送成功，此时消息被标记为“暂不能投递”，这种状态下的消息即为半事务消息。</li><li>生产者开始执行本地事务逻辑。</li><li>生产者根据本地事务执行结果向服务端提交二次确认结果（Commit或是Rollback），服务端收到确认结果后处理逻辑如下：<ul><li>二次确认结果为Commit：服务端将半事务消息标记为可投递，并投递给消费者。</li><li>二次确认结果为Rollback：服务端将回滚事务，不会将半事务消息投递给消费者。</li></ul></li><li>在断网或者是生产者应用重启的特殊情况下，若服务端未收到发送者提交的二次确认结果，或服务端收到的二次确认结果为Unknown未知状态，经过固定时间后，服务端将对消息生产者即生产者集群中任一生产者实例发起消息回查。</li><li>生产者收到消息回查后，需要检查对应消息的本地事务执行的最终结果。</li><li>生产者根据检查到的本地事务的最终状态再次提交二次确认，服务端仍按照步骤4对半事务消息进行处理。</li></ul><p>事务消息生命周期：</p><ul><li>初始化：半事务消息被生产者构建并完成初始化，待发送到服务端的状态。</li><li>事务待提交：半事务消息被发送到服务端，和普通消息不同，并不会直接被服务端持久化，而是会被单独存储到事务存储系统中，等待第二阶段本地事务返回执行结果后再提交。此时消息对下游消费者不可见。</li><li>消息回滚：第二阶段如果事务执行结果明确为回滚，服务端会将半事务消息回滚，该事务消息流程终止。</li><li>提交待消费：第二阶段如果事务执行结果明确为提交，服务端会将半事务消息重新存储到普通存储系统中，此时消息对下游消费者可见，等待被消费者获取并消费。</li><li>消费中：消息被消费者获取，并按照消费者本地的业务逻辑进行处理的过程。此时服务端会等待消费者完成消费并提交消费结果，如果一定时间后没有收到消费者的响应，RocketMQ 会对消息进行重试处理。具体信息，请参见消费重试。</li><li>消费提交：消费者完成消费处理，并向服务端提交消费结果，服务端标记当前消息已经被处理（包括消费成功和失败）。RocketMQ 版默认支持保留所有消息，此时消息数据并不会立即被删除，只是逻辑标记已消费。消息在保存时间到期或存储空间不足被删除前，消费者仍然可以回溯消息重新消费。</li><li>消息删除：RocketMQ 版按照消息保存机制滚动清理最早的消息数据，将消息从物理文件中删除。</li></ul><p>RocketMQ事务消息支持：</p><ul><li>消息类型：事务消息仅支持在MessageType为Transaction的主题使用，即事务消息只能发送至类型为事务消息的主题中。</li><li>消息消费：RocketMQ事务消息保证生产者本地事务和下游消息发送事务的一致性，但不保证消息消费结果和上游事务的一致性。因此需要下游业务自行保证消息正确处理，建议消费端做好消费重试。</li><li>中间状态：RocketMQ事务消息一致性为最终一致性，即在消息提交到下游消费端处理完成之前，下游和上游事务之间的状态会不一致。因此，事务消息仅适合能接受异步执行的场景。</li><li>事务超时：RocketMQ事务消息的生命周期存在超时机制，即半事务消息被生产者发送服务端后，如果在指定时间内服务端无法确认提交或者回滚状态，则消息默认会被回滚。</li></ul><h2 id="基于RocketMQ实现分布式事务"><a href="#基于RocketMQ实现分布式事务" class="headerlink" title="基于RocketMQ实现分布式事务"></a>基于RocketMQ实现分布式事务</h2><p><strong>设计思路：</strong></p><ul><li>泛型抽象：使用 TransactionHandler<T> 来封装具体的本地事务逻辑（例如，创建订单、扣减库存）。</li><li>数据载体：使用 TransactionArg<T> 作为sendMessageInTransaction的arg参数，将事务ID、业务参数和对应的处理器handler粘合在一起。</li><li>统一监听器：实现一个单一、非泛型的TransactionListener。这个监听器不执行任何具体业务，只负责：<ul><li>从arg（即TransactionArg）中解构出handler。</li><li>调用handler.executeLocal(…)来执行具体业务。</li><li>基于TransactionLogEntity进行事务状态的持久化和回查。</li></ul></li></ul><h3 id="核心逻辑实现"><a href="#核心逻辑实现" class="headerlink" title="核心逻辑实现"></a>核心逻辑实现</h3><p>依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.rocketmq<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>rocketmq-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.rocketmq<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>rocketmq-common<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>定义事务参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">record</span> <span class="hljs-title class_">TransactionArg</span>&lt;T&gt;(Long txId, T arg, TransactionHandler&lt;T&gt; handler) &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>定义 TransactionHandler 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 本地事务执行器的顶层接口</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;T&gt; 业务参数类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TransactionHandler</span>&lt;T&gt; &#123;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 执行本地事务</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> arg 业务参数</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@throws</span> Exception 抛出异常表示本地事务执行失败，需要回滚</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">executeLocal</span><span class="hljs-params">(T arg)</span> <span class="hljs-keyword">throws</span> Exception;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 获取此事务的业务类型，用于日志记录</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> 业务类型标识符</span><br><span class="hljs-comment">   */</span><br>  String <span class="hljs-title function_">getBizType</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>RocketMQ 事务监听器(核心)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 统一的分布式事务监听器</span><br><span class="hljs-comment"> * * 实现了 &#x27;TransactionListener&#x27; 接口，用于处理事务消息的两个阶段：</span><br><span class="hljs-comment"> * 1. executeLocalTransaction: 执行本地事务</span><br><span class="hljs-comment"> * 2. checkLocalTransaction: 回查本地事务状态</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component(&quot;distributedTransactionListener&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DistributedTransactionListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TransactionListener</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(DistributedTransactionListener.class);<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_CHECK_RETRIES</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TransactionLogRepository logRepository;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ObjectMapper objectMapper; <span class="hljs-comment">// 用于序列化业务参数</span><br><br>  <span class="hljs-comment">// 通过构造函数注入依赖</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">DistributedTransactionListener</span><span class="hljs-params">(TransactionLogRepository logRepository, ObjectMapper objectMapper)</span> &#123;<br>      <span class="hljs-built_in">this</span>.logRepository = logRepository;<br>      <span class="hljs-built_in">this</span>.objectMapper = objectMapper;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 第一阶段：执行本地事务</span><br><span class="hljs-comment">   * * 当发送方发送 &quot;Half Message&quot; 成功后，Broker会回调此方法。</span><br><span class="hljs-comment">   * * <span class="hljs-doctag">@param</span> msg Half Message 消息</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> arg &#x27;sendMessageInTransaction&#x27; 中传递的 &#x27;arg&#x27; 对象，这里是我们设计的 TransactionArg</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> 本地事务的执行状态</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> LocalTransactionState <span class="hljs-title function_">executeLocalTransaction</span><span class="hljs-params">(Message msg, Object arg)</span> &#123;<br>    <span class="hljs-comment">// 1. 解析参数</span><br>    <span class="hljs-keyword">if</span> (!(arg <span class="hljs-keyword">instanceof</span> TransactionArg&lt;?&gt; txArg)) &#123;<br>      log.error(<span class="hljs-string">&quot;[TX] Invalid argument type. Expected TransactionArg, but got &#123;&#125;&quot;</span>, <br>                (arg != <span class="hljs-literal">null</span> ? arg.getClass().getName() : <span class="hljs-string">&quot;null&quot;</span>));<br>      <span class="hljs-keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;<br>    &#125;<br><br>    <span class="hljs-comment">// 泛型擦除，我们需要手动进行转换，但调用方保证了类型安全</span><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    TransactionArg&lt;Object&gt; genericTxArg = (TransactionArg&lt;Object&gt;) txArg;<br>    <br>    <span class="hljs-type">Long</span> <span class="hljs-variable">bizTxId</span> <span class="hljs-operator">=</span> genericTxArg.txId();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">rocketMqTxId</span> <span class="hljs-operator">=</span> msg.getTransactionId();<br>    <br>    log.info(<span class="hljs-string">&quot;[TX] Executing local transaction. BizTxId: &#123;&#125;, RocketMQTxId: &#123;&#125;&quot;</span>, bizTxId, rocketMqTxId);<br><br>    <span class="hljs-comment">// 2. 创建并保存事务日志 (预处理状态)</span><br>    <span class="hljs-type">TransactionLogEntity</span> <span class="hljs-variable">txLog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionLogEntity</span>();<br>    txLog.setTransId(bizTxId);<br>    txLog.setBizType(genericTxArg.handler().getBizType());<br>    txLog.setPayload(rocketMqTxId); <span class="hljs-comment">// 存储RocketMQ的事务ID，用于反查</span><br>    txLog.setState(TransactionState.UNKNOWN.name()); <span class="hljs-comment">// 初始状态为 UNKNOWN</span><br>    txLog.setRetries(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        txLog.setArgs(objectMapper.writeValueAsString(genericTxArg.arg()));<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        log.error(<span class="hljs-string">&quot;[TX] Failed to serialize transaction args. BizTxId: &#123;&#125;&quot;</span>, bizTxId, e);<br>        txLog.setArgs(<span class="hljs-string">&quot;Serialization Failed&quot;</span>);<br>    &#125;<br>      <br>    <span class="hljs-keyword">try</span> &#123;<br>      logRepository.save(txLog);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception dbError) &#123;<br>      log.error(<span class="hljs-string">&quot;[TX] Failed to save initial transaction log. BizTxId: &#123;&#125;&quot;</span>, bizTxId, dbError);<br>      <span class="hljs-comment">// 连日志库都挂了，无法继续，只能返回 UNKNOWN 等待回查</span><br>      <span class="hljs-keyword">return</span> LocalTransactionState.UNKNOW;<br>    &#125;<br><br>    <span class="hljs-comment">// 3. 执行真正的本地事务</span><br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 调用 TransactionHandler 中定义的本地业务逻辑</span><br>      genericTxArg.handler().executeLocal(genericTxArg.arg());<br><br>      <span class="hljs-comment">// 4. 本地事务成功：更新日志状态为 COMMITTED</span><br>      txLog.setState(TransactionState.COMMITTED.name());<br>      txLog.setUpdateTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>      logRepository.save(txLog);<br>      <br>      log.info(<span class="hljs-string">&quot;[TX] Local transaction committed. BizTxId: &#123;&#125;&quot;</span>, bizTxId);<br>      <span class="hljs-comment">// 返回 COMMIT，Broker 将使消息对消费者可见</span><br>      <span class="hljs-keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;<br><br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>      <span class="hljs-comment">// 5. 本地事务失败：更新日志状态为 ROLLBACK</span><br>      log.error(<span class="hljs-string">&quot;[TX] Local transaction failed, rolling back. BizTxId: &#123;&#125;&quot;</span>, bizTxId, e);<br>      <br>      txLog.setState(TransactionState.ROLLBACK.name());<br>      txLog.setUpdateTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>      logRepository.save(txLog);<br>      <br>      <span class="hljs-comment">// 返回 ROLLBACK，Broker 将删除此消息</span><br>      <span class="hljs-keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;<br>    &#125;<br>      <br>    <span class="hljs-comment">// 注意：如果 executeLocal 成功，但在更新日志为 COMMITTED 时DB又挂了，</span><br>    <span class="hljs-comment">// 日志状态将保持为 UNKNOWN。这没问题，后续的 &#x27;checkLocalTransaction&#x27; 会来处理。</span><br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 第二阶段：回查本地事务状态</span><br><span class="hljs-comment">   * 当 Broker 长时间未收到 &#x27;executeLocalTransaction&#x27; 的响应 (COMMIT/ROLLBACK) 时， (例如</span><br><span class="hljs-comment">   * executeLocalTransaction 返回了 UNKNOW，或者生产者在返回前崩溃) Broker 会回调此方法来 &quot;check&quot; 事务的最终状态。</span><br><span class="hljs-comment">   * * <span class="hljs-doctag">@param</span> msg 消息</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> 本地事务的最终状态</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> LocalTransactionState <span class="hljs-title function_">checkLocalTransaction</span><span class="hljs-params">(MessageExt msg)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">rocketMqTxId</span> <span class="hljs-operator">=</span> msg.getTransactionId();<br>    <span class="hljs-comment">// 在 executeLocalTransaction 时，将 bizTxId 存入了 msg 的属性中</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">bizTxIdStr</span> <span class="hljs-operator">=</span> msg.getProperty(<span class="hljs-string">&quot;BIZ_TX_ID&quot;</span>);<br>    <span class="hljs-keyword">if</span> (bizTxIdStr == <span class="hljs-literal">null</span>) &#123;<br>      logger.warn(<span class="hljs-string">&quot;[TX-Check] &#x27;BIZ_TX_ID&#x27; property not found in message. RocketMQTxId: &#123;&#125;. THIS IS UNUSUAL.&quot;</span>, rocketMqTxId);<br>      <span class="hljs-comment">// 降级：尝试通过 RocketMQ ID 查询 (前提是 executeLocalTransaction 中 payload 存的是 RocketMQ ID)</span><br>      <span class="hljs-comment">// 在我们的设计中，我们使用 bizTxId 作为主查询键，所以这里只能返回 UNKNOWN</span><br>      <span class="hljs-keyword">return</span> LocalTransactionState.UNKNOW;<br>    &#125;<br><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">bizTxId</span> <span class="hljs-operator">=</span> Long.parseLong(bizTxIdStr);<br>    logger.info(<span class="hljs-string">&quot;[TX-Check] Checking local transaction state. BizTxId: &#123;&#125;, RocketMQTxId: &#123;&#125;&quot;</span>,<br>        bizTxId, rocketMqTxId);<br><br>    <span class="hljs-comment">// 1. 根据业务ID查询事务日志</span><br>    Optional&lt;TransactionLogEntity&gt; txLogOpt = logRepository.findByTransId(bizTxId);<br><br>    <span class="hljs-keyword">if</span> (txLogOpt.isEmpty()) &#123;<br>      <span class="hljs-comment">// 极端情况：executeLocalTransaction 连第一条日志都没存进去就挂了</span><br>      logger.warn(<span class="hljs-string">&quot;[TX-Check] Transaction log not found for BizTxId: &#123;&#125;. Assuming ROLLBACK.&quot;</span>,bizTxId);<br>      <span class="hljs-comment">// 理论上应该回滚，因为本地事务很可能没执行</span><br>      <span class="hljs-keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;<br>    &#125;<br><br>    <span class="hljs-type">TransactionLogEntity</span> <span class="hljs-variable">txLog</span> <span class="hljs-operator">=</span> txLogOpt.get();<br>    <span class="hljs-comment">// 2. 根据日志状态返回结果</span><br>    <span class="hljs-type">TransactionState</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> TransactionState.valueOf(txLog.getState());<br>    <span class="hljs-keyword">switch</span> (state) &#123;<br>      <span class="hljs-keyword">case</span> COMMITTED:<br>        logger.info(<span class="hljs-string">&quot;[TX-Check] State is COMMITTED. BizTxId: &#123;&#125;&quot;</span>, bizTxId);<br>        <span class="hljs-keyword">return</span> LocalTransactionState.COMMIT_MESSAGE;<br>      <span class="hljs-keyword">case</span> ROLLBACK:<br>        logger.info(<span class="hljs-string">&quot;[TX-Check] State is ROLLBACK. BizTxId: &#123;&#125;&quot;</span>, bizTxId);<br>        <span class="hljs-keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;<br>      <span class="hljs-keyword">case</span> UNKNOWN:<br>      <span class="hljs-keyword">default</span>:<br>        <span class="hljs-comment">// 状态是 UNKNOWN，意味着 executeLocalTransaction 没执行完，或者执行完了但更新状态失败</span><br>        logger.warn(<span class="hljs-string">&quot;[TX-Check] State is UNKNOWN. BizTxId: &#123;&#125;. Retries: &#123;&#125;&quot;</span>, bizTxId, txLog.getRetries());<br>        <span class="hljs-comment">// 增加重试次数</span><br>        txLog.setRetries(txLog.getRetries() + <span class="hljs-number">1</span>);<br>        logRepository.save(txLog);<br>        <span class="hljs-comment">// 超过最大重试次数，标记为回滚 (或转人工)</span><br>        <span class="hljs-keyword">if</span> (txLog.getRetries() &gt; MAX_CHECK_RETRIES) &#123;<br>          logger.error(<span class="hljs-string">&quot;[TX-Check] Max retries exceeded for BizTxId: &#123;&#125;. Force ROLLBACK.&quot;</span>, bizTxId);<br>          txLog.setState(TransactionState.ROLLBACK.name());<br>          logRepository.save(txLog);<br>          <span class="hljs-keyword">return</span> LocalTransactionState.ROLLBACK_MESSAGE;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 继续返回 UNKNOWN，等待 Broker 下一次回查</span><br>          <span class="hljs-keyword">return</span> LocalTransactionState.UNKNOW;<br>        &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建事务管理，简化业务使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransactionManager</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(TransactionManager.class);<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TransactionMQProducer transactionMQProducer;<br><br>  TransactionManager(TransactionMQProducer transactionMQProducer) &#123;<br>    <span class="hljs-built_in">this</span>.transactionMQProducer = transactionMQProducer;<br>  &#125;<br><br>  <span class="hljs-comment">// 模拟的全局唯一ID生成器 (生产环境应使用Snowflake或Redis)</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">txIdGenerator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(System.currentTimeMillis());<br><br>  <span class="hljs-keyword">public</span> &lt;T&gt; SendResult <span class="hljs-title function_">sendInTransaction</span><span class="hljs-params">(String topic,</span><br><span class="hljs-params">      String tags,</span><br><span class="hljs-params">      String messageBody,</span><br><span class="hljs-params">      TransactionHandler&lt;T&gt; handler,</span><br><span class="hljs-params">      T localTxArg)</span> <span class="hljs-keyword">throws</span> MQClientException &#123;<br><br>    <span class="hljs-comment">// 1. 生成全局唯一的业务事务ID</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">bizTxId</span> <span class="hljs-operator">=</span> txIdGenerator.incrementAndGet();<br><br>    <span class="hljs-comment">// 2. 准备消息</span><br>    <span class="hljs-type">Message</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(topic, tags, messageBody.getBytes(StandardCharsets.UTF_8));<br><br>    <span class="hljs-comment">// 关键：将业务事务ID放入消息属性，这样 &#x27;checkLocalTransaction&#x27; 才能通过 msg.getProperty() 获取到它</span><br>    msg.putUserProperty(<span class="hljs-string">&quot;BIZ_TX_ID&quot;</span>, String.valueOf(bizTxId));<br>    msg.putUserProperty(<span class="hljs-string">&quot;BIZ_TYPE&quot;</span>, handler.getBizType());<br><br>    <span class="hljs-comment">// 3. 准备 &#x27;arg&#x27; 参数，这个 &#x27;arg&#x27; 会被传递给 &#x27;executeLocalTransaction&#x27;</span><br>    TransactionArg&lt;T&gt; transactionArg = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionArg</span>&lt;&gt;(bizTxId, localTxArg, handler);<br><br>    <span class="hljs-comment">// 4. 发送事务消息</span><br>    logger.info(<span class="hljs-string">&quot;[TX-Send] Sending transaction message. BizTxId: &#123;&#125;&quot;</span>, bizTxId);<br><br>    <span class="hljs-comment">// 此方法会：</span><br>    <span class="hljs-comment">// 1. 发送 Half Message</span><br>    <span class="hljs-comment">// 2. (成功后) 立即同步调用 &#x27;executeLocalTransaction&#x27;</span><br>    <span class="hljs-comment">// 3. (根据返回结果) 提交或回滚</span><br>    <span class="hljs-type">SendResult</span> <span class="hljs-variable">sendResult</span> <span class="hljs-operator">=</span> transactionMQProducer.sendMessageInTransaction(msg, transactionArg);<br><br>    logger.info(<span class="hljs-string">&quot;[TX-Send] SendResult: &#123;&#125;. BizTxId: &#123;&#125;&quot;</span>, sendResult.getSendStatus(), bizTxId);<br>    <span class="hljs-keyword">return</span> sendResult;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>创建 CreateOrderTransactionHandler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CreateOrderTransactionHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TransactionHandler</span>&lt;OrderInfo&gt; &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(CreateOrderTransactionHandler.class);<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">executeLocalTransaction</span><span class="hljs-params">(OrderInfo order, Long txId)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    logger.info(<span class="hljs-string">&quot;[Local-TX] 开始执行本地事务：创建订单...&quot;</span>);<br>    logger.info(<span class="hljs-string">&quot;[Local-TX] 正在将订单写入数据库... OrderId: &#123;&#125;&quot;</span>, order.orderId());<br>    <span class="hljs-comment">//todo 写入订单库表</span><br><br>    logger.info(<span class="hljs-string">&quot;[Local-TX] 订单写入数据库成功. OrderId: &#123;&#125;&quot;</span>, order.orderId());<br>    <span class="hljs-comment">// 注意：这里不需要发消息，这里只负责【本地事务】，消息的发送由 TransactionManager负责</span><br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getBizType</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;CREATE_ORDER&quot;</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>OrderSercie 接入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TransactionManager transactionManager;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CreateOrderTransactionHandler createOrderHandler;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 创建订单 (事务性操作)</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">createOrder</span><span class="hljs-params">(String product, <span class="hljs-type">long</span> amount)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 1. 准备业务数据</span><br>    <span class="hljs-type">OrderInfo</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderInfo</span>(UUID.randomUUID().toString().substring(<span class="hljs-number">0</span>, <span class="hljs-number">8</span>),<br>        <span class="hljs-number">1001L</span>,<br>        product,<br>        amount);<br><br>    <span class="hljs-comment">// 2. 定义要发送给下游 (如：积分服务、通知服务) 的消息体，消息体通常只包含ID，让下游反查，以避免数据不一致</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">messageBody</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;\&quot;orderId\&quot;: \&quot;&quot;</span> + order.orderId() + <span class="hljs-string">&quot;\&quot;&#125;&quot;</span>;<br><br>    <span class="hljs-comment">// 3. 调用统一事务管理器</span><br>    <span class="hljs-type">SendResult</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> transactionManagerService.sendInTransaction(<br>        <span class="hljs-string">&quot;TOPIC_ORDER_CREATED&quot;</span>,          <span class="hljs-comment">// 消息主题</span><br>        <span class="hljs-string">&quot;TAG_ORDER&quot;</span>,                    <span class="hljs-comment">// 消息标签</span><br>        messageBody,                    <span class="hljs-comment">// 发送给消费者的消息体</span><br>        createOrderHandler,             <span class="hljs-comment">// 【关键】本地事务处理器</span><br>        order                           <span class="hljs-comment">// 【关键】本地事务需要的参数</span><br>    );<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Order created. OrderId: &quot;</span> + order.orderId() + <span class="hljs-string">&quot;, SendStatus: &quot;</span><br>        + result.getSendStatus();<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>上面基于RocketMQ实现了一个统一的 DistributedTransactionListener，它不关心具体业务，只负责调度 handler 和维护事务日志，具有极高的可扩展性。业务方（如OrderService）只需注入对应的Handler和TransactionManagerService即可发起事务。</p>]]></content>
    
    
    <categories>
      
      <category>事务</category>
      
      <category>分布式</category>
      
      <category>RocketMQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>事务</tag>
      
      <tag>分布式</tag>
      
      <tag>RocketMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>事务基础与原理</title>
    <link href="/2025/07/22/%E4%BA%8B%E5%8A%A1-%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%8E%9F%E7%90%86/"/>
    <url>/2025/07/22/%E4%BA%8B%E5%8A%A1-%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>事务是数据库的一个重要功能，事务就是指对数据进行读写的一系列操作，事务在执行时，会提供专门的属性保证，包括<strong>原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability），也就是 ACID 属性</strong>。这些属性既包括了对事务执行结果的要求，也有对数据库在事务执行前后的数据状态变化的要求。</p><span id="more"></span><ul><li>原子性(Atomicity): 原子性，指的是整个事务要么全部成功，要么全部失败，即一个事务的多个操作必须完成，或者都不完成。</li><li>一致性(Consistency): 事务执行结束后，数据库的完整性约束没有被破坏，事务执行的前后顺序都是合法数据状态。数据库的完整性约束包括但不限于：<ul><li>实体完整性，如行的主键存在且唯一；</li><li>列完整性，如字段的类型、大小、长度要符合要求；</li><li>外键约束；</li><li>用户自定义完整性，如转账前后，两个账户余额的和应该不变。</li></ul></li><li>隔离性(Isolation): 指的是多个事务可以同时对数据进行修改，但是相互不影响，即事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰，讲究的是不同事务之间的相互影响。</li><li>持久性(Durability): 事务一旦提交，所有的修改将永久的保存到数据库中，即使系统崩溃重启后数据也不会丢失。</li></ul><hr><h2 id="mysql事务基础与原理"><a href="#mysql事务基础与原理" class="headerlink" title="mysql事务基础与原理"></a>mysql事务基础与原理</h2><p>MySQL事务是由具体的引擎来实现的，如 InnoDB 引擎它是支持事务的，并不是所有的引擎都能支持事务，比如 MySQL 原生的 MyISAM 引擎就不支持事务，也正是这样，所以大多数 MySQL 的引擎都是用 InnoDB。InnoDB 将事务分为五个状态，分别是：<strong>活动的、部分提交的、失败的、中止的、提交的</strong>。</p><ul><li>活动的：对应开启事务的时候，也就是 START TRANSACTION。</li><li>部分提交的：在Innodb引擎中，当事务开始后，如果我们输入 COMMIT，那么该事务就是部分提交的，这是因为这个提交只是在 Innodb BufferPool中提交了修改，修改的还只是内存中的数据，还没有刷到硬盘，所以我们提交的时候就是部分提交的。</li><li>中止的：执行ROLLBACK后，就是中止的的状态了，也就是回滚修改的时候。</li><li>失败的：应该很少遇到，就是在事务处于活动的或者部分提交的状态，导致内存中的数据没有持久化到硬盘，那这个事务就是失败的。</li></ul><hr><h3 id="Innodb事务基本操作"><a href="#Innodb事务基本操作" class="headerlink" title="Innodb事务基本操作"></a>Innodb事务基本操作</h3><p>在MySQL中，我们可以通过一些简单的命令来操作事务：</p><ul><li>开始一个事务：使用START TRANSACTION语句或BEGIN语句来开始一个事务。事务开始后，MySQL将自动将后续的操作视为一个事务。</li><li>提交一个事务：使用COMMIT语句来提交一个事务。提交操作将永久保存对数据库的更改，并结束当前的事务。</li><li>回滚一个事务：使用ROLLBACK语句来回滚一个事务。回滚操作将取消对数据库的更改，并撤销当前事务中的所有操作。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 开始事务</span><br><span class="hljs-keyword">START</span> TRANSACTION;<br><br><span class="hljs-comment">-- 执行一系列的SQL操作</span><br><span class="hljs-keyword">INSERT INTO</span> table_name (column1, column2) <span class="hljs-keyword">VALUES</span> (value1, value2);<br><span class="hljs-keyword">UPDATE</span> table_name <span class="hljs-keyword">SET</span> column1 <span class="hljs-operator">=</span> value1 <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">condition</span>;<br><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> table_name <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">condition</span>;<br><br><span class="hljs-comment">-- 判断是否满足某些条件</span><br>IF <span class="hljs-keyword">condition</span> <span class="hljs-keyword">THEN</span><br>    <span class="hljs-comment">-- 执行其他操作</span><br>    <span class="hljs-keyword">INSERT INTO</span> table_name (column1, column2) <span class="hljs-keyword">VALUES</span> (value1, value2);<br><span class="hljs-keyword">ELSE</span><br>    <span class="hljs-comment">-- 回滚事务</span><br>    <span class="hljs-keyword">ROLLBACK</span>;<br><span class="hljs-keyword">END</span> IF;<br><br><span class="hljs-comment">-- 提交事务</span><br><span class="hljs-keyword">COMMIT</span>;<br><br></code></pre></td></tr></table></figure><p>MySQL默认使用自动提交模式（Auto-Commit Mode），即每个SQL语句都被视为一个单独的事务并自动提交。如果要使用显式事务控制，需要在执行任何DML操作之前显式地开始一个事务，并在适当的时候选择提交或回滚事务。MySQL允许在一个事务中嵌套其他事务，即在一个事务内部启动另一个事务，嵌套事务的主要目的是在更细粒度的操作中实现事务的管理和控制。嵌套事务可以通过<strong>SAVEPOINT和ROLLBACK TO SAVEPOINT</strong>语句进行控制，保存点是在事务中设置的一个标记，用于标识事务中的一个特定位置，通过设置保存点，可以在事务进行过程中创建一个可以回滚到该点的标记，以便在发生错误或其他情况时进行回滚操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">START</span> TRANSACTION;<br><br><span class="hljs-comment">-- 执行一些操作</span><br><br><span class="hljs-keyword">SAVEPOINT</span> savepoint1;<br><br><span class="hljs-comment">-- 执行更细粒度的操作</span><br><br><span class="hljs-keyword">SAVEPOINT</span> savepoint2;<br><br><span class="hljs-comment">-- 执行更细粒度的操作</span><br><br><span class="hljs-keyword">ROLLBACK</span> <span class="hljs-keyword">TO</span> <span class="hljs-keyword">SAVEPOINT</span> savepoint1;<br><br><span class="hljs-comment">-- 回滚到savepoint1，取消savepoint2后的操作</span><br><br><span class="hljs-keyword">COMMIT</span>;<br></code></pre></td></tr></table></figure><hr><h3 id="mysql事务隔离与并发执行问题"><a href="#mysql事务隔离与并发执行问题" class="headerlink" title="mysql事务隔离与并发执行问题"></a>mysql事务隔离与并发执行问题</h3><p>通常来说，我们的数据库不可能只有一个会话(Session)在执行业务，当有多个Session在同时操作数据库时可能会出现的问题。而事务隔离其实就是为了解决脏读、不可重复读、幻读几个问题。Innodb在不同的隔离级别下可能产生如下并发执行问题：</p><ul><li><strong>脏读(Dirty Read)</strong>：一个事务读取到另一个事务未提交的数据，然后另一个事务回滚了，导致前一个事务读取到了无效的数据。<ul><li><strong>事务A</strong> 开始，修改了一行数据，但尚未提交。</li><li><strong>事务B</strong> 在此时读取了被事务A修改的同一行数据。</li><li><strong>事务A</strong> 之后回滚了修改。</li><li><strong>结果</strong>：事务B读取到的数据是无效的，因为它基于一个最终被撤销的修改。</li></ul></li><li><strong>不可重复读（Non-Repeatable Read）</strong>：在一个事务内部，对同一行数据进行多次读取，却得到了不同的结果。这通常是由于另一个<strong>已提交的事务</strong>在两次读取之间修改了该数据。<ul><li><strong>事务A</strong> 开始，读取了一行数据。</li><li><strong>事务B</strong> 在此时修改了同一行数据，并<strong>提交</strong>了事务。</li><li><strong>事务A</strong> 再次读取同一行数据。</li><li><strong>结果</strong>：事务A前后两次读取的结果不一致。</li></ul></li><li><strong>幻读（Phantom）</strong>：在一个事务内部，多次按照相同的查询条件进行数据查询，但两次查询的结果集（行数）不同。这通常是由于另一个<strong>已提交的事务</strong>在两次查询之间<strong>插入</strong>了新数据。<ul><li><strong>事务A</strong> 开始，按照某个条件进行范围查询，返回一个结果集。</li><li><strong>事务B</strong> 在此时插入了一条符合事务A查询条件的新数据，并<strong>提交</strong>了事务。</li><li><strong>事务A</strong> 再次按照相同的条件进行范围查询。</li><li><strong>结果</strong>：事务A发现查询结果集中多出了一行数据，就像出现了“幻影”一样。</li></ul></li></ul><p>四种事务隔离级别中，只有串行化的隔离级别解决了全部这 3 个问题，其他的 3 个隔离级别都可能产生并发执行问题。mysql可以通过如下命令来设置事务的隔离级别：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-comment">-- 修改当前会话的事务隔离级别</span><br><span class="hljs-keyword">SET</span> SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;<br><br><span class="hljs-comment">-- 修改全局事务隔离级别</span><br><span class="hljs-keyword">SET</span> <span class="hljs-keyword">GLOBAL</span> TRANSACTION ISOLATION LEVEL READ COMMITTED;<br></code></pre></td></tr></table></figure><p>事务的隔离级别决定了多个并发事务之间的可见性和互斥程度，MySQL InnoDB存储引擎实现了SQL标准中的四种事务隔离级别，它们通过锁机制和MVCC的组合来实现，在性能和一致性之间进行权衡，每种级别都有其独特的特性和应用场景：</p><ul><li><p><strong>读未提交(READ UNCOMMITTED)：</strong> 最低的隔离级别，一个事务可以看到其他事务未提交的修改，可能导致<code>脏读（Dirty Read）</code>、<code>不可重复读（Non-repeatable Read）</code>和<code>幻读（Phantom Read）</code>等问题。</p><ul><li>机制<ul><li>不加锁：在这种级别下，SELECT操作不加锁，直接读取最新的记录。</li><li>无Read View：不使用MVCC机制，直接返回记录的最新版本，即使该版本是由未提交的事务写入的。</li></ul></li><li><strong>解决方案：</strong><ul><li>不要使用读未提交隔离级别，除非对数据的一致性和可靠性没有任何要求。</li><li>使用更高的隔离级别，如读已提交、可重复读或者可串行化，来避免脏读、不可重复读或者幻读等问题。</li><li>使用锁机制，如表级锁或者行级锁，来控制对数据的并发访问和修改。</li></ul></li></ul></li><li><p><strong>读已提交(READ COMMITTED)：</strong> 一个事务只能看到其他事务已经提交的修改，可以避免<code>脏读</code>，但是可能导致<code>不可重复读</code>和<code>幻读</code>等问题。</p><ul><li>机制<ul><li>MVCC与Read View：每次SELECT语句执行时都会重新生成一个Read View。</li><li>快照读：SELECT操作通过MVCC机制，读取Read View生成时已提交的最新数据版本。</li><li>阻塞写入：在UPDATE或DELETE等修改操作时，会加排他锁（X锁），阻塞其他事务的修改。</li></ul></li><li><strong>解决方案：</strong><ul><li>使用更高的隔离级别，如可重复读或者可串行化，来避免不可重复读或者幻读等问题</li><li>使用锁机制，如表级锁或者行级锁，来控制对数据的并发访问和修改</li></ul></li></ul></li><li><p><strong>可重复读(REPEATABLE READ):</strong> 一个事务在开始时创建一个数据快照，并且在整个事务期间保持不变，可以避免脏读和不可重复读，但是可能导致<code>幻读</code>等问题。提供了比READ UNCOMMITTED更高的一致性，同时保持较好的并发性能。MySQL的InnoDB在此级别下通过间隙锁解决了幻读问题，这是SQL标准中未强制要求的。可重复读是MySQL InnoDB的默认隔离级别，在保证一致性和性能之间取得了很好的平衡。虽然解决了幻读，但需要注意SELECT … FOR UPDATE和普通SELECT的行为差异（当前读和快照读）。</p><ul><li>机制<ul><li>MVCC与Read View：事务第一次执行快照读时生成一个Read View，此后该事务中的所有快照读都沿用这个固定的Read View。</li><li>间隙锁（Gap Lock）：在对范围进行加锁查询时（如SELECT … FOR UPDATE），除了锁定记录本身，还会锁定记录之间的间隙，阻止其他事务插入新的记录，从而防止幻读。</li><li>版本链：事务通过Undo Log版本链，确保每次读取到的都是事务开始时的数据版本。</li></ul></li><li><strong>解决方案</strong><ul><li>使用更高的隔离级别，如可串行化，来避免幻读等问题</li><li>使用锁机制，如表级锁或者行级锁，来控制对数据的并发访问和修改</li></ul></li></ul></li><li><p><strong>串行化(SERIALIZABLE):</strong> 最高的隔离级别，一个事务在执行期间对其他事务不可见，并且对数据进行加锁，可以避免所有的并发问题，但是并发性能最低。因为读写操作都可能被阻塞，通常只在对数据一致性要求极高且并发度较低的场景中使用。 </p><ul><li>强制加锁：通过强制事务串行执行，将所有SELECT操作都隐式地转换为SELECT … FOR SHARE，即加共享锁（S锁）。</li><li>阻塞读写：当一个事务在读取数据时，其他事务无法修改该数据；反之，当一个事务在修改数据时，其他事务也无法读取该数据。</li></ul></li></ul><p>从上往下，隔离强度逐渐增强，性能逐渐变差。采用哪种隔离级别要根据系统需求权衡决定，其中， <code>可重复读</code> 是 MySQL Innodb 的默认级别。</p><p><strong>事务隔离级别小结</strong></p><table><thead><tr><th align="left">隔离级别</th><th align="left">实现方式</th><th align="left">解决的问题</th><th align="left">存在的并发问题</th></tr></thead><tbody><tr><td align="left">READ UNCOMMITTED</td><td align="left"><strong>无锁</strong>，直接读取最新数据。</td><td align="left">无</td><td align="left">脏读、不可重复读、幻读</td></tr><tr><td align="left">READ COMMITTED</td><td align="left"><strong>MVCC</strong>：每次SELECT生成Read View。</td><td align="left">脏读</td><td align="left">不可重复读、幻读</td></tr><tr><td align="left">REPEATABLE READ</td><td align="left"><strong>MVCC</strong>：事务启动时生成Read View，配合<strong>间隙锁</strong>解决幻读。</td><td align="left">脏读、不可重复读</td><td align="left"><strong>已解决</strong>（在InnoDB中）</td></tr><tr><td align="left">SERIALIZABLE&#96;</td><td align="left"><strong>强行加锁</strong>，所有SELECT都加共享锁。</td><td align="left">所有并发问题</td><td align="left">无</td></tr></tbody></table><hr><h3 id="Mysql-InnoDB引擎事务实现原理"><a href="#Mysql-InnoDB引擎事务实现原理" class="headerlink" title="Mysql InnoDB引擎事务实现原理"></a>Mysql InnoDB引擎事务实现原理</h3><p>InnoDb在事务实现上必然围绕着ACID四个事务特性展开，即如何解决事务的<strong>原子性、一致性、隔离性、持久性</strong>问题。在 InnoDB引擎中通过如下机制实现：</p><ul><li>redo log ：保证事务持久性</li><li>undo log：回滚日志，保证事务原子性</li><li>mvcc与lock: 实现一致性和隔离性</li></ul><hr><h4 id="持久性保证"><a href="#持久性保证" class="headerlink" title="持久性保证"></a><strong>持久性保证</strong></h4><p>事务持久性是由Redo Log来保证的。Redo Log属于InnoDB存储引擎的物理日志，用于保证事务的持久性。它记录了对数据页的物理修改，采用顺序写入的方式，性能较高。它由一组文件组成，通常命名为 ib_logfile*。使用写入方式为循环写入，当文件写满后会回到开头进行覆盖。如果数据库发生崩溃（如断电）时，InnoDB 会在重启后通过重做日志恢复那些已提交但尚未写入磁盘的数据页，确保数据不丢失。Redo Log包括两部分：<strong>一个是内存中的日志缓冲区（Redo Log Buffer），另一个是磁盘上的日志文件（Redo Log File）</strong>。Redo Log的主要作用有两个：</p><ul><li><strong>崩溃恢复</strong>：具备crash-safe能力，提供断电重启时解决事务丢失数据问题。当数据库发生异常崩溃时，可以根据Redo Log恢复数据到最近一次提交的状态。</li><li><strong>提高性能</strong>：先写Redo Log记录更新。当等到有空闲线程、内存不足或Redo Log Buffer满了时刷脏。写Redo Log是顺序写入，刷脏是随机写，节省了随机写磁盘的IO消耗（转成顺序写），所以性能得到提升。这种先写日志，再写磁盘的技术就是WAL（Write-Ahead Logging）技术。</li></ul><p>RedoLog写入过程：RedoLog遵循预写日志（Write-Ahead Logging，WAL）原则，即数据修改先写入日志文件，再写入数据文件。</p><ul><li>写入 redo log buffer：当一个事务执行更新操作时，InnoDB 会首先将 redo log 记录写入内存中的 redo log buffer。由于是内存操作，这一步速度非常快。</li><li>刷新到操作系统的文件缓存：InnoDB 会以一定的频率将 redo log buffer 中的内容刷新到操作系统的文件缓存中。</li><li>刷新到磁盘：操作系统的文件缓存内容最终会通过 fsync() 等系统调用，同步到磁盘上的 redo log file。</li></ul><p>RedoLog刷盘时机</p><ul><li>事务提交时：这是最主要的刷盘时机，由参数 innodb_flush_log_at_trx_commit 控制。</li><li>定期刷新：后台线程（Master Thread）会大约每秒将 redo log buffer 的内容刷新到磁盘。即使没有事务提交，也会定期刷盘，以保障数据的持久性。</li><li>redo log buffer 空间不足：当 redo log buffer 的剩余空间小于一半时，也会触发一次刷盘操作，以腾出空间。</li><li>数据库正常关闭时：关闭 MySQL 服务器时，会把 redo log buffer 的所有内容刷新到磁盘。</li><li>检查点（Checkpoint）：redo log 是循环写入的。当 redo log 文件快写满时，会触发检查点机制，将部分脏页（Buffer Pool 中被修改的数据页）刷新到磁盘，并更新 checkpoint 位置，以便新的 redo log 记录可以覆盖旧的日志。</li></ul><p>RedoLog配置参数：<strong>innodb_flush_log_at_trx_commit</strong></p><ul><li>1（最高持久性，较低性能），每次事务提交时，将 redo log buffer 同步刷新到磁盘。保证事务提交后，redo log 一定在磁盘上，可以最大程度地保障数据安全，即使发生系统崩溃也不会丢失已提交的事务。但频繁的磁盘 I&#x2F;O 导致性能较差，是 MySQL 官方推荐的配置。</li><li>2（中等持久性，较高性能），每次事务提交时，将 redo log buffer 的内容写入操作系统的文件缓存，但不立即刷新到磁盘。操作系统每隔一秒会将文件缓存的内容刷新到磁盘，如果 MySQL 进程崩溃，但操作系统没崩溃，数据不会丢失。如果操作系统崩溃，可能会丢失一秒内的事务数据。</li><li>0（最低持久性，最高性能），不在事务提交时执行任何刷新操作。Master Thread 每秒将 redo log buffer 刷新到磁盘，如果 MySQL 进程或操作系统崩溃，可能丢失最多一秒内的所有事务数据。</li></ul><p>当数据库发生异常崩溃时，会导致内存中的数据页丢失，此时需要根据Redo Log File中的记录进行恢复，恢复的过程是从最近一个检查点开始，扫描Redo Log File中的记录，将已经提交的事务对应的记录重做到数据页上，将未提交的事务对应的记录忽略。这样就可以将数据页恢复到最近一次提交的状态，从而保证持久性。</p><hr><h4 id="原子性保证"><a href="#原子性保证" class="headerlink" title="原子性保证"></a><strong>原子性保证</strong></h4><p>事务的原子性是由Innodb的Undo Log来实现的。Undo Log是 InnoDB 存储引擎特有的逻辑日志，用于保证事务的原子性和实现多版本并发控制（MVCC）。它记录了数据被修改前的信息（before image），以便在事务回滚时恢复数据，Undo Log实现上使用链表记录会形成一个版本链，每一条修改记录都会指向上一条修改记录，最终指向原始数据行。undo log主要作用：</p><ul><li>事务回滚：当事务失败或执行 ROLLBACK 时，利用 undo log 中的信息将数据恢复到修改前的状态。</li><li>MVCC：在并发操作中，通过 undo log 记录的旧版本数据，确保事务可以读取到一致性的数据。</li></ul><p>Undo Log的工作原理如下：</p><ul><li>当InnoDB执行一条DML语句时（比如INSERT、UPDATE、DELETE），首先会将该语句对应的逆向操作记录写入Undo Log中。Undo Log是存储在回滚段（Rollback Segment）中的，回滚段是InnoDB存储引擎的一个特殊区域，它包含了多个回滚段槽（Rollback Slot），每个回滚段槽又包含了多个回滚指针（Roll Pointer），每个回滚指针指向一个Undo Log。</li><li>当事务需要回滚时（比如执行ROLLBACK语句或者发生异常错误），会根据Undo Log中的记录逐条执行逆向操作，将数据页恢复到事务之前的状态。</li><li>当事务提交时或者达到清理时机，会将Undo Log中的记录标记为可清理，并释放占用的空间。清理时机有两种：<ul><li>当事务提交后，如果该事务没有影响其他事务的MVCC视图，则可以立即清理；</li><li>当事务提交后，如果该事务影响了其他事务的MVCC视图，则需要等待所有依赖该事务的MVCC视图消失后才能清理。</li></ul></li><li>当数据库发生异常崩溃时，会导致部分未提交或未清理的Undo Log残留在回滚段中，此时需要根据Redo Log File中的记录进行恢复。恢复的过程是从最近一个检查点开始，扫描Redo Log File中的记录，将已经提交但未清理的Undo Log标记为可清理，并释放占用的空间；将未提交但已写入Undo Log的事务回滚，并释放占用的空间。</li></ul><hr><h4 id="一致性保证"><a href="#一致性保证" class="headerlink" title="一致性保证"></a><strong>一致性保证</strong></h4><p>事务的一致性保证是通过MVCC来实现的，在 REPEATABLE READ 或 READ COMMITTED 隔离级别下，当一个事务正在修改数据，而另一个事务要读取相同的数据时，InnoDB 会根据 Undo Log版本链找到该数据行的旧版本，提供一个一致性的读视图，避免了脏读和幻读。</p><p>MVCC(Multi-Version Concurrency Control)是一种用于数据库系统（如MySQL的InnoDB引擎）的并发控制技术，其核心思想是在不加锁的情况下实现对数据的一致性读。它通过保存数据在某个时间点的快照，使得不同事务可以同时读写数据，从而提高数据库的并发性能。InnoDB的MVCC主要依赖以下三个核心组件来实现： </p><ul><li>隐藏字段：每行数据都包含几个隐藏字段，用于记录事务信息和版本。</li><li>Undo Log（回滚日志）：记录了数据行的历史版本，用于事务回滚和MVCC的快照读。</li><li>Read View（读视图）：一个由活跃事务ID组成的列表，用于判断当前事务所能看到的数据版本。</li></ul><p><font color=green>当一个事务修改一行数据时，InnoDB会在Undo Log中创建一个该行数据的旧版本快照，并将DB_ROLL_PTR指向这个新生成的Undo Log记录。每一次对数据的修改，都会在Undo Log中生成一个新的版本，并形成一条由DB_ROLL_PTR串起来的版本链。通过版本链，可以追溯到该数据行在不同时间点的所有历史版本。</font></p><p>MVCC的工作流程：当一个事务执行快照读（SELECT语句）时，会触发以下步骤： </p><ul><li>创建Read View：如果当前事务是第一次执行快照读，InnoDB会生成一个Read View。</li><li>遍历版本链：InnoDB会从最新版本的数据开始，通过DB_ROLL_PTR遍历Undo Log中的版本链。</li><li>可见性判断：对于版本链中的每个版本，InnoDB会根据DB_TRX_ID（该版本记录的修改事务ID）和Read View中的信息进行可见性判断。<ul><li>如果DB_TRX_ID小于min_trx_id，则表示该版本在当前事务启动前就已经提交，可见。</li><li>如果DB_TRX_ID大于max_trx_id，则表示该版本是在当前事务启动后才开始的，不可见。</li><li>如果DB_TRX_ID在min_trx_id和max_trx_id之间：</li><li>若DB_TRX_ID在m_ids列表中，则说明该版本是由一个活跃的事务修改的，不可见。</li><li>若DB_TRX_ID不在m_ids列表中，则说明该版本是由一个已提交的事务修改的，可见。</li></ul></li><li>返回结果：InnoDB会一直遍历版本链，直到找到第一个可见的版本，然后返回该版本的数据。如果遍历完整个版本链都没有找到可见版本，说明该行数据对当前事务是不可见的。</li></ul><p>MVCC机制巧妙地实现了读写操作的分离：<font color=red>快照读（SELECT）不加锁，直接利用版本链获取历史数据，从而不会阻塞任何写操作；而当前读（SELECT … FOR UPDATE、UPDATE、DELETE等）则会加锁，以确保数据更新的一致性。这种设计极大地提高了并发性能。</font></p><hr><h4 id="隔离性保证"><a href="#隔离性保证" class="headerlink" title="隔离性保证"></a><strong>隔离性保证</strong></h4><p>隔离性确保了多个并发事务在操作时互不干扰，InnoDB 通过锁和多版本并发控制（MVCC）来实现。</p><ul><li>锁机制：<ul><li>共享锁（S锁）和排他锁（X锁）：InnoDB 提供行级锁，允许多个事务共享读锁，但排他写锁只能被一个事务持有。</li><li>意向锁：为了支持多粒度锁，InnoDB 引入了意向锁，帮助快速判断是否可以对表进行加锁。</li><li>间隙锁：在 REPEATABLE READ 隔离级别下，InnoDB 使用间隙锁来锁定索引记录之间的范围，从而防止幻读。</li></ul></li><li>多版本并发控制（MVCC）：<ul><li>快照读：在 REPEATABLE READ 和 READ COMMITTED 隔离级别下，普通的 SELECT 语句采用快照读，它不会加锁，而是通过 Undo Log 构建出数据在某个时间点的快照，提供一致性的读取。</li><li>当前读：SELECT … FOR UPDATE、SELECT … FOR SHARE、UPDATE、DELETE 等语句，会读取最新的数据并加锁，以保证数据的一致性。</li></ul></li></ul><hr><h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><p>Redis 事务是一组命令的集合，这些命令会被作为一个整体执行，是 Redis 的最小执行单位，它可以保证一次执行多个命令，每个事务是一个单独的隔离操作，事务中的所有命令都会序列化、按顺序地执行。服务端在执行事务的过程中，不会被其他客户端发送来的命令请求打断。</p><p>Redis事务的在实现上是基于命令队列、单线程模型和乐观锁机制，核心通过MULTI、EXEC、WATCH等命令组合完成：</p><ul><li>MULTI：标记事务的开始，后续的所有命令将被放入一个队列中，而不是立即执行。</li><li>EXEC：提交事务，按顺序执行队列中的所有命令，并返回每个命令的执行结果。</li><li>DISCARD：取消事务，清空事务队列中的所有命令。</li><li>WATCH：监控一个或多个键，如果在事务执行前这些键被其他客户端修改，则事务会被中断。</li><li>UNWATCH：取消对所有键的监控。</li></ul><p>Redis 事务的执行过程包含三个步骤：</p><ul><li><p><strong>开启事务：</strong> 执行MULTI命令后，服务器会将该客户端的状态更改为事务状态，后续命令不再立即执行，而是暂存到事务队列中。在此状态下，客户端发送的所有命令（除了 EXEC, DISCARD, WATCH, SUBSCRIBE 等少数命令）都不会立即执行，而是被暂存到一个事务队列（transaction queue）中。提交命令后，服务器会向客户端返回 QUEUED 表示命令已入队。</p></li><li><p><strong>执行事务或丢弃：</strong> 客户端向服务端发送提交或者丢弃事务的命令，让 Redis 执行第二步中发送的具体指令或者清空队列命令，放弃执行。</p><ul><li>EXEC: 当客户端发送 EXEC 命令时，Redis服务器会遍历并执行事务队列中的所有命令，并将每个命令的执行结果按顺序组成一个列表返回给客户端。在整个执行过程中，Redis服务器不会中断去处理其他客户端的命令，从而保证了原子性（从并发角度看）。</li><li>DISCARD: 当客户端发送 DISCARD 命令时，服务器会清空事务队列，并将客户端状态恢复为非事务状态。</li></ul></li><li><p><strong>乐观锁控制（WATCH 命令）</strong>：WATCH 机制实现了乐观锁。客户端在 MULTI 之前使用 WATCH 监视一个或多个键。被监视的键会被记录在一个特定的字典中，每个键都关联一个监视该键的客户端列表。在 EXEC 执行前，Redis会检查被监视的键自 WATCH 以来是否被其他客户端修改过。如果任何一个被监视的键发生了变化，整个事务将被取消执行，EXEC 命令会返回一个特殊的响应（通常是 nil），通知客户端重试事务。</p></li></ul><hr><h3 id="Redis事务示例"><a href="#Redis事务示例" class="headerlink" title="Redis事务示例:"></a>Redis事务示例:</h3><ul><li>正常使用事务: 通过 MULTI 和 EXEC 执行一个事务过程</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs redis">MULTI<br>set a 10<br>set b 20<br>EXEC<br></code></pre></td></tr></table></figure><p>每个读写指令执行后的返回结果都是 QUEUED，表示操作都被暂存到了命令队列，但还没有实际执行，当执行了 EXEC 命令，就可以看到具体每个指令的响应数据。</p><ul><li>异常事务: 通过 MULTI 和 DISCARD丢弃队列命令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs redis">set a 5<br>MULTI<br>set a 10<br>set a 20<br>DISCARD<br></code></pre></td></tr></table></figure><hr><h3 id="Redis事务对ACID支持分析"><a href="#Redis事务对ACID支持分析" class="headerlink" title="Redis事务对ACID支持分析"></a>Redis事务对ACID支持分析</h3><p>Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：</p><ul><li>批量指令在执行 EXEC 命令之前会放入队列暂存；</li><li>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行；</li><li>事务执行过程中，其他客户端提交的命令不会插入到当前命令执行的序列中。</li></ul><p>在事务期间，可能遇到三种命令错误：</p><ul><li>在执行 <code>EXEC</code> 命令前，发送的指令本身就错误。如下：<ul><li>参数数量错误；</li><li>命令名称错误，使用了不存在的命令；</li><li>内存不足（Redis 实例使用 <code>maxmemory</code>指令配置内存限制）。</li></ul></li><li>在执行 <code>EXEC</code> 命令后，命令可能会失败。例如，命令和操作的数据类型不匹配（对 String 类型 的 value 执行了 List 列表操作）；</li><li>在执行事务的 <code>EXEC</code> 命令时。Redis 实例发生了故障导致事务执行失败。</li></ul><hr><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a><strong>原子性</strong></h4><p>执行EXEC前错误：在命令入队时，Redis 就会报错并且记录下这个错误。此时，我们还能继续提交命令操作。等到执行了 EXEC命令之后，Redis 就会拒绝执行所有提交的命令操作，返回事务失败的结果。这样一来，事务中的所有命令都不会再被执行了，可以保证原子性。</p><p>执行EXEC后错误：某个命令在事务执行期间出现错误，如命令和操作的数据类型不匹配，在操作入队时没有被 Redis 实例检查出错误。这时尽管 Redis 会对单个命令报错，但还是会把这个事务接所有正确的命令执行完，这时候事务的原子性就无法保证。Redis 没有提供回滚机制，虽然 Redis 提供了 DISCARD 命令，但是这个命令只能用来主动放弃事务执行，把暂存的命令队列清空，起不到回滚的效果。<br>执行EXEC时错误：事务执行期间 Redis 实例发生了故障，导致事务执行失败，这种情况下，如果Redis开启了AOF日志，那么，只会有部分的事务操作被记录到AOF日志中，只有手动使用redis-check-aof工具清除未完成事务，使用AOF恢复实例后，事务操作不会再被执行，可以保证了原子性。如果AOF日志并没有开启，那么实例重启后，数据也都没法恢复了，此时，也就谈不上原子性了。</p><hr><h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a><strong>一致性</strong></h4><ul><li>命令入队时就报错。在这种情况下，事务本身就会被放弃执行，所以可以保证数据库的一致性。</li><li>命令入队时没报错，实际执行时报错。在这种情况下，有错误的命令不会被执行，正确的命令可以正常执行，也不会改变数据库的一致性。</li><li>EXEC 命令执行时实例发生故障。在这种情况下，实例故障后会进行重启，这就和数据恢复的方式有关了。<ul><li>若没有开启 RDB 或 AOF 日志：那实例故障重启后，数据都没有了，数据库是一致的。</li><li>若使用了 RDB 快照：因为RDB快照不会在事务执行时执行，所以，事务命令操作的结果不会被保存到 RDB 快照中，使用 RDB 快照进行恢复时，数据库里的数据也是一致的。</li><li>若使用了 AOF 日志：如果事务操作还没有被记录到AOF日志时，实例就发生了故障，那么，使用AOF日志恢复的数据库数据是一致的。如果只有部分操作被记录到了AOF日志，我们可以使用redis-check-aof清除事务中已经完成的操作，数据库恢复后也是一致的。</li></ul></li></ul><p>所以，总结来说，在命令执行错误或 Redis 发生故障的情况下，Redis 事务机制对一致性属性是有保证的。</p><hr><h4 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a><strong>隔离性</strong></h4><p>事务的隔离性保证，会受到和事务一起执行的并发操作的影响。而事务执行又可以分成命令入队（EXEC 命令执行前）和命令实际执行（EXEC 命令执行后）两个阶段，所以，我们就针对这两个阶段，分成两种情况来分析：</p><ul><li><p>并发操作在 EXEC 命令前执行，此时，隔离性的保证要使用 WATCH 机制来实现，否则隔离性无法保证；一个事务的 EXEC 命令还没有执行时，事务的命令操作是暂存在命令队列中的。此时，如果有其它的并发操作，我们就需要看事务是否使用了 WATCH 机制。WATCH 机制的作用是，在事务执行前，监控一个或多个键的值变化情况，当事务调用 EXEC 命令执行时，WATCH 机制会先检查监控的键是否被其它客户端修改了。如果修改了，就放弃事务执行，避免事务的隔离性被破坏。然后，客户端可以再次执行事务，此时，如果没有并发修改事务数据的操作了，事务就能正常执行，隔离性也得到了保证。</p></li><li><p>并发操作在 EXEC 命令后执行，此时，隔离性可以保证。因为Redis是用单线程执行命令，EXEC 命令执行后，Redis 会保证先把命令队列中的所有命令执行完，在这种情况下，并发操作不会破坏事务的隔离性。</p></li></ul><hr><h4 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a><strong>持久性</strong></h4><p>因为 Redis 是内存数据库，所以，数据是否持久化保存完全取决于 Redis 的持久化配置模式。如果Redis没有使用RDB或AOF，那么事务的持久化属性肯定得不到保证。如果Redis使用了RDB模式，那么，在一个事务执行后，而下一次的RDB快照还未执行前，如果发生了实例宕机，这种情况下，事务修改的数据也是不能保证持久化的。如果Redis采用了AOF模式，因为AOF模式的三种配置选项no、everysec和always都会存在数据丢失的情况，所以，事务的持久性属性也还是得不到保证。不管 Redis 采用什么持久化模式，事务的持久性属性是得不到保证的。</p><hr><h3 id="Redis事务总结"><a href="#Redis事务总结" class="headerlink" title="Redis事务总结"></a>Redis事务总结</h3><p>总结来说，Redis事务通过命令入队、单线程顺序执行和 <strong>乐观锁（WATCH）</strong> 机制，提供了一种高效且简单的事务处理方式，但它并不提供完全的回滚支持，需要自行处理运行时错误。Redis事务不具备完整的ACID的支持：</p><ul><li>Redis 具备了一定的原子性，但不支持回滚。</li><li>Redis 具备 ACID 中一致性的概念</li><li>Redis 具备隔离性。</li><li>Redis 无法保证持久性。</li></ul>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
      <category>事务</category>
      
      <category>redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
      <tag>redis</tag>
      
      <tag>事务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Distuptor核心原理分析</title>
    <link href="/2025/07/21/java-juc-DIsruptor%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <url>/2025/07/21/java-juc-DIsruptor%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p> Disruptor是LMAX公司开发的一个高性能的有界内存队列，其目的是为了解决内存队列的延迟问题。目前应用非常广泛，Log4j2、Spring Messaging、HBase、Storm等都有使用到Disruptor。Disruptor项目团队的一篇论文，其高性能总结如下：</p><span id="more"></span><ul><li><strong>高效数据结构—环形缓冲区（RingBuffer）</strong>：环形缓冲区（Ring Buffer）是一个预先分配好内存空间的固定大小的数组，数组元素在初始化时一次性全部创建。使用数组而非链表结构，是为了避免频繁创建和销毁节点带来的垃圾回收（GC）开销，从而降低延迟。并且数组在内存中是连续存放的，这对 CPU 的缓存机制（缓存行）非常友好，可以提高数据访问效率。环形缓冲区定义大小必须是 2 的 N 次幂，这样做的好处是可以通过位运算（index &amp; (bufferSize - 1)）快速定位数组下标，省去了昂贵的取模运算。</li><li><strong>并发控制—无锁设计（Sequencer 和 Sequence Barrier）</strong>：Disruptor 采用无锁或极少锁的设计来管理并发访问，替代传统的锁和阻塞队列机制。 生产者和消费者都维护一个独立的序列号，表示当前处理到的位置。通过比较序列号来判断是否有新的事件可用或是否有足够的空间写入。序列栅栏（Sequence Barrier）负责协调生产者和消费者之间的序列号，确保消费者不会读取到尚未写入的事件，生产者也不会覆盖尚未消费的事件。在多生产者场景下，使用 Compare-And-Swap (CAS) 原子操作来竞争下一个可写的序列号，避免使用重量级锁。 </li><li><strong>性能优化—消除伪共享（Padding）</strong>：为了进一步优化性能，Disruptor 使用 <strong>缓存行填充（Cache Line Padding）</strong> 技术来消除伪共享（False Sharing）问题。 伪共享是当多个线程操作不同但位于同一个 CPU 缓存行的数据时，会导致缓存行的频繁失效和同步，降低性能。Disruptor 在关键变量（如序列号）前后填充额外的字节，确保它们位于独立的缓存行中，从而避免不必要的缓存同步。 </li><li><strong>事件处理—预分配与等待策略</strong>：<ul><li>缓冲区中的“事件”（Event，即数据对象）是预先创建好的普通 Java 对象。生产者只需更新对象的内容，而不需要在每次生产数据时都创建新对象，进一步减少 GC 开销。</li><li>消费者可以通过不同的等待策略来决定如何等待新事件的到来（例如，忙等待、带超时等待、阻塞等待等），以平衡 CPU 利用率和延迟。</li></ul></li></ul><p>总之：Disruptor 在实现上通过结合<strong>环形数组、无锁并发控制（序列号和 CAS）、缓存行优化和内存预分配</strong>等多种底层技术，构建了一个高效的生产者-消费者框架，能够在线程间数据交换时提供远超传统阻塞队列的性能。</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src="/images/java-juc-DIsruptor%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90_Disruptor%E6%9E%B6%E6%9E%84.png"></p><p>Disruptor 框架主要由以下几个核心组件构成，它们共同协作实现了高效的线程间数据交换。</p><ul><li>Ring Buffer（环形缓冲区）：环形缓冲区通常被视为 Disruptor 的核心组件。</li><li>Sequencer：（序号管理器）。序列器是 Disruptor 的核心部分。这个接口有两个实现（单生产者和多生产者），它实现了所有并发算法，用于在生产者和消费者之间快速、正确地传递数据。</li><li>Sequence（序列）：Disruptor 使用序列（Sequence）来标识某个特定组件的进度。每个消费者（事件处理器）以及 Disruptor 本身都会维护一个序列。主要是为了解决并发冲突，disruptor里面大部分的并发代码都是通过对Sequence的值同步修改实现的，而非锁，类似于AtomicLong，但是解决了伪共享问题，这是disruptor高性能的一个主要原因。</li><li>SequenceBarrier（序号栅栏）：，管理和协调生产者的游标序号和各个消费者的序号，确保生产者不会覆盖消费者未来得及处理的消息，确保存在依赖的消费者之间能够按照正确的顺序处理。</li><li>EventProcessor（事件处理器）：监听RingBuffer的事件，并消费可用事件，从RingBuffer读取的事件会交由实际的生产者实现类来消费；它会一直侦听下一个可用的序号，直到该序号对应的事件已经准备好。</li><li>EventHandler（业务处理器）：是实际消费者的接口，完成具体的业务逻辑实现，第三方实现该接口；代表着消费者。</li><li>Producer：生产者接口，第三方线程充当该角色，producer向RingBuffer写入事件。</li><li>Wait Strategy：等待策略，Wait Strategy决定了一个消费者怎么等待生产者将事件（Event）放入Disruptor中。常用的三个：<ul><li><strong>BlockingWaitStrategy（常用）</strong>：使用ReentrantLock，失败则进入等待队列等待唤醒重试。当吞吐量和低延迟不如CPU资源重要时使用。</li><li><strong>YieldingWaitStrategy（常用）</strong>：尝试100次，全失败后调用Thread.yield()让出CPU。该策略将使用100%的CPU，如果其他线程请求CPU资源，这种策略更容易让出CPU资源。</li><li><strong>SleepingWaitStrategy（常用）</strong>：尝试200次 。前100次直接重试，后100次每次失败后调用Thread.yield()让出CPU，全失败线程睡眠（默认100纳秒 ）。</li></ul></li></ul><p><strong>说明</strong>：</p><ul><li>生产者（producer）向RingBuffer中加入事件，生产方只维护一个代表生产的最后一个元素的序号。代表生产的最后一个元素的序号。每次向Disruptor发布一个元素都调用Sequenced.next()来获取下个位置的写入权。。</li><li>消费者（EventHandler）从RingBuffer中读取事件，但是读取之前会通过 SequenceBarrier 检查事件是否准备好，如果事件已准备好，消费者调用 get() 方法从 RingBuffer 中读取事件，并通过自己的 Sequence 更新处理进度</li><li>SequenceBarrier，引用 Sequencer 的实例来跟踪生产者的序列号，检查事件是否已经发布（根据序列号），判断消费者是否可以安全地读取事件，假如消费者的序列号对应的事件还没有生产者生产出来，那么SequenceBarrier就会执行等待策略WaitStrategy。</li><li>消费者之间可以有依赖关系。例如：JournalConsumer 完成后， ReplicationConsumer 才能处理事件，ApplicationConsumer 可能依赖于前两个消费者的结果。这种依赖关系通过 SequenceBarrier 和 Sequence 协调。</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>Event 是具体的数据实体，生产者生产 Event ，存入 RingBuffer，消费者从 RingBuffer 中消费它进行逻辑处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TaskEvent</span>&lt;T&gt; &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> taskId;<br>  <span class="hljs-comment">// 具体的业务数据</span><br>  <span class="hljs-keyword">private</span> T payload;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicBoolean</span> <span class="hljs-variable">processed</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicBoolean</span>(<span class="hljs-literal">false</span>);<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">TaskEvent</span><span class="hljs-params">()</span> &#123;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">TaskEvent</span><span class="hljs-params">(<span class="hljs-type">long</span> taskId, T payload)</span> &#123;<br>    <span class="hljs-built_in">this</span>.taskId = taskId;<br>    <span class="hljs-built_in">this</span>.payload = payload;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">setProcessed</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> processed.compareAndSet(<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">getProcessed</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> processed.get();<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getTaskId</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> taskId;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setTaskId</span><span class="hljs-params">(<span class="hljs-type">long</span> taskId)</span> &#123;<br>    <span class="hljs-built_in">this</span>.taskId = taskId;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getPayload</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> payload;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPayload</span><span class="hljs-params">(T payload)</span> &#123;<br>    <span class="hljs-built_in">this</span>.payload = payload;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义EventFactory用于创建Event对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TaskEventFactory</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">EventFactory</span>&lt;TaskEvent&lt;T&gt;&gt; &#123;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> TaskEvent&lt;T&gt; <span class="hljs-title function_">newInstance</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TaskEvent</span>&lt;&gt;();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义生产者：生成者主要是持有 RingBuffer 对象进行数据的发布。在 RingBuffer 初始化时该 Object 数组就已经使用 EventFactory 初始化了一些空 Event，后续就不需要在运行时来创建了，提高性能。因此这里通过 RingBuffer 获取指定序号得到的是一个空对象，需要对它进行赋值后，才能进行发布。通过 RingBuffer 的 next 方法获取可用序号，如果 RingBuffer 空间不足会阻塞。通过 next 方法获取序号后，需要确保接下来使用 publish 方法发布数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TaskProducer</span>&lt;T&gt; &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RingBuffer&lt;TaskEvent&lt;T&gt;&gt; ringBuffer;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">TaskProducer</span><span class="hljs-params">(DisruptorQueue&lt;T&gt; queue)</span> &#123;<br>    Disruptor&lt;TaskEvent&lt;T&gt;&gt; disruptor = queue.getDisruptor();<br>    <span class="hljs-built_in">this</span>.ringBuffer = disruptor.getRingBuffer();<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(TaskEvent&lt;T&gt; event)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">sequence</span> <span class="hljs-operator">=</span> ringBuffer.next();<br>    <span class="hljs-keyword">try</span> &#123;<br>      TaskEvent&lt;T&gt; taskEvent = ringBuffer.get(sequence);<br>      taskEvent.setTaskId(event.getTaskId());<br>      taskEvent.setPayload(event.getPayload());<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      ringBuffer.publish(sequence);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义消费者：消费者可以实现 EventHandler 接口，定义自己的处理逻辑。这里是一个抽象类，简化代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractTaskConsumer</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">EventHandler</span>&lt;TaskEvent&lt;T&gt;&gt; &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(AbstractTaskConsumer.class);<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onEvent</span><span class="hljs-params">(TaskEvent&lt;T&gt; event, <span class="hljs-type">long</span> sequence, <span class="hljs-type">boolean</span> endOfBatch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">if</span> (event.markAsProcessed()) &#123;<br>      logger.info(<span class="hljs-string">&quot;consumer sequence: &#123;&#125;&quot;</span>, sequence);<br>      <span class="hljs-keyword">try</span> &#123;<br>        bizHandler(event);<br>      &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">throw</span> e;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bizHandler</span><span class="hljs-params">(TaskEvent&lt;T&gt; event)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>封装Disruptor，简化初始化过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DisruptorQueue</span>&lt;T&gt; &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Integer</span> <span class="hljs-variable">DEFAULT_BUFFER_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">4096</span> &lt;&lt; <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Disruptor&lt;TaskEvent&lt;T&gt;&gt; disruptor;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">DisruptorQueue</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>(DEFAULT_BUFFER_SIZE);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">DisruptorQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> bufferSize)</span> &#123;<br>    <span class="hljs-built_in">this</span>(bufferSize, ProducerType.SINGLE, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BlockingWaitStrategy</span>(),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultThreadFactory</span>(<span class="hljs-string">&quot;default-disruptor&quot;</span>));<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">DisruptorQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> bufferSize, ThreadFactory threadFactory)</span> &#123;<br>    <span class="hljs-built_in">this</span>(bufferSize, ProducerType.SINGLE, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BlockingWaitStrategy</span>(), threadFactory);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">DisruptorQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> bufferSize, ProducerType producerType, WaitStrategy waitStrategy,</span><br><span class="hljs-params">      ThreadFactory threadFactory)</span> &#123;<br><br>    <span class="hljs-built_in">this</span>.disruptor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Disruptor</span>&lt;&gt;(<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">TaskEventFactory</span>&lt;&gt;(),<br>        bufferSize,<br>        threadFactory,<br>        producerType,<br>        waitStrategy);<br>  &#125;<br><br>  <span class="hljs-meta">@SafeVarargs</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">(AbstractTaskConsumer&lt;T&gt;... consumer)</span> &#123;<br>    disruptor.handleEventsWith(consumer);<br>    disruptor.start();<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> Disruptor&lt;TaskEvent&lt;T&gt;&gt; <span class="hljs-title function_">getDisruptor</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.disruptor;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> TimeoutException &#123;<br>    disruptor.shutdown(<span class="hljs-number">5</span>, TimeUnit.SECONDS);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码实现的一个通用的业务处理逻辑，下面的具体的业务使用：<br>具体的业务BizTaskConsumer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BizTaskConsumer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractTaskConsumer</span>&lt;User&gt; &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(BizTaskConsumer.class);<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bizHandler</span><span class="hljs-params">(TaskEvent&lt;User&gt; event)</span> &#123;<br>    logger.info(<span class="hljs-string">&quot;biz consumer, taskId: &#123;&#125;, payload: &#123;&#125;&quot;</span>, event.getTaskId(), event.getPayload());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>  DisruptorQueue&lt;User&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DisruptorQueue</span>&lt;&gt;();<br><br>  BizTaskConsumer[] consumers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BizTaskConsumer</span>[<span class="hljs-number">4</span>];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>    consumers[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BizTaskConsumer</span>();<br>  &#125;<br>  queue.start(consumers);<br><br>  TaskProducer&lt;User&gt; producer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TaskProducer</span>&lt;&gt;(queue);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10L</span>; i++) &#123;<br>    MDC.put(<span class="hljs-string">&quot;traceId&quot;</span>, String.valueOf(i));<br>    logger.info(<span class="hljs-string">&quot;id: &#123;&#125;&quot;</span>, i);<br>    TaskEvent&lt;User&gt; taskEvent = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TaskEvent</span>&lt;&gt;();<br>    taskEvent.setTaskId(Instant.now().toEpochMilli());<br>    taskEvent.setPayload(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(i, <span class="hljs-string">&quot;ares&quot;</span>));<br>    producer.push(taskEvent);<br>  &#125;<br><br>  queue.shutdown();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="核心源码分析"><a href="#核心源码分析" class="headerlink" title="核心源码分析"></a>核心源码分析</h2><h3 id="成员变量："><a href="#成员变量：" class="headerlink" title="成员变量："></a>成员变量：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Disruptor</span>&lt;T&gt;<br>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RingBuffer&lt;T&gt; ringBuffer;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadFactory threadFactory;<br>  ......<br>&#125;<br></code></pre></td></tr></table></figure><p>这里着重看下 RingBuffer：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RingBufferFields</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RingBufferPad</span><br>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> indexMask;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> E[] entries;<br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> bufferSize;<br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Sequencer sequencer;<br>&#125;<br></code></pre></td></tr></table></figure><p>E[] entries：为RingBuffer的存储数组。</p><h3 id="Disruptor创建"><a href="#Disruptor创建" class="headerlink" title="Disruptor创建"></a>Disruptor创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Disruptor</span><span class="hljs-params">(</span><br><span class="hljs-params">  <span class="hljs-keyword">final</span> EventFactory&lt;T&gt; eventFactory,</span><br><span class="hljs-params">  <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> ringBufferSize,</span><br><span class="hljs-params">  <span class="hljs-keyword">final</span> Executor executor,</span><br><span class="hljs-params">  <span class="hljs-keyword">final</span> ProducerType producerType,</span><br><span class="hljs-params">  <span class="hljs-keyword">final</span> WaitStrategy waitStrategy)</span>&#123;<br>  <span class="hljs-built_in">this</span>(RingBuffer.create(producerType, eventFactory, ringBufferSize, waitStrategy), executor);<br>&#125;<br></code></pre></td></tr></table></figure><p>RingBuffer.create():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; RingBuffer&lt;E&gt; <span class="hljs-title function_">create</span><span class="hljs-params">(</span><br><span class="hljs-params">      <span class="hljs-keyword">final</span> ProducerType producerType,</span><br><span class="hljs-params">      <span class="hljs-keyword">final</span> EventFactory&lt;E&gt; factory,</span><br><span class="hljs-params">      <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> bufferSize,</span><br><span class="hljs-params">      <span class="hljs-keyword">final</span> WaitStrategy waitStrategy)</span>&#123;<br>  <span class="hljs-keyword">switch</span> (producerType)<br>  &#123;<br>      <span class="hljs-keyword">case</span> SINGLE:<br>          <span class="hljs-keyword">return</span> createSingleProducer(factory, bufferSize, waitStrategy);<br>      <span class="hljs-keyword">case</span> MULTI:<br>          <span class="hljs-keyword">return</span> createMultiProducer(factory, bufferSize, waitStrategy);<br>      <span class="hljs-keyword">default</span>:<br>          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(producerType.toString());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 RingBuffer 创建时，分为单生产者与多生产者。不论是单生产者还是多生产者，最终都会创建一个 RingBuffer 对象，只是传给 RingBuffer 的 Sequencer 对象不同，RingBuffer 内部最终创建了一个Object 数组来存储 Event 数据。RingBuffer创建我们需要注意：</p><ul><li>RingBuffer 在创建该数组后紧接着调用 fill 方法调用 EventFactory 工厂方法为数组中的元素进行初始化，后续在使用这些元素时，直接通过下标获取并给对应的属性赋值，这样就避免了 Event 对象的反复创建，避免频繁 GC。</li><li>RingBuffe 的数组中的元素是在初始化时一次性全部创建的，所以这些元素的内存地址大概率是连续的。消费者在消费时，是遵循空间局部性原理的。消费完第一个Event 时，很快就会消费第二个 Event，而在消费第一个 Event 时，CPU 会把内存中的第一个 Event 的后面的 Event 也加载进 Cache 中，这样当消费第二个 Event时，它已经在 CPU Cache 中了，所以就不需要从内存中加载了，这样可以大大提升性能。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">RingBufferFields(<br>        EventFactory&lt;E&gt; eventFactory,<br>        Sequencer sequencer)&#123;<br>        <br>  <span class="hljs-comment">// 额外创建2个填充空间的大小, 首尾填充, 避免数组的有效载荷和其它成员加载到同一缓存行</span><br>  <span class="hljs-built_in">this</span>.entries = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[sequencer.getBufferSize() + <span class="hljs-number">2</span> * BUFFER_PAD];<br>  fill(eventFactory);<br>&#125;<br> <br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fill</span><span class="hljs-params">(EventFactory&lt;E&gt; eventFactory)</span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; bufferSize; i++)&#123;<br>      <span class="hljs-comment">// BUFFER_PAD + i为真正的数组索引</span><br>      entries[BUFFER_PAD + i] = eventFactory.newInstance();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="消费者与消费"><a href="#消费者与消费" class="headerlink" title="消费者与消费"></a>消费者与消费</h3><p>在 Disruptor 启动之前需要添加 Consumer 并启动消费者线程:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">disruptor.handleEventsWith(consumer);<br>disruptor.start();<br></code></pre></td></tr></table></figure><p>具体源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-meta">@SafeVarargs</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> EventHandlerGroup&lt;T&gt; <span class="hljs-title function_">handleEventsWith</span><span class="hljs-params">(<span class="hljs-keyword">final</span> EventHandler&lt;? <span class="hljs-built_in">super</span> T&gt;... handlers)</span><br>&#123;<br>    <span class="hljs-keyword">return</span> createEventProcessors(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Sequence</span>[<span class="hljs-number">0</span>], handlers);<br>&#125;<br><br>EventHandlerGroup&lt;T&gt; <span class="hljs-title function_">createEventProcessors</span><span class="hljs-params">(</span><br><span class="hljs-params">        <span class="hljs-keyword">final</span> Sequence[] barrierSequences,</span><br><span class="hljs-params">        <span class="hljs-keyword">final</span> EventHandler&lt;? <span class="hljs-built_in">super</span> T&gt;[] eventHandlers)</span><br>&#123;<br>  checkNotStarted();<br>  <span class="hljs-comment">// 收集添加的消费者的序号</span><br>  <span class="hljs-keyword">final</span> Sequence[] processorSequences = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sequence</span>[eventHandlers.length];<br>  <span class="hljs-comment">// 本批次消费由于添加在同一个节点之后, 因此共享该屏障</span><br>  <span class="hljs-keyword">final</span> <span class="hljs-type">SequenceBarrier</span> <span class="hljs-variable">barrier</span> <span class="hljs-operator">=</span> ringBuffer.newBarrier(barrierSequences);<br>  <span class="hljs-comment">// 为每个EventHandler创建一个BatchEventProcessor</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, eventHandlersLength = eventHandlers.length; i &lt; eventHandlersLength; i++)<br>  &#123;<br>      <span class="hljs-keyword">final</span> EventHandler&lt;? <span class="hljs-built_in">super</span> T&gt; eventHandler = eventHandlers[i];<br><br>      <span class="hljs-keyword">final</span> BatchEventProcessor&lt;T&gt; batchEventProcessor =<br>              <span class="hljs-keyword">new</span> <span class="hljs-title class_">BatchEventProcessorBuilder</span>().build(ringBuffer, barrier, eventHandler);<br><br>      <span class="hljs-keyword">if</span> (exceptionHandler != <span class="hljs-literal">null</span>)<br>      &#123;<br>          batchEventProcessor.setExceptionHandler(exceptionHandler);<br>      &#125;<br>      <span class="hljs-comment">// 添加到消费者信息仓库中</span><br>      consumerRepository.add(batchEventProcessor, eventHandler, barrier);<br>      processorSequences[i] = batchEventProcessor.getSequence();<br>  &#125;<br>  <span class="hljs-comment">// 更新序列</span><br>  updateGatingSequencesForNextInChain(barrierSequences, processorSequences);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventHandlerGroup</span>&lt;&gt;(<span class="hljs-built_in">this</span>, consumerRepository, processorSequences);<br>&#125;<br></code></pre></td></tr></table></figure><p>disruptor.start()：Disruptor的启动就是遍历consumerRepository 中收集的 EventProcessor（实现了Runnable接口），将它提交到创建 Disruptor 时指定的executor 中，EventProcessor 的 run 方法会启动一个while 循环，不断尝试从 RingBuffer 中获取数据进行消费。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> RingBuffer&lt;T&gt; <span class="hljs-title function_">start</span><span class="hljs-params">()</span><br>&#123;<br>  checkOnlyStartedOnce();<br>  consumerRepository.startAll(threadFactory);<br>  <span class="hljs-keyword">return</span> ringBuffer;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startAll</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ThreadFactory threadFactory)</span><br>&#123;<br>  consumerInfos.forEach(c -&gt; c.start(threadFactory));<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Executor executor)</span> &#123;<br>  executor.execute(eventprocessor);<br>&#125;<br></code></pre></td></tr></table></figure><p>消费：Disruptor 启动时，会将封装 EventHandler 的EventProcessor（此处以 BatchEventProcessor 为例）提交到线程池中运行，BatchEventProcessor 的 run 方法会调用 processEvents 方法不断尝试从 RingBuffer 中获取数据进行消费。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">witnessValue</span> <span class="hljs-operator">=</span> running.compareAndExchange(IDLE, RUNNING);<br>  <span class="hljs-keyword">if</span> (witnessValue == IDLE) &#123;<br>    省略<br>    <span class="hljs-keyword">if</span> (running.get() == RUNNING) &#123;<br>      processEvents();<br>    &#125;<br>    省略<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processEvents</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-type">T</span> <span class="hljs-variable">event</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// sequence记录消费者的消费进度, 初始为-1</span><br>  <span class="hljs-type">long</span> <span class="hljs-variable">nextSequence</span> <span class="hljs-operator">=</span> sequence.get() + <span class="hljs-number">1L</span>;<br>  <span class="hljs-comment">// 循环处理，每一个EventProcessor都由独立的线程处理</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">startOfBatchSequence</span> <span class="hljs-operator">=</span> nextSequence;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 通过屏障获取到的最大可用序号</span><br>      <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">availableSequence</span> <span class="hljs-operator">=</span> sequenceBarrier.waitFor(nextSequence);<br>      <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">endOfBatchSequence</span> <span class="hljs-operator">=</span> min(nextSequence + batchLimitOffset, availableSequence);<br>      <br>      <span class="hljs-keyword">if</span> (nextSequence &lt;= endOfBatchSequence) &#123;<br>        eventHandler.onBatchStart(endOfBatchSequence - nextSequence + <span class="hljs-number">1</span>, availableSequence - nextSequence + <span class="hljs-number">1</span>);<br>      &#125;<br>      <span class="hljs-comment">// 批量消费</span><br>      <span class="hljs-keyword">while</span> (nextSequence &lt;= endOfBatchSequence) &#123;<br>        event = dataProvider.get(nextSequence);<br>        <span class="hljs-comment">// 这里调用的是 BizTaskConsumer.onEvent()</span><br>        eventHandler.onEvent(event, nextSequence, nextSequence == endOfBatchSequence);<br>        nextSequence++;<br>      &#125;<br>      retriesAttempted = <span class="hljs-number">0</span>;<br>      <span class="hljs-comment">// 更新消费进度(批量消费, 每次消费只更新一次Sequence, 减少性能消耗)</span><br>      sequence.set(endOfBatchSequence);<br>    &#125; <br>    <span class="hljs-comment">// 省略异常处理</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在 waitStrategy 的 waitFor 方法返回，得到最大可用的序号 availableSequence 后，最后需要再调用下 sequencer 的 getHighestPublishedSequence 获取真正可用的最大序号，这和生产者模型有关系，如果是单生产者，因为数据是连续发布的，直接返回传入的 availableSequence。而如果是多生产者，因为多生产者是有多个线程在生产数据，发布的数据是不连续的，因此需要通过 getHighestPublishedSequence 方法获取已发布的且连续的最大序号，因为获取序号进行消费时需要是顺序的，不能跳跃。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">waitFor</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-type">long</span> sequence)</span> <span class="hljs-keyword">throws</span> AlertException, InterruptedException, TimeoutException &#123;<br>  checkAlert();<br>  <span class="hljs-type">long</span> <span class="hljs-variable">availableSequence</span> <span class="hljs-operator">=</span> waitStrategy.waitFor(sequence, cursorSequence, dependentSequence, <span class="hljs-built_in">this</span>);<br>  <span class="hljs-keyword">if</span> (availableSequence &lt; sequence) &#123;<br>      <span class="hljs-keyword">return</span> availableSequence;<br>  &#125;<br>  <span class="hljs-comment">// 目标sequence已经发布了, 这里获取真正的最大序号(和生产者模型有关)</span><br>  <span class="hljs-keyword">return</span> sequencer.getHighestPublishedSequence(sequence, availableSequence);<br>&#125;<br><br><span class="hljs-comment">// BlockingWaitStrategy.waitFor()</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">waitFor</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-type">long</span> sequence, <span class="hljs-keyword">final</span> Sequence cursorSequence, <span class="hljs-keyword">final</span> Sequence dependentSequence, <span class="hljs-keyword">final</span> SequenceBarrier barrier)</span> <span class="hljs-keyword">throws</span> AlertException, InterruptedException &#123;<br>  <span class="hljs-type">long</span> availableSequence;<br>  <span class="hljs-keyword">if</span> (cursorSequence.get() &lt; sequence)&#123;<br>    <span class="hljs-keyword">synchronized</span> (mutex) &#123;<br>      <span class="hljs-keyword">while</span> (cursorSequence.get() &lt; sequence) &#123;<br>        barrier.checkAlert();<br>        mutex.wait();<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 确保该序号已经被我前面的消费者消费(协调与其他消费者的关系)</span><br>  <span class="hljs-keyword">while</span> ((availableSequence = dependentSequence.get()) &lt; sequence)&#123;<br>    barrier.checkAlert();<br>    <span class="hljs-comment">// 自旋等待</span><br>    Thread.onSpinWait();<br>  &#125;<br>  <span class="hljs-keyword">return</span> availableSequence;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>dependentSequence</strong>：消费者依赖的前置消费者的消费进度。该字段是在添加 EventHandler，创建BatchEventProcessor 时创建的。如果当前消费者没有前置依赖的消费者，那么它只需要关心生产者的进度，生产者生产到哪里，它就可以消费到哪里，因此 dependentSequence 就是 cursor。而如果当前消费者有前置依赖的消费者，那么dependentSequence就是FixedSequenceGroup(dependentSequences)。dependentSequence 分为两种情况，所以 waitFor 的逻辑也可以分为两种情况讨论：</p><ul><li>当前消费者无前置消费者时，当生产者继续发布数据后，因为 dependentSequence 持有的就是生产者的生成进度，因此消费者可以感知到，继续消费。</li><li>当前消费者有前置消费者时，需要等待最慢的消费者序列号追上才能往后消费。</li></ul><h3 id="生产者与发布"><a href="#生产者与发布" class="headerlink" title="生产者与发布"></a>生产者与发布</h3><p>我们先看下业务发布入口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(TaskEvent&lt;T&gt; event)</span> &#123;<br>  <span class="hljs-type">long</span> <span class="hljs-variable">sequence</span> <span class="hljs-operator">=</span> ringBuffer.next();<br>  <span class="hljs-keyword">try</span> &#123;<br>    TaskEvent&lt;T&gt; taskEvent = ringBuffer.get(sequence);<br>    taskEvent.setTaskId(event.getTaskId());<br>    taskEvent.setPayload(event.getPayload());<br>  &#125; <span class="hljs-keyword">finally</span> &#123;<br>    ringBuffer.publish(sequence);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>业务发布逻辑</strong>：</p><ul><li>调用 next 方法获取可用序号，该方法可能会阻塞。</li><li>通过上一步获得的序号从 RingBuffer 中获取对应的 Event，因为 RingBuffer 中所有的 Event 在初始化时已经创建好了，这里获取的只是空对象。</li><li>taskEvent 进行业务赋值。</li><li>在 finally 方法中进行最终的发布<code>ringBuffer.publish(sequence)</code>，标记该序号数据已实际生产完成。</li></ul><p><strong>next方法</strong>：next 方法默认申请一个序号。nextValue 表示已分配的序号，nextSequence 表示在此基础上再申请n个序号（此处n为1），cachedValue 表示缓存的消费者的最小消费进度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">next</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-type">int</span> n)</span>&#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 已分配的序号的缓存(已分配到这里), 初始-1. 可以看该方法的返回值nextSequence,</span><br><span class="hljs-comment">   * 接下来生产者就会该往该位置写数据, 它赋值给了nextValue, 所以下一次调用next方</span><br><span class="hljs-comment">   * 法时, nextValue位置就是表示已经生产好了数据, 接下来要申请nextSequece的数据</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-type">long</span> <span class="hljs-variable">nextValue</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.nextValue;<br>  <span class="hljs-comment">// 本次申请分配的序号</span><br>  <span class="hljs-type">long</span> <span class="hljs-variable">nextSequence</span> <span class="hljs-operator">=</span> nextValue + n;<br>  <span class="hljs-comment">// 构成环路的点：环形缓冲区可能追尾的点 = 等于本次申请的序号-环形缓冲区大小，如果该序号大于最慢消费者的进度, 那么表示追尾了, 需要等待</span><br>  <span class="hljs-type">long</span> <span class="hljs-variable">wrapPoint</span> <span class="hljs-operator">=</span> nextSequence - bufferSize;<br>  <span class="hljs-comment">// 消费最慢的消费者的进度</span><br>  <span class="hljs-type">long</span> <span class="hljs-variable">cachedGatingSequence</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.cachedValue;<br>  <span class="hljs-comment">// wrapPoint &gt; cachedGatingSequence 表示生产者追上消费者产生环路(追尾), 即缓冲区已满, 此时需要获取消费者们最新的进度, 以确定是否队列满</span><br>  <span class="hljs-keyword">if</span> (wrapPoint &gt; cachedGatingSequence || cachedGatingSequence &gt; nextValue) &#123;<br>    <span class="hljs-comment">// 插入StoreLoad内存屏障/栅栏, 保证可见性。</span><br>    <span class="hljs-comment">// 因为publish使用的是set()/putOrderedLong, 并不保证其他消费者能及时看见发布的数据</span><br>    <span class="hljs-comment">// 当我再次申请更多的空间时, 必须保证消费者能消费发布的数据</span><br>    cursor.setVolatile(nextValue);  <span class="hljs-comment">// StoreLoad fence</span><br>    <span class="hljs-type">long</span> minSequence;<br>    <span class="hljs-comment">// minSequence是多个消费者的最小序号, 要等所有消费者消费完了才能继续生产</span><br>    <span class="hljs-keyword">while</span> (wrapPoint &gt; (minSequence = Util.getMinimumSequence(gatingSequences, nextValue))) &#123;<br>      <span class="hljs-comment">// RingBuffer 已经满了，阻塞等待 消费者消费</span><br>      LockSupport.parkNanos(<span class="hljs-number">1L</span>); <br>    &#125;<br>    <span class="hljs-comment">// 缓存最新的消费进度</span><br>    <span class="hljs-built_in">this</span>.cachedValue = minSequence;<br>  &#125;<br>  <span class="hljs-built_in">this</span>.nextValue = nextSequence;<br>  <span class="hljs-keyword">return</span> nextSequence;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>发布数据</strong>：生产者获取到可用序号后，对Event 对象进行业务赋值后，最后调用 RingBuffer 的 publish 方法发布数据，RingBuffer 会委托给其持有的 sequencer（单生产者和多生产者对应不同的 sequencer）对象进行真正发布。单生产者的发布逻辑比较简单，更新下 cursor 进度（cursor 表示生产者的生产进度，该位置已实际发布数据，而 next 方法中的 nextSequence 表示生产者申请的最大序号，可能还未实际发布数据），接着唤醒等待的消费者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">publish</span><span class="hljs-params">(<span class="hljs-keyword">final</span> <span class="hljs-type">long</span> sequence)</span>&#123;<br>  sequencer.publish(sequence);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">publish</span><span class="hljs-params">(<span class="hljs-type">long</span> sequence)</span> &#123;<br>  <span class="hljs-comment">// 更新生产者进度</span><br>  cursor.set(sequence);<br>  <span class="hljs-comment">// 唤醒等待的消费者</span><br>  waitStrategy.signalAllWhenBlocking();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Disruptor 是基于生产者消费者模式，如果生产快消费慢，就会导致生产者无法写入数据，不建议在 Disruptor 消费线程中处理耗时较长的业务。另外，每一个 EventHandler 对应一个线程，一个线程只服务于一个 EventHandler，在创建 Disruptor 时不推荐传入指定的线程池，而是由 Disruptor 自身根据 EventHandler 数量去创建对应的线程。消费者在获取不到数据时会根据设置的等待策略进行等待，BlockingWaitStrategry 是最低效的策略，但其对 CPU消耗最小，YieldingWaitStrategy 有着较低的延迟、较高的吞吐量，以及较高 CPU 占用率。生产者调用 next 方法申请序号时，如果获取不到可用序号会阻塞，可以使用 tryPublishEvent 方法，生产者在申请不到可用序号时会立即返回，不会阻塞业务线程。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>并发</category>
      
      <category>高性能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>并发</tag>
      
      <tag>高性能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于LinkedTransferQueue实现连接池</title>
    <link href="/2025/07/19/java-juc-%E5%9F%BA%E4%BA%8ELinkedTransferQueue%E5%AE%9E%E7%8E%B0%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    <url>/2025/07/19/java-juc-%E5%9F%BA%E4%BA%8ELinkedTransferQueue%E5%AE%9E%E7%8E%B0%E8%BF%9E%E6%8E%A5%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>连接池是一种用空间换时间、并确保资源可控性的重要设计模式。 它将昂贵的“连接创建”操作转变为廉价的“连接借用”操作，是构建高性能、高可用的数据库驱动应用不可或缺的基础设施。</p><span id="more"></span><ul><li>创建连接开销巨大: 建立一个数据库连接是一个昂贵且耗时的操作。它涉及到网络通信（三次握手）、数据库服务器的认证、权限验证等一系列步骤。这个过程可能需要几百毫秒甚至几秒钟的时间。</li><li>连接池复用连接: 连接池在应用程序启动时预先创建一定数量的连接，并将它们存储在一个池中。当应用程序需要访问数据库时，它不是创建一个新连接，而是从池中借用一个已有的、空闲的连接。操作完成后，将连接归还到池中，而不是关闭它。</li><li>消除创建&#x2F;销毁的延迟: 通过复用连接，应用程序消除了每次请求时的连接创建和销毁开销，从而大大缩短了数据库操作的响应时间，提高了系统的整体吞吐量（Throughput）。</li></ul><h3 id="常见框架"><a href="#常见框架" class="headerlink" title="常见框架"></a>常见框架</h3><p>Apache Commons Pool 2：<br>Apache Commons Pool 2 是一个通用的、高度可配置的对象池框架。它的实现原理基于一套清晰的接口和协作组件，旨在提供灵活且健壮的对象生命周期管理。 核心原理是通过将对象池 (GenericObjectPool) 的通用逻辑与特定对象的生命周期管理 (PooledObjectFactory) 解耦，实现了一个高度灵活、可配置且功能全面的通用对象池框架。它使用同步机制和后台维护线程来确保在高并发环境下的正确性和稳定性。</p><p>HikariCP：<br>HikariCP（简称 Hikari）之所以能成为目前 Java 生态中最快、最受欢迎的连接池，其核心实现原理在于极致的性能优化和精巧的设计。它避免了其他连接池中常见的性能瓶颈，主要通过以下几个方面实现：</p><ul><li><p>核心数据结构——ConcurrentBag。Hikari 没有使用传统的 BlockingQueue 或其他标准并发集合来存储连接，而是实现了一个名为 ConcurrentBag（并发背包）的自定义并发集合，这是其高性能的关键之一。ConcurrentBag 旨在最大程度地减少线程争用（contention），它内部使用了一些无锁（lock-free）技术（如 CAS 操作）来管理连接的分配和回收，避免了昂贵的锁操作。ConcurrentBag 内部利用 ThreadLocal 存储了一个小的、线程私有的连接缓存。当一个线程请求连接时，它首先会检查自己的 ThreadLocal 缓存。如果能直接从缓存中获取，就可以完全避免跨线程同步的开销，实现极快的连接获取速度。只有在私有缓存为空时，才会涉及到底层的共享池同步操作。</p></li><li><p>连接代理：<br>当应用程序从 Hikari 中获取连接时，它实际上并没有拿到物理数据库连接本身，而是拿到了一个实现了 Connection 接口的代理对象 (ConnectionProxy)。这个代理对象拦截了应用程序调用的 close() 方法。当应用调用 close() 时，代理并不会真正关闭底层的物理连接，而是将连接的状态重置（清理事务状态、恢复默认配置等）后，将其归还到连接池的 ConcurrentBag 中，并将连接标记为可用状态。代理负责管理连接在“空闲（IDLE）”和“使用中（IN_USE）”之间的状态转换。</p></li><li><p>轻量级连接验证：<br>许多传统的连接池在每次借出连接前都会执行一个 connection test query（例如 SELECT 1）来验证连接的有效性，这会带来额外的网络延迟和数据库负载。</p><ul><li><strong>惰性验证</strong>: Hikari 采取了更智能的验证策略，它默认只在连接空闲超过 500 毫秒时进行验证。如果连接一直处于被频繁借出和归还的状态（高负载场景），它会跳过验证步骤，极大地提高了高并发下的性能。</li><li><strong>快速失败</strong>: Hikari 依赖于 JDBC 驱动本身的快速失败机制。它假定连接在大多数时候是健康的，只有在真正发生网络错误或数据库故障时才处理异常，而不是主动去探测连接的健康状况。</li></ul></li><li><p>异步连接创建与维护 (Housekeeper)<br>Hikari 使用一个名为 Housekeeper（管家）的后台线程来异步管理连接池的生命周期。</p><ul><li>连接维护: Housekeeper 定期运行（默认每 30 秒），负责执行以下任务：<ul><li>检查并关闭空闲时间过长（超过 idleTimeout）的连接，以缩减连接池规模，如果当前连接数大于 minimumIdle。</li><li>检查并关闭生存时间过长，超过 maxLifetime）的连接，确保连接定期刷新，避免数据库或中间件的强制断开。</li><li>在需要时异步创建新连接，以维持 minimumIdle 要求的空闲连接数，避免在高峰期同步创建连接导致延迟。</li></ul></li><li>泄露检测: Housekeeper 还会检查连接是否发生泄露，即借出后长时间未归还，并在配置了 leakDetectionThreshold 时记录警告日志。</li></ul></li></ul><h3 id="LinkedTransferQueue"><a href="#LinkedTransferQueue" class="headerlink" title="LinkedTransferQueue"></a>LinkedTransferQueue</h3><p>LinkedTransferQueue 是 Java util.concurrent 包下提供的一个高性能的并发队列实现，它实现了 TransferQueue 接口。它的设计目标是在生产者和消费者之间实现高效的直接切换（handoff）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedTransferQueue</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueue</span>&lt;E&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TransferQueue</span>&lt;E&gt;, java.io.Serializable &#123;&#125;<br></code></pre></td></tr></table></figure><p><strong>主要特性 (Characteristics)</strong></p><ul><li>无界（Unbounded）: 理论上，LinkedTransferQueue 是一个无界队列。只要内存允许，你可以向其中添加任意多的元素。</li><li>高性能的无锁（Lock-Free）实现: 它基于 CAS（Compare-And-Swap）操作实现了一个高效的无锁数据结构。在大多数并发场景下，它的性能通常优于基于锁的阻塞队列（如 LinkedBlockingQueue）。</li><li>直接传递（Handoff）机制: 这是它最显著的特性。当一个生产者线程调用 transfer() 方法时，它会阻塞，直到一个消费者线程准备好接收该元素，然后元素会直接从生产者传递给消费者，省去了元素在队列中排队的过程。</li><li>公平性（Fairness）: LinkedTransferQueue 保证了等待的生产者和消费者线程的公平性。等待时间最长的线程将首先被匹配和唤醒。</li><li>实现了 TransferQueue 接口: 它继承了 AbstractQueue 并实现了 TransferQueue 接口，提供了比标准 BlockingQueue 更丰富的同步方法。</li></ul><p>LinkedTransferQueue 提供了标准队列操作（如 put, offer, take, poll）以及特有的 transfer 操作：</p><ul><li><p>核心 Transfer 方法 (直接传递): </p><ul><li>V transfer(V e) throws InterruptedException：尝试立即将元素 e 传递给一个等待接收的消费者。<strong>阻塞</strong>，如果当前没有消费者在等待接收元素，则当前调用线程会阻塞，直到有一个消费者出现并接收了该元素。</li><li>boolean tryTransfer(V e)：尝试立即将元素 e 传递给一个等待接收的消费者。<strong>非阻塞&#x2F;立即返回</strong>，如果有等待的消费者，立即传递并返回 true。如果没有等待的消费者，则立即返回 false，元素不会被放入队列。</li><li>boolean tryTransfer(V e, long timeout, TimeUnit unit) throws InterruptedException：尝试在指定的超时时间内将元素 e 传递给一个消费者。<strong>超时阻塞</strong>，如果在超时时间内成功匹配消费者，则返回 true；如果超时仍未匹配到消费者，则返回 false（元素不会进入队列）。</li></ul></li><li><p>标准 Queue&#x2F;BlockingQueue 方法 (排队&#x2F;阻塞)</p><ul><li>void put(V e): 将指定的元素插入队列的尾部。非阻塞，由于队列是无界的，此方法不会阻塞，它总是立即返回。</li><li>boolean offer(V e): 相当于 put(e)，用于将元素添加到队列。非阻塞，总是返回 true。</li><li>V take() throws InterruptedException: 检索并移除此队列的头部元素。阻塞，如果队列当前为空，则当前线程会阻塞，直到有元素可用。</li><li>V poll(long timeout, TimeUnit unit) throws InterruptedException: 检索并移除队列的头部，使用超时等待。超时阻塞，如果在指定时间内队列仍然为空，则返回 null。</li><li>V poll(): 检索并移除队列的头部。非阻塞，如果队列为空，立即返回 null。</li></ul></li></ul><p>LinkedTransferQueue 非常适合实现高性能的“任务分发中心”或连接池等场景，其中生产者希望在有消费者准备好处理数据时立即将数据移交给消费者，最大限度地减少延迟和排队时间。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>使用 LinkedTransferQueue (LTQ) 来实现对象池是一个高性能的选择，尤其是在高并发场景下。LTQ 的核心优势在于其 transfer() 和 tryTransfer() 方法，它们支持“直接交接”，当一个线程归还对象时（生产者），它可以尝试 tryTransfer()，如果此时有另一个线程正在 poll() 或 take() 等待获取对象（消费者），LTQ 会将该对象直接从归还线程交给等待线程，而无需将对象放入队列中再取出。这极大地减少了锁竞争和上下文切换，提高了吞吐量。</p><h3 id="核心设计思路"><a href="#核心设计思路" class="headerlink" title="核心设计思路"></a>核心设计思路</h3><ul><li><p><code>PooledFactory&lt;T&gt;</code> 接口: 定义如何创建、销毁和验证池中对象。这是池化框架（如 Apache Commons Pool）的标准实践。<br>PooledProperties 类: 存放配置，例如最大池大小 maxSize 和获取超时 acquireTimeout等。</p></li><li><p><code>TransferQueuePool&lt;T&gt;</code> : 核心数据结构，用于存放空闲的对象。</p></li><li><p>tryAcquire() (获取对象):  </p><ul><li>首先尝试 pool.poll() 非阻塞地获取一个空闲对象。</li><li>如果获取到，验证（validate）对象。如果有效，返回；如果无效，销毁（destroy）对象，总数（totalSize）减一，然后重试。 </li><li>如果没有空闲对象，检查 total。 如果 totalSize &lt; maxSize，尝试使用 AtomicInteger.compareAndSet() 增加 total 并创建一个新对象（factory.create()）。 如果 totalSize &gt;&#x3D; maxSize（池已满），则调用 pool.poll(timeout, unit) 阻塞等待，直到有其他线程归还对象。</li></ul></li><li><p>release(T obj) (归还对象):</p><ul><li>首先验证对象。如果无效，直接销毁，total 减一，不归还到池中。 </li><li>核心: 调用 pool.tryTransfer(obj)。 如果 tryTransfer 返回 true，意味着对象已成功“直接交接”给一个正在等待的线程。如果返回 false（没有线程在等待），则调用 idleObjects.offer(obj) 将对象放入空闲队列中。</li></ul></li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>PooledFactory：通用工厂接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PooledFactory</span>&lt;T&gt; &#123;<br><br>  T <span class="hljs-title function_">create</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception;<br><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">(T obj)</span>;<br><br>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">validate</span><span class="hljs-params">(T obj)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>PooledProperties：配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PooledProperties</span> &#123;<br><br>  <span class="hljs-type">int</span> <span class="hljs-variable">maximumPoolSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">minimumIdle</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>  <span class="hljs-type">long</span> <span class="hljs-variable">idleInterval</span> <span class="hljs-operator">=</span> <span class="hljs-number">60L</span>;<br>  <span class="hljs-type">long</span> <span class="hljs-variable">idleTimeout</span> <span class="hljs-operator">=</span> <span class="hljs-number">3000L</span>;<br>  <span class="hljs-type">long</span> <span class="hljs-variable">maxLifetime</span> <span class="hljs-operator">=</span> <span class="hljs-number">60</span> * <span class="hljs-number">1000L</span>;<br>  <span class="hljs-type">long</span> <span class="hljs-variable">acquireTimeout</span> <span class="hljs-operator">=</span> <span class="hljs-number">5000L</span>;<br>  <span class="hljs-type">TimeUnit</span> <span class="hljs-variable">acquireTimeunit</span> <span class="hljs-operator">=</span> TimeUnit.MILLISECONDS;<br>&#125;<br></code></pre></td></tr></table></figure><p>PooledWrapper：资源封装类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PooledWrapper</span>&lt;T&gt; &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> T resource;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> creationTime;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> lastAccessTime;<br><br>  PooledWrapper(T resource) &#123;<br>    <span class="hljs-built_in">this</span>.resource = resource;<br>    <span class="hljs-built_in">this</span>.creationTime = System.currentTimeMillis();<br>    <span class="hljs-built_in">this</span>.lastAccessTime = <span class="hljs-built_in">this</span>.creationTime;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>TransferQueuePool：具体实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransferQueuePool</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AutoCloseable</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(TransferQueuePool.class);<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PooledProperties properties;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LinkedTransferQueue&lt;PooledWrapper&lt;T&gt;&gt; pool;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PooledFactory&lt;T&gt; factory;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ScheduledExecutorService scheduler;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicBoolean</span> <span class="hljs-variable">closed</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicBoolean</span>(<span class="hljs-literal">false</span>);<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">total</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">idle</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">TransferQueuePool</span><span class="hljs-params">(PooledProperties properties, PooledFactory&lt;T&gt; factory)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-built_in">this</span>.properties = properties;<br>    <span class="hljs-built_in">this</span>.factory = factory;<br>    <span class="hljs-built_in">this</span>.pool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedTransferQueue</span>&lt;&gt;();<br>    <span class="hljs-built_in">this</span>.scheduler = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span>(<span class="hljs-number">1</span>, r -&gt; &#123;<br>      <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r);<br>      t.setDaemon(<span class="hljs-literal">true</span>);<br>      t.setName(<span class="hljs-string">&quot;transfer-pool-scheduler-&quot;</span> + t.getId());<br>      <span class="hljs-keyword">return</span> t;<br>    &#125;);<br>    ((ScheduledThreadPoolExecutor) <span class="hljs-built_in">this</span>.scheduler).setRemoveOnCancelPolicy(<span class="hljs-literal">true</span>);<br>    initializePool();<br>    startCheckTask();<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initializePool</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; properties.getMinimumIdle(); i++) &#123;<br>      createPoolWrapper();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createPoolWrapper</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    logger.info(<span class="hljs-string">&quot;create pool wrapper......................&quot;</span>);<br>    <span class="hljs-type">T</span> <span class="hljs-variable">wrapper</span> <span class="hljs-operator">=</span> factory.create();<br>    PooledWrapper&lt;T&gt; pooledWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PooledWrapper</span>&lt;&gt;(wrapper);<br>    pool.offer(pooledWrapper);<br>    total.incrementAndGet();<br>    idle.incrementAndGet();<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startCheckTask</span><span class="hljs-params">()</span> &#123;<br>    scheduler.scheduleAtFixedRate(<br>        <span class="hljs-built_in">this</span>::checkIdleTask,<br>        properties.getIdleInterval(),<br>        properties.getIdleInterval(),<br>        TimeUnit.SECONDS);<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkIdleTask</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    logger.info(<span class="hljs-string">&quot;check idle task,runtime:&#123;&#125;&quot;</span>, now);<br>    <span class="hljs-keyword">try</span> &#123;<br>      pool.removeIf(wrapper -&gt; &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 检查是否过期</span><br>        <span class="hljs-keyword">if</span> (now - wrapper.getCreationTime() &gt; properties<br>            .getMaxLifetime()) &#123;<br>          removed = <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!factory.validate(wrapper.getResource())) &#123;<br>          removed = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (removed) &#123;<br>          factory.destroy(wrapper.getResource());<br>          total.decrementAndGet();<br>          idle.decrementAndGet();<br>        &#125;<br>        <span class="hljs-keyword">return</span> removed;<br>      &#125;);<br><br>      <span class="hljs-comment">// 确保维持最小连接数</span><br>      <span class="hljs-keyword">while</span> (total.get() &lt; properties.getMinimumIdle()) &#123;<br>        createPoolWrapper();<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>      logger.error(<span class="hljs-string">&quot;check idle task error&quot;</span>, e);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> T <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">return</span> tryAcquire(properties.getAcquireTimeout(), TimeUnit.SECONDS);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> T <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">if</span> (closed.get()) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;pool is closed!!!&quot;</span>);<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.nanoTime() + unit.toNanos(timeout);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>      <span class="hljs-type">long</span> <span class="hljs-variable">remainingNanos</span> <span class="hljs-operator">=</span> deadline - System.nanoTime();<br>      <span class="hljs-keyword">if</span> (remainingNanos &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeoutException</span>(<span class="hljs-string">&quot;Timeout waiting for object from pool.&quot;</span>);<br>      &#125;<br><br>      PooledWrapper&lt;T&gt; wrapper = pool.poll();<br>      <span class="hljs-keyword">if</span> (wrapper != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (factory.validate(wrapper.getResource())) &#123;<br>          idle.decrementAndGet();<br>          <span class="hljs-keyword">return</span> wrapper.getResource();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          factory.destroy(wrapper.getResource());<br>          total.decrementAndGet();<br>        &#125;<br>      &#125;<br>      <span class="hljs-comment">// 队列为空，检查是否可以创建新对象</span><br>      <span class="hljs-keyword">if</span> (total.get() &lt; properties.getMaximumPoolSize()) &#123;<br>        <span class="hljs-keyword">synchronized</span> (pool) &#123;<br>          <span class="hljs-keyword">if</span> (total.get() &lt; properties.getMaximumPoolSize()) &#123;<br>            createPoolWrapper();<br>            wrapper = pool.poll();<br>            <span class="hljs-keyword">if</span> (wrapper != <span class="hljs-literal">null</span>) &#123;<br>              idle.decrementAndGet();<br>              <span class="hljs-keyword">return</span> wrapper.getResource();<br>            &#125;<br>          &#125;<br>        &#125;<br>      &#125;<br><br>      <span class="hljs-comment">// 队列已满，必须阻塞等待</span><br>      wrapper = pool.poll(timeout, unit);<br>      <span class="hljs-keyword">if</span> (wrapper != <span class="hljs-literal">null</span>) &#123;<br>        idle.decrementAndGet();<br>        <span class="hljs-keyword">return</span> wrapper.getResource();<br>      &#125;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeoutException</span>(<span class="hljs-string">&quot;resource acquisition timed out&quot;</span>);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">(T resource)</span> &#123;<br>    logger.info(<span class="hljs-string">&quot;release resource &#123;&#125;&quot;</span>, resource);<br>    <span class="hljs-keyword">if</span> (resource == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!closed.get() &amp;&amp; factory.validate(resource)) &#123;<br>      PooledWrapper&lt;T&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PooledWrapper</span>&lt;&gt;(resource);<br>      <span class="hljs-keyword">if</span> (!pool.tryTransfer(wrapper)) &#123;<br>        pool.offer(wrapper);<br>        idle.incrementAndGet();<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      factory.destroy(resource);<br>      total.decrementAndGet();<br>      idle.decrementAndGet();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    logger.info(<span class="hljs-string">&quot;starting close pool..........................&quot;</span>);<br>    <span class="hljs-keyword">if</span> (closed.compareAndSet(<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>)) &#123;<br>      scheduler.shutdown();<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 如果等待超时则强制关闭</span><br>        <span class="hljs-keyword">if</span> (!scheduler.awaitTermination(properties.getAcquireTimeout(), TimeUnit.MILLISECONDS)) &#123;<br>          scheduler.shutdownNow();<br>        &#125;<br>      &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        scheduler.shutdownNow();<br>        Thread.currentThread().interrupt();<br>      &#125;<br>      PooledWrapper&lt;T&gt; wrapper;<br>      <span class="hljs-keyword">while</span> ((wrapper = pool.poll()) != <span class="hljs-literal">null</span>) &#123;<br>        factory.destroy(wrapper.getResource());<br>        total.decrementAndGet();<br>        idle.decrementAndGet();<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>实现具体的工厂类——DbConnectionFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DbConnectionFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">PooledFactory</span>&lt;MockDbConnection&gt; &#123;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> MockDbConnection <span class="hljs-title function_">create</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MockDbConnection</span>();<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">(MockDbConnection obj)</span> &#123;<br>    <span class="hljs-keyword">if</span> (obj != <span class="hljs-literal">null</span>) &#123;<br>      obj.close();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">validate</span><span class="hljs-params">(MockDbConnection obj)</span> &#123;<br>    <span class="hljs-comment">// 在借出和归还时检查连接是否“存活”</span><br>    <span class="hljs-keyword">return</span> obj != <span class="hljs-literal">null</span> &amp;&amp;  !obj.isClosed();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现具体的资源类——MockDbConnection</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MockDbConnection</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">idCounter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> id;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">closed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">MockDbConnection</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.id = idCounter.incrementAndGet();<br>    System.out.println(<span class="hljs-string">&quot;创建连接 #&quot;</span> + id);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">executeQuery</span><span class="hljs-params">(String query)</span> &#123;<br>    <span class="hljs-keyword">if</span> (closed) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;连接 #&quot;</span> + id + <span class="hljs-string">&quot; 已关闭。&quot;</span>);<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;线程 &quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot; 使用连接 #&quot;</span> + id + <span class="hljs-string">&quot; 执行查询: &quot;</span> + query);<br>    <span class="hljs-comment">// 模拟耗时</span><br>    <span class="hljs-keyword">try</span> &#123;<br>      Thread.sleep(<span class="hljs-number">100</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>      Thread.currentThread().interrupt();<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isClosed</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> closed;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.closed = <span class="hljs-literal">true</span>;<br>    System.out.println(<span class="hljs-string">&quot;销毁连接 #&quot;</span> + id);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MockDbConnection[id=&quot;</span> + id + <span class="hljs-string">&quot;]&quot;</span>;<br>  &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>客户端使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MockDbExample</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(MockDbExample.class);<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 1.配置</span><br>    <span class="hljs-type">PooledProperties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PooledProperties</span>();<br>    properties.setMaximumPoolSize(<span class="hljs-number">10</span>);<br>    properties.setAcquireTimeout(<span class="hljs-number">2000</span>);<br>    properties.setAcquireTimeunit(TimeUnit.MILLISECONDS);<br><br>    <span class="hljs-comment">// 2.创建池</span><br>    <span class="hljs-keyword">try</span> (TransferQueuePool&lt;MockDbConnection&gt; pool = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransferQueuePool</span>&lt;&gt;(properties,<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">DbConnectionFactory</span>())) &#123;<br><br>      <span class="hljs-comment">// 3. 创建线程池来模拟并发请求</span><br>      <span class="hljs-type">int</span> <span class="hljs-variable">numTasks</span> <span class="hljs-operator">=</span> <span class="hljs-number">15</span>;<br>      <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(numTasks);<br><br>      logger.info(<span class="hljs-string">&quot;--- 启动 %d 个并发任务，池大小为 %d ---\n&quot;</span>, numTasks,<br>          properties.getMaximumPoolSize());<br><br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; numTasks; i++) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">taskId</span> <span class="hljs-operator">=</span> i;<br>        executor.submit(() -&gt; &#123;<br>          <span class="hljs-type">MockDbConnection</span> <span class="hljs-variable">connection</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>          <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 4. 借用连接</span><br>            logger.info(<span class="hljs-string">&quot;任务 &quot;</span> + taskId + <span class="hljs-string">&quot; 尝试借用连接...&quot;</span>);<br>            connection = pool.tryAcquire();<br><br>            <span class="hljs-comment">// 5. 使用连接</span><br>            connection.executeQuery(<span class="hljs-string">&quot;SELECT * FROM users WHERE id=&quot;</span> + taskId);<br><br>          &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            logger.info(<span class="hljs-string">&quot;任务 &quot;</span> + taskId + <span class="hljs-string">&quot; 获取连接失败: &quot;</span> + e.getMessage());<br>          &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (connection != <span class="hljs-literal">null</span>) &#123;<br>              <span class="hljs-comment">// 6. 归还连接</span><br>              logger.info(<span class="hljs-string">&quot;任务 &quot;</span> + taskId + <span class="hljs-string">&quot; 归还连接 &quot;</span> + connection);<br>              pool.release(connection);<br>            &#125;<br>          &#125;<br>        &#125;);<br>      &#125;<br><br>      <span class="hljs-comment">// 7. 关闭</span><br>      executor.shutdown();<br>      <span class="hljs-keyword">if</span> (!executor.awaitTermination(<span class="hljs-number">30</span>, TimeUnit.SECONDS)) &#123;<br>        executor.shutdownNow(); <span class="hljs-comment">// 超时则强制终止线程</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面实现了一个简化的通用的池，利用了 LinkedTransferQueue 的高性能特性，同时通过 AtomicInteger 和 CAS 操作来管理池的边界，实现了一个健壮、高性能的通用对象池。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>juc</category>
      
      <category>并发</category>
      
      <category>高性能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>juc</tag>
      
      <tag>并发</tag>
      
      <tag>高性能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CompletableFuture 基础与原理</title>
    <link href="/2025/07/17/java-juc-CompletableFuture%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%8E%9F%E7%90%86/"/>
    <url>/2025/07/17/java-juc-CompletableFuture%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>CompletableFuture 是 JDK8 中新增的多线程任务执行类，通过它我们可以方便地进行串行、并行、组合和转换异步任务，它能够以一种非常灵活的方式处理异步操作的结果，包括成功的结果、异常和取消等情况。它是对Futurer接口增强，在异步计算中，Future确实是个非常优秀的接口。但也存在着诸多限制：</p><span id="more"></span><ul><li>并发执行多任务：Future只提供了get()方法来获取结果，并且是阻塞的。所以，除了等待你别无他法；</li><li>无法对多个任务进行链式调用：如果你希望在计算任务完成后执行特定动作，比如发邮件，但Future却没有提供这样的能力；</li><li>无法组合多个任务：如果你运行了10个任务，并期望在它们全部执行结束后执行特定动作，那么在Future中这是无能为力的；</li><li>没有异常处理：Future接口中没有关于异常处理的方法；</li></ul><p>CompletableFuture的核心特性：</p><ul><li><strong>基于事件驱动</strong>：CompletableFuture的核心思想是基于事件驱动和回调。当一个任务完成时，它会触发一个或多个依赖它的后续操作，而不是让调用方线程一直阻塞等待。</li><li><strong>链式调用与组合</strong>：CompletableFuture通过提供丰富的API（如thenApply、thenAccept、thenCompose等），允许以链式调用的方式将多个异步任务连接起来，形成一个完整的异步处理流水线。这使得处理复杂的异步流程变得非常简单，避免了“回调地狱”。</li><li><strong>状态机管理</strong>：CompletableFuture内部通过一个状态机来管理任务的生命周期，例如NEW、COMPLETING、COMPLETED_NORMALLY、COMPLETED_EXCEPTIONALLY等。当任务完成时，其结果或异常会存储在内部字段中，并更新状态，通知所有依赖它的后续任务。</li><li><strong>默认线程池</strong>：CompletableFuture的异步方法（如supplyAsync、runAsync等）默认使用ForkJoinPool.commonPool()来执行任务，也可以指定自定义的Executor来控制任务的执行线程。</li><li><strong>无锁设计与原子操作</strong>：为了确保高并发下的性能，CompletableFuture的内部实现大量依赖无锁原子操作（如CAS），以高效地管理任务状态和回调链，减少锁竞争。</li></ul><h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 可自定义二元操作的函数式</span><br><span class="hljs-keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">thenApply</span><span class="hljs-params">(Function&lt;? <span class="hljs-built_in">super</span> T,? extends U&gt; fn)</span>;<br><span class="hljs-keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">thenApplyAsync</span><span class="hljs-params">(Function&lt;? <span class="hljs-built_in">super</span> T,? extends U&gt; fn)</span>;<br><br><span class="hljs-comment">// 自定义consumer实现，不返回结果</span><br><span class="hljs-keyword">public</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">thenAccept</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; action)</span>;<br><span class="hljs-keyword">public</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">thenAcceptAsync</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> T&gt; action)</span>;<br><br><span class="hljs-comment">// 自定义consumer实现，返回结果</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">supplyAsync</span><span class="hljs-params">(Supplier&lt;U&gt; supplier)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">supplyAsync</span><span class="hljs-params">(Supplier&lt;U&gt; supplier, Executor executor)</span>;<br><br><span class="hljs-comment">// 直接执行任务</span><br><span class="hljs-keyword">public</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">thenRun</span><span class="hljs-params">(Runnable action)</span>;<br><span class="hljs-keyword">public</span> CompletableFuture&lt;Void&gt; <span class="hljs-title function_">thenRunAsync</span><span class="hljs-params">(Runnable action)</span>;<br><br><span class="hljs-comment">// 组合任务</span><br><span class="hljs-keyword">public</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; <span class="hljs-title function_">thenCombine</span><span class="hljs-params">(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? <span class="hljs-built_in">super</span> T,? <span class="hljs-built_in">super</span> U,? extends V&gt; fn)</span>;<br><span class="hljs-keyword">public</span> &lt;U,V&gt; CompletableFuture&lt;V&gt; <span class="hljs-title function_">thenCombineAsync</span><span class="hljs-params">(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? <span class="hljs-built_in">super</span> T,? <span class="hljs-built_in">super</span> U,? extends V&gt; fn)</span>;<br><br><span class="hljs-comment">// 任务完成回调事件，返回结果</span><br><span class="hljs-keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">handle</span><span class="hljs-params">(BiFunction&lt;? <span class="hljs-built_in">super</span> T, Throwable, ? extends U&gt; fn)</span>;<br><span class="hljs-keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">handleAsync</span><span class="hljs-params">(BiFunction&lt;? <span class="hljs-built_in">super</span> T, Throwable, ? extends U&gt; fn)</span>;<br><br><span class="hljs-comment">// 任务完成事件，不返回结果</span><br><span class="hljs-keyword">public</span> CompletionStage&lt;T&gt; <span class="hljs-title function_">whenComplete</span><span class="hljs-params">(BiConsumer&lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-built_in">super</span> Throwable&gt; action)</span>;<br><span class="hljs-keyword">public</span> CompletionStage&lt;T&gt; <span class="hljs-title function_">whenCompleteAsync</span><span class="hljs-params">(BiConsumer&lt;? <span class="hljs-built_in">super</span> T, ? <span class="hljs-built_in">super</span> Throwable&gt; action)</span>;<br><br><span class="hljs-comment">// 异常处理</span><br><span class="hljs-keyword">public</span> CompletionStage&lt;T&gt; <span class="hljs-title function_">exceptionally</span><span class="hljs-params">(Function&lt;Throwable, ? extends T&gt; fn)</span>;<br></code></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li>基础示例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>  CompletableFuture&lt;String&gt; cf = CompletableFuture<br>      .supplyAsync(() -&gt; <span class="hljs-string">&quot;Hello CompletableFuture&quot;</span>)<br>      .thenApply(String::toUpperCase)<br>      .thenApply(String::trim);<br><br>  cf.thenAccept(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>异常处理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture.supplyAsync(() -&gt; &#123;<br>      <span class="hljs-type">double</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span> / <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">return</span> s;<br>    &#125;).exceptionally(ex -&gt; &#123;<br>      System.out.println(ex.getMessage());<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0d</span>;<br>    &#125;).thenAccept(System.out::println);<br></code></pre></td></tr></table></figure><ul><li>多任务并行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;String&gt; cf1 = CompletableFuture.supplyAsync(() -&gt; <span class="hljs-string">&quot;cf1&quot;</span>);<br>CompletableFuture&lt;String&gt; cf2 = CompletableFuture.supplyAsync(() -&gt; <span class="hljs-string">&quot;cf2&quot;</span>);<br>CompletableFuture&lt;String&gt; cf3 = CompletableFuture.supplyAsync(() -&gt; <span class="hljs-string">&quot;cf3&quot;</span>);<br>CompletableFuture.allOf(cf1, cf2, cf3).thenRun(() -&gt; &#123;<br>  <span class="hljs-type">String</span> <span class="hljs-variable">res1</span> <span class="hljs-operator">=</span> cf1.join();<br>  <span class="hljs-type">String</span> <span class="hljs-variable">res2</span> <span class="hljs-operator">=</span> cf2.join();<br>  <span class="hljs-type">String</span> <span class="hljs-variable">res3</span> <span class="hljs-operator">=</span> cf3.join();<br>  System.out.println(<span class="hljs-string">&quot;result=&quot;</span> + res1 + <span class="hljs-string">&quot;,&quot;</span> + res2 + <span class="hljs-string">&quot;,&quot;</span> + res3);<br>&#125;);<br></code></pre></td></tr></table></figure><ul><li>一个异步调用的聚合示例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AggService</span> &#123;<br>  <span class="hljs-meta">@Autowired</span><br>  <span class="hljs-keyword">private</span> AsyncRestTemplate restTemplate;<br><br>  <span class="hljs-keyword">public</span> CompletableFuture&lt;Response&gt; <span class="hljs-title function_">getAggResponse</span><span class="hljs-params">()</span> &#123;<br>    CompletableFuture&lt;User[]&gt; ucf = CompletableFuture.supplyAsync(() -&gt; &#123;<br>      <span class="hljs-keyword">return</span> restTemplate.getForObject(<span class="hljs-string">&quot;http://domain/users&quot;</span>, User[].class);<br>    &#125;);<br>    <br>    CompletableFuture&lt;Product[]&gt; pcf = CompletableFuture.supplyAsync(() -&gt; &#123;<br>      <span class="hljs-keyword">return</span> restTemplate.getForObject(<span class="hljs-string">&quot;http://domain/products&quot;</span>, Product[].class);<br>    &#125;);<br>    <br>    CompletableFuture&lt;Order[]&gt; ocf  = CompletableFuture.supplyAsync(() -&gt; &#123;<br>      <span class="hljs-keyword">return</span> restTemplate.getForObject(<span class="hljs-string">&quot;http://domain/orders&quot;</span>, Order[].class);<br>    &#125;);<br>    <br>    <span class="hljs-keyword">return</span> CompletableFuture<br>            .allOf(usersFuture, productsFuture, ordersFuture)<br>            .thenApply(v -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">AggResponse</span>(ucf.join(), pcf.join(), ocf.join()));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="核心原理"><a href="#核心原理" class="headerlink" title="核心原理"></a>核心原理</h2><p>CompletableFuture实现了两个接口：<strong>Future、CompletionStage</strong>。</p><ul><li>Future表示异步计算的结果。</li><li>CompletionStage 是 Java 8 引入的一个核心接口，它定义了支持异步操作编排和组合所需的所有基本方法。它是 CompletableFuture 实现强大异步任务编排能力的关键，提供了一套标准、声明式的 API，使得复杂的异步逻辑能够以流畅、非阻塞、易于管理的方式编写。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CompletableFuture</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Future</span>&lt;T&gt;, CompletionStage&lt;T&gt; &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>CompletableFuture中包含两个字段：<strong>result和stack</strong>：</p><ul><li>result用于存储当前CF的结果；</li><li>stack（Completion）表示当前CF完成后需要触发的依赖动作（Dependency Actions），去触发依赖它的CF的计算，依赖动作可以有多个，以栈（Treiber stack）的形式存储，stack表示栈顶元素，依赖的动作（Dependency Action）都封装在一个单独Completion子类中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">volatile</span> Object result;       <span class="hljs-comment">// Either the result or boxed AltResult</span><br><span class="hljs-keyword">volatile</span> Completion stack;    <span class="hljs-comment">// Top of Treiber stack of dependent actions</span><br></code></pre></td></tr></table></figure><h3 id="Completion"><a href="#Completion" class="headerlink" title="Completion"></a>Completion</h3><p>在 CompletableFuture 中，Completion 并不是一个公共 API 接口或类，而是 CompletableFuture 类的内部抽象基类以及一系列相关的内部具体子类。它是实现链式调用（Chaining） 和 非阻塞回调（Non-blocking Callbacks） 机制的核心数据结构。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Completion</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ForkJoinTask</span>&lt;Void&gt;<br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>, AsynchronousCompletionTask &#123;<br><br>  <span class="hljs-comment">// 存储下一个任务链式调用栈。</span><br>  <span class="hljs-keyword">volatile</span> Completion next;      <span class="hljs-comment">// Treiber stack link</span><br>  <span class="hljs-keyword">abstract</span> CompletableFuture&lt;?&gt; tryFire(<span class="hljs-type">int</span> mode);<br><br>  <span class="hljs-keyword">abstract</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isLive</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span>                &#123; tryFire(ASYNC); &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exec</span><span class="hljs-params">()</span>            &#123; tryFire(ASYNC); <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Void <span class="hljs-title function_">getRawResult</span><span class="hljs-params">()</span>       &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRawResult</span><span class="hljs-params">(Void v)</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Completion主要作用是充当链表节点和回调任务的封装器，用于管理任务之间的依赖关系:</p><ul><li>表示依赖关系: 每一个 thenApply, thenAccept, thenRun 等方法调用都会创建一个新的 CompletableFuture，并将一个实现了 Completion 抽象类的实例（例如 UniCompletion、BiCompletion 等）作为回调节点附加到前一个 CompletableFuture 上。</li><li>存储回调逻辑: Completion 对象内部封装了需要在前一个任务（前驱）完成后执行的具体逻辑（例如 Function, Consumer, Runnable 等）。</li><li>实现任务编排: 当一个 CompletableFuture 完成时，它会遍历其内部的 stack 链表（由 Completion 节点组成），并触发执行所有依赖它的后续任务。</li><li>传播结果与异常: Completion 节点负责将前驱任务的结果传递给后续任务，或者将异常信息向下游传播，直到被处理。</li></ul><p><img src="/images/java-juc-CompletableFuture%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%8E%9F%E7%90%86_CompletableFuture%E9%93%BE%E5%BC%8F%E8%B0%83%E7%94%A8.png"></p><p>在上图中，CompletableFuture 内部实现，CompletableFuture.stack 和 Completion.next 共同构成了一个无锁（lock-free）的单向链表结构，用于管理依赖关系和回调任务。CompletableFuture.stack是一个 volatile 字段，类型是抽象内部类 Completion。它充当链表的头部（Head of the list），指向最近被添加到该 CompletableFuture 实例的那个 Completion 节点。而 Completion.next，充当链表节点的指针（Pointer to the next node），它指向下一个（即在此节点之前添加的）Completion 节点。</p><h3 id="以thenApply-为例分析"><a href="#以thenApply-为例分析" class="headerlink" title="以thenApply()为例分析"></a>以thenApply()为例分析</h3><p>在上图中，这个链表采用 <strong>头插法（Prepend&#x2F;Push-style）</strong> 进行维护，并且操作是线程安全的，利用了 volatile 和底层的 CAS (Compare-And-Swap) 原子操作。</p><ul><li>创建新的CompletableFuture，<code>CompletableFuture&lt;V&gt; d = newIncompleteFuture()</code></li><li><strong>添加依赖</strong>：<ul><li>一个新的 Completion 节点（比如 UniApply）被创建。</li><li>新节点的 next 字段被设置为当前 CompletableFuture 的旧 stack 头指针。<ul><li>使用 CAS 操作，尝试将 CompletableFuture 的 stack 指针更新为这个新节点。</li><li>如果 CAS 失败（说明有其他线程同时添加了节点），则重试，直到成功。</li></ul></li><li>stack 指针总是指向链表最前面的那个节点，而链表的顺序是 <strong>后进先出（LIFO）</strong> 的。</li></ul></li><li><strong>任务完成时触发</strong>（调用 complete() 或任务执行结束）:<ul><li>CompletableFuture 会调用内部方法 postComplete()。</li><li>postComplete() 会从 stack 头开始，遍历并弹出链表中的每一个 Completion 节点。</li><li>对于每个节点，它都会调用 tryFire() 方法来执行实际的回调逻辑。</li><li>在触发执行时，通过 Completion.next 指针可以依次访问到所有后续的依赖任务。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture.completedFuture(<span class="hljs-string">&quot;Hello CompletableFuture&quot;</span>).thenApply(String::toUpperCase);<br></code></pre></td></tr></table></figure><ul><li>thenApply()</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;U&gt; CompletableFuture&lt;U&gt; <span class="hljs-title function_">thenApply</span><span class="hljs-params">(</span><br><span class="hljs-params">  Function&lt;? <span class="hljs-built_in">super</span> T,? extends U&gt; fn)</span> &#123;<br>  <span class="hljs-keyword">return</span> uniApplyStage(<span class="hljs-literal">null</span>, fn);<br>&#125;<br><br><span class="hljs-keyword">private</span> &lt;V&gt; CompletableFuture&lt;V&gt; <span class="hljs-title function_">uniApplyStage</span><span class="hljs-params">(</span><br><span class="hljs-params">  Executor e, Function&lt;? <span class="hljs-built_in">super</span> T,? extends V&gt; f)</span> &#123;<br>  <span class="hljs-keyword">if</span> (f == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>  Object r;<br>  <span class="hljs-keyword">if</span> ((r = result) != <span class="hljs-literal">null</span>)<br>    <span class="hljs-keyword">return</span> uniApplyNow(r, e, f);<br>  <span class="hljs-comment">// 创建新的CompletableFuture</span><br>  CompletableFuture&lt;V&gt; d = newIncompleteFuture();<br>  <span class="hljs-comment">// 添加依赖</span><br>  unipush(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UniApply</span>&lt;T,V&gt;(e, d, <span class="hljs-built_in">this</span>, f));<br>  <span class="hljs-keyword">return</span> d;<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unipush</span><span class="hljs-params">(Completion c)</span> &#123;<br>  <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">while</span> (!tryPushStack(c)) &#123;<br>      <span class="hljs-keyword">if</span> (result != <span class="hljs-literal">null</span>) &#123;<br>        NEXT.set(c, <span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-literal">null</span>)<br>      <span class="hljs-comment">// 重点完成通知</span><br>      c.tryFire(SYNC);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>UniApply</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UniCompletion</span>&lt;T,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Completion</span> &#123;<br>  Executor executor;                 <span class="hljs-comment">// executor to use (null if none)</span><br>  CompletableFuture&lt;V&gt; dep;          <span class="hljs-comment">// the dependent to complete</span><br>  CompletableFuture&lt;T&gt; src;          <span class="hljs-comment">// source for action</span><br><br>  UniCompletion(Executor executor, <br>                CompletableFuture&lt;V&gt; dep,<br>                CompletableFuture&lt;T&gt; src) &#123;<br>      <span class="hljs-built_in">this</span>.executor = executor; <br>      <span class="hljs-built_in">this</span>.dep = dep; <br>      <span class="hljs-built_in">this</span>.src = src;<br>  &#125;<br><br>  <span class="hljs-comment">// 返回是否 action 可以执行</span><br>  <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">claim</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Executor</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> executor;<br>    <span class="hljs-keyword">if</span> (compareAndSetForkJoinTaskTag((<span class="hljs-type">short</span>)<span class="hljs-number">0</span>, (<span class="hljs-type">short</span>)<span class="hljs-number">1</span>)) &#123;<br>      <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>)<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      executor = <span class="hljs-literal">null</span>; <span class="hljs-comment">// disable</span><br>      e.execute(<span class="hljs-built_in">this</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UniApply</span>&lt;T,V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">UniCompletion</span>&lt;T,V&gt; &#123;<br>  Function&lt;? <span class="hljs-built_in">super</span> T,? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">V</span>&gt; fn;<br>  UniApply(Executor executor, CompletableFuture&lt;V&gt; dep,<br>            CompletableFuture&lt;T&gt; src,<br>            Function&lt;? <span class="hljs-built_in">super</span> T,? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">V</span>&gt; fn) &#123;<br>    <span class="hljs-built_in">super</span>(executor, dep, src); <br>    <span class="hljs-built_in">this</span>.fn = fn;<br>  &#125;<br>  <span class="hljs-comment">// 尝试去调用当前任务。uniApply()方法为核心逻辑。</span><br>  <span class="hljs-keyword">final</span> CompletableFuture&lt;V&gt; <span class="hljs-title function_">tryFire</span><span class="hljs-params">(<span class="hljs-type">int</span> mode)</span> &#123;<br>    CompletableFuture&lt;V&gt; d; CompletableFuture&lt;T&gt; a;<br>    Object r; <br>    Throwable x; <br>    Function&lt;? <span class="hljs-built_in">super</span> T,? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">V</span>&gt; f;<br>    <span class="hljs-comment">//判断源任务是否已经完成了，a表示的就是源任务，a.result就代表的是原任务的结果。</span><br>    <span class="hljs-keyword">if</span> ((a = src) == <span class="hljs-literal">null</span> || (r = a.result) == <span class="hljs-literal">null</span><br>        || (d = dep) == <span class="hljs-literal">null</span> || (f = fn) == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 验证是否出现异常结果，如有则任务执行结束</span><br>    tryComplete: <span class="hljs-keyword">if</span> (d.result == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">if</span> (r <span class="hljs-keyword">instanceof</span> AltResult) &#123;<br>        <span class="hljs-keyword">if</span> ((x = ((AltResult)r).ex) != <span class="hljs-literal">null</span>) &#123;<br>          d.completeThrowable(x, r);<br>          <span class="hljs-keyword">break</span> tryComplete;<br>        &#125;<br>        r = <span class="hljs-literal">null</span>;<br>      &#125;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 异步执行任务</span><br>        <span class="hljs-keyword">if</span> (mode &lt;= <span class="hljs-number">0</span> &amp;&amp; !claim())<br>          <span class="hljs-comment">// 任务未执行返回false</span><br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span> <br>          <span class="hljs-type">T</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> (T) r;<br>          <span class="hljs-comment">// 任务执行完成将结果写入result</span><br>          d.completeValue(f.apply(t));<br>        &#125;<br>      &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        d.completeThrowable(ex);<br>      &#125;<br>    &#125;<br>    src = <span class="hljs-literal">null</span>; dep = <span class="hljs-literal">null</span>; fn = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 当前线程执行了该任务，返回结果继续执行前一个任务</span><br>    <span class="hljs-keyword">return</span> d.postFire(a, mode);<br>  &#125;<br><br>  <span class="hljs-keyword">final</span> CompletableFuture&lt;T&gt; <span class="hljs-title function_">postFire</span><span class="hljs-params">(CompletableFuture&lt;?&gt; a, <span class="hljs-type">int</span> mode)</span> &#123;<br>    <span class="hljs-keyword">if</span> (a != <span class="hljs-literal">null</span> &amp;&amp; a.stack != <span class="hljs-literal">null</span>) &#123;<br>      Object r;<br>      <span class="hljs-keyword">if</span> ((r = a.result) == <span class="hljs-literal">null</span>)<br>        a.cleanStack();<br>      <span class="hljs-keyword">if</span> (mode &gt;= <span class="hljs-number">0</span> &amp;&amp; (r != <span class="hljs-literal">null</span> || a.result != <span class="hljs-literal">null</span>))<br>        <span class="hljs-comment">// 完成任务执行并进行出栈</span><br>        a.postComplete();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (result != <span class="hljs-literal">null</span> &amp;&amp; stack != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">// postComplete调用过来的任务已完成</span><br>      <span class="hljs-keyword">if</span> (mode &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>      <span class="hljs-keyword">else</span><br>        <span class="hljs-comment">// 完成任务执行并进行出栈</span><br>        postComplete();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>CompletableFuture 通过维护任务完成状态和回调列表，实现了基于事件驱动和回调的非阻塞异步编程模型。 </p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>juc</category>
      
      <category>并发</category>
      
      <category>线程池</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>juc</tag>
      
      <tag>并发</tag>
      
      <tag>线程池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ForkJoinPool 基础</title>
    <link href="/2025/07/15/java-juc-ForkJoinPool%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%8E%9F%E7%90%86/"/>
    <url>/2025/07/15/java-juc-ForkJoinPool%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>ForkJoinPool 是 Java 7 引入的用于并行执行“分而治之”任务的线程池，它是 ExecutorService 接口的一个特殊实现，其核心设计目标是高效地处理那些可以递归分解成更小任务的工作负载。其工作方式采取工作窃取算法，以避免工作线程由于拆分了任务之后的join等待过程，这样处于空闲的工作线程将从其他工作线程的队列中主动去窃取任务来执行。</p><span id="more"></span><h3 id="分而治之"><a href="#分而治之" class="headerlink" title="分而治之"></a>分而治之</h3><p>分治法的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题的相互独立且与原问题的性质相同，求出子问题的解之后，将这些解合并，就可以得到原有问题的解，是一种分目标完成的程序算法。</p><p><img src="/images/java-juc-ForkJoin%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%8E%9F%E7%90%86_%E5%88%86%E6%B2%BB%E9%80%BB%E8%BE%91%E5%9B%BE.png"></p><p>实现分治思想通常涉及三个步骤：</p><ul><li>分解 (Divide&#x2F;Fork)：将一个复杂的大任务拆解成多个相互独立的、更小的子任务。这个过程是递归进行的。</li><li>解决 (Conquer&#x2F;Compute)：当任务被分解到足够小，无法再拆分时（达到了预设的阈值），就直接执行这个小任务。</li><li>合并结果 (Combine&#x2F;Join)：等待所有子任务完成后，将它们的结果汇总起来，形成最终大任务的结果。</li></ul><h3 id="工作窃取算法"><a href="#工作窃取算法" class="headerlink" title="工作窃取算法"></a>工作窃取算法</h3><p>工作窃取算法的基本思想是将任务队列分配给每个线程，并通过线程间的协作来完成任务的执行。每个线程都有自己的任务队列，当一个线程执行完自己队列中的任务后，它会去其他线程的队列中窃取任务来执行。其逻辑如下：</p><ul><li>本地队列：每个线程都有一个自己的本地任务队列，用于存放待执行的任务，这些任务通常是由当前线程创建或分配的。</li><li>窃取任务：当一个线程执行完自己队列中的任务后，它会去其他线程的队列中偷取任务来执行。通常情况下，线程会选择窃取其他线程队列中的末尾位置（或近似末尾位置）的任务，因为这些任务最可能是最近添加的，即最新的任务。</li><li>动态调整：工作窃取算法具有一定的自适应性，它会根据当前系统的负载情况动态地调整任务的分配策略。例如，当一个线程的本地队列为空时，它会去窃取其他线程的任务来执行。当一个线程的本地队列过长时，它可能会主动将部分任务分配给其他线程。</li></ul><p><img src="/images/java-juc-ForkJoin%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%8E%9F%E7%90%86_%E5%B7%A5%E4%BD%9C%E7%AA%83%E5%8F%96%E7%AE%97%E6%B3%95.png"></p><p>工作窃取算法的优点是能够减少线程之间的竞争和同步开销，提高并行性能，它利用了多核处理器的特性，使得任务可以在多个处理单元上并行执行，从而提高了系统的整体吞吐量和响应速度。</p><h2 id="ForkJoinPool基础"><a href="#ForkJoinPool基础" class="headerlink" title="ForkJoinPool基础"></a>ForkJoinPool基础</h2><p>在JUC中，ForkJoinPool 的实现依赖于三个关键类：</p><ul><li><strong>ForkJoinPool</strong>: 线程池的核心管理类，负责协调和管理工作线程，实现工作窃取算法，并提供任务提交的入口。</li><li><strong>ForkJoinWorkerThread</strong>: 实际执行任务的工作线程。每个工作线程都绑定一个私有的任务队列。</li><li><strong>ForkJoinTask</strong>: 抽象的任务类，定义了 fork()（提交子任务）和 join()（等待子任务完成并合并结果）等操作。开发者通常继承其子类 RecursiveAction 或 RecursiveTask 来实现具体的业务逻辑。</li></ul><p>一般我们要定义Fork&#x2F;Join任务是直接继承ForkJoinTask的子类，Fork&#x2F;Join框架提供了两个子类：</p><ul><li>RecursiveAction：递归无结果的ForkJoinTask——没有返回值任务(类似于 Runnable)。</li><li>RecursiveTask：递归有结果的ForkJoinTask——有返回值任务(类似于 Callable)。</li></ul><p>ForkJoinPool的核心功能：</p><ul><li>管理工作线程：ForkJoinPool会管理一组ForkJoinWorkerThread，这些工作线程用于执行提交给线程池的任务。</li><li>自适应并行度：默认情况下，线程池的并行度（parallelism）与可用的处理器数量相等，从而最大限度地利用硬件资源。</li><li>高效调度：它不依赖操作系统调度，而是通过其内部的工作窃取算法来高效地调度任务。</li></ul><p>ForkJoinPool 提交任务方法：<br><img src="/images/java-juc-ForkJoin%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%8E%9F%E7%90%86_ForkJoinPool%E4%BB%BB%E5%8A%A1%E6%8F%90%E4%BA%A4%E6%96%B9%E6%B3%95.png"></p><h3 id="基于-ForKJoinTask-实现-Fibonacci计算，使用Fork-Join框架实现一个计算Fibonacci任务"><a href="#基于-ForKJoinTask-实现-Fibonacci计算，使用Fork-Join框架实现一个计算Fibonacci任务" class="headerlink" title="基于 ForKJoinTask 实现 Fibonacci计算，使用Fork&#x2F;Join框架实现一个计算Fibonacci任务"></a>基于 ForKJoinTask 实现 Fibonacci计算，使用Fork&#x2F;Join框架实现一个计算Fibonacci任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseForkJoinExample</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>    <span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>(<span class="hljs-number">4</span>);<br>    <span class="hljs-comment">//Integer result = pool.submit(new FibonacciTask(n)).join();</span><br>    <span class="hljs-comment">// invoke 为同步提交任务，与submit().join()等价</span><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> pool.invoke(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FibonacciTask</span>(n));<br>    System.out.println(<span class="hljs-string">&quot;result = &quot;</span> + result);<br>    pool.shutdown();<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FibonacciTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;Integer&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FibonacciTask</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>      <span class="hljs-built_in">this</span>.n = n;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// 算法逻辑.......</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于上的 compute() 方法有如下几种实现：</p><ol><li><strong>fork() + compute() + join()</strong>:</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;<br><br>  <span class="hljs-type">FibonacciTask</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FibonacciTask</span>(n - <span class="hljs-number">1</span>);<br>  <span class="hljs-type">FibonacciTask</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FibonacciTask</span>(n - <span class="hljs-number">2</span>);<br><br>  <span class="hljs-comment">// 1. 手动将 left 任务推入队列（供窃取）</span><br>  left.fork(); <br>  <br>  <span class="hljs-comment">// 2. 手动让当前线程执行 right 任务</span><br>  <span class="hljs-type">Integer</span> <span class="hljs-variable">rightResult</span> <span class="hljs-operator">=</span> right.compute(); <br>  <br>  <span class="hljs-comment">// 3. 手动等待 left 任务（如果需要）</span><br>  <span class="hljs-type">Integer</span> <span class="hljs-variable">leftResult</span> <span class="hljs-operator">=</span> left.join(); <br>  <span class="hljs-comment">// 4. 合并</span><br>  <span class="hljs-keyword">return</span> leftResult + rightResult;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码执行时，当前线程将 left 任务提交到队列，然后它自己并不等待，而是立即开始通过 right.compute() 同步地计算 right 任务。该线程没有被浪费，它在积极地完成一半的工作（计算 right）。与此同时，left 任务在队列中，可以被线程池中的另一个空闲线程“窃取”(work-stealing) 并行执行。这是 Fork&#x2F;Join 框架推荐的标准模式。它实现了<strong>一个任务（left）异步化，另一个任务（right）本地化</strong>，从而最大化地利用了 CPU 资源，避免了不必要的线程阻塞。</p><p><font color=red>注意：为了实现更好的负载均衡，并减少窃取开销，总是 fork() 那个计算量更大的任务，compute() 那个计算量更小的任务。在上面代码中left &#x3D; new FibonacciTask(n - 1) 任务更大，right &#x3D; new FibonacciTask(n - 2) 任务更小</font>。为什么呢？这是因为 <strong>工作窃取(Work-Stealing)机制</strong> ：</p><ul><li>fork() 的作用： 当一个工作线程（Worker Thread）调用 task.fork()，它会将这个 task 放入自己的工作队列（一个双端队列，Deque）中。这个任务现在就可以被其他空闲线程窃取。</li><li>compute() 的作用： 线程自己立即开始执行这个任务。</li><li>窃取的发生： 当一个线程 A 变得空闲时（它完成了自己的所有工作），它会随机查看另一个线程 B 的工作队列，并从队列的另一端窃取一个任务来执行。</li></ul><p>因此：在 Fork&#x2F;Join 模式中，更优的做法是：</p><ul><li>把最大的那份工作 fork() 出去（推到队列里），让最有空的“同事”（其他线程）去认领。</li><li>你自己立即开始 compute() 最小的那份工作，以保持自己忙碌。</li></ul><p>这样可以确保偷窃者（Idle Threads）总能拿到“值得偷”的大块任务，从而最大限度地减少了它们在“寻找工作”上花费的开销，实现了最高效的负载均衡。</p><ol start="2"><li><strong>invokeAll()+join()+join()</strong>:</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> n;<br><br>  <span class="hljs-type">FibonacciTask</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FibonacciTask</span>(n - <span class="hljs-number">1</span>);<br>  <span class="hljs-type">FibonacciTask</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FibonacciTask</span>(n - <span class="hljs-number">2</span>);<br><br>  <span class="hljs-comment">// 1. 自动并行执行 left 和 right，并 *阻塞* 直到它们都完成</span><br>  invokeAll(left, right);<br><br>  <span class="hljs-comment">// 2. 合并：此时 .join() 只是获取结果，不会阻塞，因为 invokeAll 已经保证它们都完成了。</span><br>  <span class="hljs-keyword">return</span> left.join() + right.join();<br>&#125;<br></code></pre></td></tr></table></figure><p>ForkJoinTask.invokeAll() 是一个静态辅助方法，专门用于简化<strong>执行一组子任务并等待它们全部完成</strong>的场景。一行代码完成了<strong>分支、执行、等待</strong>三件事，invokeAll() 本质上就是 fork&#x2F;compute&#x2F;join 模式的官方封装。在绝大多数情况下，优先使用 invokeAll()。它更安全、更简洁，可读性更高，并且性能与fork&#x2F;compute&#x2F;join 模式所能达到的效果一样好。只有在极少数需要“非对称”处理的复杂场景下（例如，fork(left) 之后，不需要 compute(right)，而是想在 join(left) 之前执行一些完全不同的逻辑），才需要回退到手动的 fork&#x2F;compute&#x2F;join 模式。</p><ol start="3"><li><strong>fork() + fork() + join() + join()</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">return</span> n;<br>  &#125;<br>  <span class="hljs-type">FibonacciTask</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FibonacciTask</span>(n - <span class="hljs-number">1</span>);<br>  <span class="hljs-comment">// 1. 将 left 任务提交到队列</span><br>  left.fork();<br>  <span class="hljs-type">FibonacciTask</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FibonacciTask</span>(n - <span class="hljs-number">2</span>);<br>  <span class="hljs-comment">// 2. 将 right 任务也提交到队列</span><br>  right.fork();<br>  <span class="hljs-comment">// 3. 阻塞等待 left</span><br>  <span class="hljs-type">Integer</span> <span class="hljs-variable">leftResult</span> <span class="hljs-operator">=</span> left.join();<br>  <span class="hljs-comment">// 4. 阻塞等待 right</span><br>  <span class="hljs-type">Integer</span> <span class="hljs-variable">rightResult</span> <span class="hljs-operator">=</span> right.join();<br>  <span class="hljs-comment">// 5. 合并</span><br>  <span class="hljs-keyword">return</span> leftResult + rightResult;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码执行时，当前线程（一个 Worker 线程）将 left 任务和 right 任务都提交到工作队列中，期望其他线程去执行它们。但是这里导致一个问题：提交任务后，<strong>当前线程立即调用 left.join() 进入阻塞（waiting）状态</strong>，它什么也不做，只是干等着 left 任务完成。本来这个 Worker 线程本可以用来执行 right 任务，但它却被浪费在等待上了，如果所有线程都像这样 fork 完就 join，线程池中的线程会很快全部进入等待状态，导致没有活动线程来实际执行队列中的任务——<strong>“线程饥饿” (Thread Starvation)</strong>。</p><h3 id="自定义-ForkJoinWorkerThreadFactory"><a href="#自定义-ForkJoinWorkerThreadFactory" class="headerlink" title="自定义 ForkJoinWorkerThreadFactory"></a>自定义 ForkJoinWorkerThreadFactory</h3><p>ForkJoinPool.ForkJoinWorkerThreadFactory 的作用是为 ForkJoinPool 创建其内部的工作线程 (ForkJoinWorkerThread)。它是一个接口，定义了创建新线程的方法，使得开发者能够控制 ForkJoinPool 中工作线程的特性:</p><ul><li>自定义工作线程属性: 允许开发者设置工作线程的名称、优先级、守护状态 (daemon status) 和异常处理器等。</li><li>集成安全管理器 (SecurityManager): 在有安全管理器运行的环境中，工厂负责创建具有正确安全上下文和权限的工作线程。ForkJoinPool 的默认工厂 defaultForkJoinWorkerThreadFactory 就是一个能处理此情况的例子。</li><li>扩展 ForkJoinWorkerThread: 允许开发者使用自定义的 ForkJoinWorkerThread 子类。这对于需要在工作线程启动时执行额外初始化逻辑或存储线程本地状态的场景非常有用。</li><li>解耦线程创建逻辑: 将线程池的核心调度逻辑与具体的线程创建细节分离，提高了代码的模块化和灵活性。</li></ul><p>下面示例是通过自定义 CustomWorkerThreadFactory 实现在ForkJoinPool中MDC上下文传递。其主要在 onStart() 将父线程的 traceId 传递给子线程，在 onTermination() 中进行清理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomWorkerThreadFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ForkJoinWorkerThreadFactory</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String namePrefix;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">poolNumber</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">threadNumber</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">1</span>);<br>  <br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Map&lt;String, String&gt; inheritedMdc;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">CustomWorkerThreadFactory</span><span class="hljs-params">(String namePrefix)</span> &#123;<br>    <span class="hljs-built_in">this</span>.namePrefix = namePrefix + <span class="hljs-string">&quot;-&quot;</span> + poolNumber.getAndIncrement() + <span class="hljs-string">&quot;-worker-&quot;</span>;<br>    <span class="hljs-built_in">this</span>.inheritedMdc = MDC.getCopyOfContextMap();<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> ForkJoinWorkerThread <span class="hljs-title function_">newThread</span><span class="hljs-params">(ForkJoinPool pool)</span> &#123;<br>    <span class="hljs-type">ForkJoinWorkerThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultForkJoinWorkerThread</span>(pool);<br>    thread.setName(namePrefix + threadNumber.getAndIncrement());<br>    <span class="hljs-keyword">return</span> thread;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultForkJoinWorkerThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ForkJoinWorkerThread</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">DefaultForkJoinWorkerThread</span><span class="hljs-params">(ForkJoinPool forkJoinPool)</span> &#123;<br>      <span class="hljs-built_in">super</span>(forkJoinPool);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onStart</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-built_in">super</span>.onStart();<br>      <span class="hljs-comment">// 在线程启动时复制 MDC 上下文</span><br>      <span class="hljs-keyword">if</span> (inheritedMdc != <span class="hljs-literal">null</span>) &#123;<br>        MDC.setContextMap(inheritedMdc);<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onTermination</span><span class="hljs-params">(Throwable exception)</span> &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 在线程结束时清理 MDC 上下文</span><br>        MDC.clear();<br>        inheritedMdc.clear();<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-built_in">super</span>.onTermination(exception);<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">parallelism</span> <span class="hljs-operator">=</span> Runtime.getRuntime().availableProcessors();<br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; parallelism; i++) &#123;<br>    MDC.put(<span class="hljs-string">&quot;traceId&quot;</span>, System.currentTimeMillis() + <span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-type">ForkJoinWorkerThreadFactory</span> <span class="hljs-variable">threadFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomWorkerThreadFactory</span>(<span class="hljs-string">&quot;test-thread-factory&quot;</span> + (i + <span class="hljs-number">1</span>));<br>    <span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">forkJoinPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>(parallelism, threadFactory, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);<br>    logger.info(<span class="hljs-string">&quot;mani thread:&#123;&#125;&quot;</span>, Thread.currentThread().getName());<br>    forkJoinPool.invoke(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FibonacciTask</span>(<span class="hljs-number">5</span>));<br>  &#125;<br>  MDC.remove(<span class="hljs-string">&quot;traceId&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ForkJoinTask执行流程"><a href="#ForkJoinTask执行流程" class="headerlink" title="ForkJoinTask执行流程"></a>ForkJoinTask执行流程</h3><ul><li><p><strong>提交 (Submission)</strong>：外部客户端（例如 main 线程）创建一个 ForkJoinPool，然后调用其 invoke(RootTask) 或 execute(RootTask) 方法来提交一个“根任务”。ForkJoinPool 接收到这个任务，并将其放入一个全局等待队列中，或者直接分配给一个空闲的工作线程。</p></li><li><p><strong>执行与分支 (Execution &amp; Fork)</strong>：一个工作线程（比如 线程 A）获得了这个 RootTask 并开始执行它的 compute() 方法。在 compute() 内部（标准模式）：</p><ul><li><strong>检查基准条件</strong>：任务首先检查自己是否已经“足够小”，小到不需要再拆分（例如，n &lt;&#x3D; 1）。如果是，则直接计算并返回结果。</li><li><strong>拆分 (Divide)</strong>：如果任务太大，它会拆分为两个（或更多）子任务，例如 LeftTask 和 RightTask。</li><li><strong>left.fork()</strong>：线程 A 调用 LeftTask.fork()。线程 A 会将 LeftTask 推入 (push) 到它自己的本地工作队列的底部 (bottom&#x2F;head)。这相当于说：“我稍后会处理这个，或者谁闲了就来拿吧。”</li><li><strong>right.compute()</strong>：线程 A 不会 fork 右边的任务，而是立即开始同步递归地执行 RightTask.compute()。</li></ul></li><li><p><strong>工作窃取 (Work-Stealing)</strong>：此时，线程 B（池中的另一个工作线程）完成了它所有的工作，它的本地队列空了。线程 B 变为空闲状态，它不能闲着。它会随机挑选另一个工作线程（比如 线程 A）。线程 B 会查看 线程 A 的队列，并从队列的顶部 (top&#x2F;tail) “窃取” (steal) 一个任务。使用<strong>一端推另一端偷</strong>可以最大限度地减少线程间的竞争，两个线程操作队列的不同端。线程 B 拿到了 LeftTask 并开始执行它的 compute() 方法。现在，LeftTask 和 RightTask（的一部分）就在并行执行了。</p></li><li><p><strong>合并 (Join)</strong>：如果线程 A 完成了 right.compute() 以及它的所有子任务。left.join() 线程 A 获取LeftTask 的结果。join()过程会检查状态，线程 A 首先检查 LeftTask 是否已经完成：</p><ul><li>已被窃取且已完成：如果 LeftTask 已被线程 B 偷走并执行完毕，join() 会立即获取结果并返回。</li><li>仍在队列中（未被窃取）：如果 LeftTask 仍然在线程 A 自己的队列中（没有线程来偷），线程 A 会将其从队列中取出并自己执行它。</li><li>已被窃取但未完成：如果 LeftTask 正被线程 B 执行，线程 A 通常也不会立即阻塞。它会先尝试执行自己队列中的其他任务，或者去“帮助”执行其他被偷的任务。在万不得已时（实在没事干了），它才会真正地阻塞 (block) 等待。</li></ul></li><li><p><strong>返回 (Conquer)</strong>：线程 A 获得了 LeftTask 和 RightTask 的结果，将它们合并。RootTask 的 compute() 方法执行完毕，返回最终结果。main 线程的 invoke() 调用结束，获得最终结果。</p></li></ul><h3 id="FonkJoinPool-适用场景"><a href="#FonkJoinPool-适用场景" class="headerlink" title="FonkJoinPool 适用场景"></a>FonkJoinPool 适用场景</h3><p>ForkJoinPool 是 Java 7 引入的一个专为并行执行可分解任务而设计的线程池，它主要用于实现“分而治之”的算法。其核心原理是工作窃取 (work-stealing) 算法，旨在充分利用多核 CPU 资源，提高并行计算效率。 ForkJoinPool 最适合处理计算密集型且符合分治思想的任务，它不是为了替代 ThreadPoolExecutor，而是其补充。 其适用场景：</p><ul><li>大规模数据处理<ul><li>数组求和或查找：计算大型数组中所有元素的总和，或查找特定元素。</li><li>图像处理：对图像的不同区域进行并行处理，例如应用滤镜、调整色彩或进行变换。</li><li>大数据分析：将海量数据集分解成小块，并行进行分析、聚合或转换操作。</li></ul></li><li>递归算法优化<ul><li>并行排序：将传统的“分而治之”排序算法（如快速排序和归并排序）并行化，提升处理大规模数据集的效率。</li><li>树状结构遍历：并行遍历树形结构，可以用于文件系统搜索、XML解析等。</li></ul></li><li>科学计算和模拟<ul><li>矩阵运算：将大型矩阵的乘法、加法等运算分解为子任务，并行执行。</li><li>数值模拟：在各种需要大量计算的科学和工程模拟中，将计算任务并行化。</li></ul></li><li>Java Stream API 的底层支持——并行流（Parallel Streams）：Java 8及以上版本的并行流API在底层就是使用ForkJoinPool来执行并行操作。例如，对一个集合进行parallelStream()操作，就会自动使用ForkJoin框架。</li></ul><p>然而对于<strong>I&#x2F;O 密集型任务、任务粒度过小、任务之间强依赖性</strong>的任务并不适用：</p><ul><li><strong>I&#x2F;O 密集型任务</strong>：如果任务涉及大量的阻塞 I&#x2F;O 操作（如网络请求、文件读写），线程可能会长时间阻塞，这会严重影响 ForkJoinPool 的性能和并行度。</li><li><strong>任务粒度过小</strong>：如果子任务太小，fork() 和 join() 操作以及任务管理的开销可能会超过并行执行带来的收益。</li><li><strong>任务之间强依赖性</strong>：如果子任务之间需要频繁通信或相互等待，工作窃取机制的效率会降低。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>juc</category>
      
      <category>并发</category>
      
      <category>线程池</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>juc</tag>
      
      <tag>并发</tag>
      
      <tag>线程池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java线程池实现</title>
    <link href="/2025/07/13/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/"/>
    <url>/2025/07/13/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>线程池 Thread Pool 是一种基于池化思想管理线程的工具，线程池维护多个线程，等待管理者分配可并发执行的任务：</p><ul><li>一方面避免了处理任务时创建销毁线程开销的代价，</li><li>另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。</li></ul><span id="more"></span><p>合理地使用线程池有如下优点：</p><ul><li><strong>降低资源消耗</strong>：通过重复利用已创建的线程降低线程创建和销毁造成的消耗；</li><li><strong>提高响应速度</strong>：当任务达到时，任务可以不需要等到线程创建就能立即执行；</li><li><strong>提高线程的可管理性</strong>：线程资源是稀缺的，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</li></ul><h2 id="ThreadPoolExecutor基础与使用"><a href="#ThreadPoolExecutor基础与使用" class="headerlink" title="ThreadPoolExecutor基础与使用"></a>ThreadPoolExecutor基础与使用</h2><p>在java中 <strong>ThreadPoolExecutor</strong> 是核心的线程池实现，这个类实现了一个线程池需要的各个方法，它实现了任务提交、线程管理、监控等等方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                          TimeUnit unit,</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                          ThreadFactory threadFactory,</span><br><span class="hljs-params">                          RejectedExecutionHandler handler)</span>&#123;&#125;<br></code></pre></td></tr></table></figure><p><strong>线程池核心参数</strong></p><ul><li><strong>corePoolSize</strong>：核心线程数。线程池在创建后，会一直保持这个数量的线程。当有任务提交时，如果当前运行的线程数小于corePoolSize，线程池会创建一个新的核心线程来执行任务。</li><li><strong>maximumPoolSize</strong>：最大线程数。线程池中允许创建的最大线程数。当工作队列已满，且当前运行的线程数小于maximumPoolSize时，线程池会创建新的非核心线程来执行任务。</li><li><strong>keepAliveTime</strong>：非核心线程空闲时间。当线程池中的线程数量超过corePoolSize时，如果某个线程空闲时间超过keepAliveTime，它就会被终止，直到线程数量回到corePoolSize。</li><li><strong>TimeUnit unit</strong>：keepAliveTime的时间单位。</li><li><strong>BlockingQueue workQueue</strong>：任务队列。当核心线程都在忙碌时，新提交的任务会被放入这个队列中等待执行。</li><li><strong>ThreadFactory threadFactory</strong>：线程工厂。用于创建新线程。</li><li><strong>RejectedExecutionHandler handler</strong>：拒绝策略。当线程池和工作队列都已满时，用于处理新任务的策略。</li></ul><h3 id="BlockingQueue阻塞队列"><a href="#BlockingQueue阻塞队列" class="headerlink" title="BlockingQueue阻塞队列"></a>BlockingQueue阻塞队列</h3><p>Java线程池（ThreadPoolExecutor）常用的几种阻塞队列类型如下：</p><ul><li><p>ArrayBlockingQueue</p><ul><li>实现：基于数组实现有界的阻塞队列，遵循 FIFO（先进先出）原则。</li><li>队列满时: 当队列已满，提交任务的线程会被阻塞，直到队列有可用空间。</li><li>公平性: 构造函数可选择是否启用公平策略。公平模式下，等待时间最长的线程优先获得队列访问权。</li><li>适用场景: 任务提交和处理速度都可控，需要限制等待任务数量以控制系统资源的场景。</li></ul></li><li><p>LinkedBlockingQueue</p><ul><li>实现：基于链表实现的可选有界（默认无界）的阻塞队列。</li><li>无界模式: 如果不指定容量，LinkedBlockingQueue 的最大容量为 Integer.MAX_VALUE。当核心线程数已满时，所有新任务都会进入此队列。由于队列无限大，永远不会触发最大线程数的创建，也不会执行拒绝策略。这可以防止任务被拒绝，但如果任务处理速度跟不上，可能导致内存溢出。</li><li>有界模式: 在构造时可指定容量，例如 new LinkedBlockingQueue&lt;&gt;(100)。此时，它类似于 ArrayBlockingQueue，在队列满时会阻塞生产者。</li><li>适用场景: 任务提交速度相对稳定，且任务量不会瞬间暴增，或者希望任务队列尽可能容纳所有任务的场景。</li></ul></li><li><p>SynchronousQueue：一个没有容量的阻塞队列，每次插入操作都必须等待另一个线程的移除操作。</p><ul><li>直接交付: 任务提交后不会被存储在队列中，而是直接交付给工作线程。如果没有空闲线程，会立即创建一个新线程（不超过 maximumPoolSize）来执行任务。</li><li>即时执行: 这种“手递手”的模式确保了任务提交后能被立即处理，但可能导致线程数快速增长。</li><li>适用场景: 高响应性要求，需要快速处理突发性任务，且 maximumPoolSize 足够大以避免拒绝任务的场景。newFixedThreadPool 和 newCachedThreadPool 在内部就使用了 SynchronousQueue。</li></ul></li><li><p><font color=red>LinkedTransferQueue：TransferQueue 接口的一个无界、非阻塞、线程安全的实现。</font></p><ul><li>融合了 SynchronousQueue 的即时传递特性和 LinkedBlockingQueue 的链表队列特性，并且使用 <strong>无锁（CAS操作）</strong> 的方式来最大化并发性能。</li><li>无界： 逻辑上无容量限制。</li><li>高效传输： 结合了 SynchronousQueue 的即时传输能力和 LinkedBlockingQueue 的队列能力，性能极高。transfer() 方法，生产者可以阻塞等待消费者接收，实现零缓冲区的同步交付。</li><li>适用场景：适用于需要低延迟、高并发消息传递的场景。</li></ul></li><li><p>PriorityBlockingQueue：一个无界的阻塞队列，其中元素根据其自然排序或指定的 Comparator 进行排序。</p><ul><li>优先级: 队列中的任务不是按照 FIFO 顺序执行，而是按照优先级顺序执行。</li><li>无界: 类似 LinkedBlockingQueue 的无界模式，maximumPoolSize 无效，且任务不会被拒绝，但可能导致内存问题。</li><li>适用场景: 需要根据任务的优先级来安排执行顺序，而不是简单的 FIFO 顺序的场景。</li></ul></li><li><p>DelayQueue（少用于线程池，但也是阻塞队列的一种）</p><ul><li>一个无界阻塞队列，只在元素的延迟时间到期时才允许取出元素。</li><li>延迟执行: 放入 DelayQueue 的元素必须实现 Delayed 接口，该接口定义了任务的延迟时间。只有当队列中的任务到期时，消费者才能取出并执行该任务。</li><li>适用场景: 需要延时执行任务的场景，例如定时任务调度、缓存过期清理等。</li></ul></li></ul><p><font color=blue>线程池最常用的是前三种：ArrayBlockingQueue、LinkedBlockingQueue 和 SynchronousQueue。可以通过ThreadPoolExecutor的构造函数自定义队列类型，实现不同的任务调度策略。</font></p><h4 id="基于LinkedTransferQueue实现ThreadPoolExecutor自定义队列："><a href="#基于LinkedTransferQueue实现ThreadPoolExecutor自定义队列：" class="headerlink" title="基于LinkedTransferQueue实现ThreadPoolExecutor自定义队列："></a><strong>基于LinkedTransferQueue实现ThreadPoolExecutor自定义队列：</strong></h4><p>LinkedTransferQueue 实现了一个基于链接节点的、线程安全的 TransferQueue 接口，该队列中的元素可以在生产者线程和消费者线程之间高效传输，LinkedTransferQueue 通常用于需要高效、线程安全的数据传输的场景，尤其是当生产和消费速率不一致时。</p><p>相较于SynchronousQueue，区别在于通用性、内部缓冲能力、并发实现方式:</p><ul><li>SynchronousQueue 是一个纯粹的握手（handoff）机制。它就像一个接力棒交换点，生产者扔出任务的同时，必须有消费者准备接住，否则双方都会阻塞。它永远不会在内部存储元素。如果需要一个简单的、高效的、零容量的线程间直接数据交换点时，例如 Executors.newCachedThreadPool() 的默认队列。</li><li><font color=red>LinkedTransferQueue则更灵活。如果调用 put() 或 offer() 方法，且当前没有等待的消费者，它会将元素像普通队列一样存储在内部链表中。只有在使用 transfer() 方法时，才会强制执行即时传递的阻塞行为。如果需要一个更通用的消息传递工具，它可以根据情况动态选择是即时传递（低延迟）还是排队缓冲（高吞吐量），并且需要极致的并发性能时。 </font></li></ul><p>和LinkedBlockingQueue相比，LinkedTransferQueue有更好的性能。LinkedTransferQueue采用 <strong>无锁（Lock-Free）</strong> 算法，完全依赖于底层的 CAS (Compare-And-Swap) 原子操作来更新链表节点和指针。这消除了锁带来的开销和竞争，尤其是在多核处理器环境下，性能通常远超 LinkedBlockingQueue。而LinkedBlockingQueue使用了两把独立的 ReentrantLock 锁 (takeLock 和 putLock) 来保护队列的头部和尾部。生产者和消费者可以在不同的锁下并行操作，例如，一个线程在添加元素到队尾，另一个线程在从队头移除元素，但在高并发生产者之间或高并发消费者之间仍然存在锁竞争。</p><ul><li>LinkedBlockingQueue: 适合传统的生产者-消费者模型，需要一个稳定的缓冲区来平衡不同生产&#x2F;消费速率的场景。它提供了容量控制（有界队列可以防止内存耗尽）。</li><li>LinkedTransferQueue: 适用于高性能的消息传递、事件驱动架构或需要低延迟同步通信的场景。它的无界特性意味着需要自行管理任务堆积导致的内存使用。下面是一个基于LinkedTransferQueue容量限制的队列实现：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WorkerQueue</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">LinkedTransferQueue</span>&lt;Runnable&gt; &#123;<br><br>  <span class="hljs-keyword">private</span> DefaultThreadPoolExecutor executor;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setExecutor</span><span class="hljs-params">(DefaultThreadPoolExecutor executor)</span> &#123;<br>    <span class="hljs-built_in">this</span>.executor = executor;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">force</span><span class="hljs-params">(Runnable o)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!executor.isShutdown()) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RejectedExecutionException</span>(<br>          <span class="hljs-string">&quot;Executor not running, can&#x27;t force a command into the queue&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.offer(o);<br>  &#125;<br><br>  <span class="hljs-comment">// 仿tomcat TaskQueue</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(<span class="hljs-meta">@Nonnull</span> Runnable runnable)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">poolSize</span> <span class="hljs-operator">=</span> executor.getPoolSize();<br><br>    <span class="hljs-comment">// 当线程数达到最大线程数时，新提交任务入队</span><br>    <span class="hljs-keyword">if</span> (poolSize == executor.getMaximumPoolSize()) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.offer(runnable);<br>    &#125;<br><br>    <span class="hljs-comment">// 当提交的任务数小于线程池中已有的线程数时，即有空闲线程，任务入队即可</span><br>    <span class="hljs-keyword">if</span> (executor.getSubmittedTasksCount().get() &lt;= poolSize) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.offer(runnable);<br>    &#125;<br><br>    <span class="hljs-comment">// 如果当前线程数量未达到最大线程数，直接返回false，让线程池创建新线程</span><br>    <span class="hljs-keyword">if</span> (poolSize &lt; executor.getMaximumPoolSize()) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 最后的兜底，放入队列</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.offer(runnable);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ThreadFactory"><a href="#ThreadFactory" class="headerlink" title="ThreadFactory"></a>ThreadFactory</h3><p>ThreadFactory 表示线程工厂，用于指定为线程池创建新线程的方式，threadFactory可以设置线程名称、线程组、优先级等参数。在jdk中，ThreadFactory 是一个接口，在使用时需要自己实现，下面是一个自定义ThreadFactory实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultThreadFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ThreadFactory</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">poolId</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String prefix;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> daemon;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> priority;<br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> ThreadGroup group;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">DefaultThreadFactory</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-built_in">this</span>(name, <span class="hljs-literal">false</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">DefaultThreadFactory</span><span class="hljs-params">(String name, <span class="hljs-type">boolean</span> daemon)</span> &#123;<br>    <span class="hljs-built_in">this</span>(name, daemon, Thread.NORM_PRIORITY, <span class="hljs-literal">null</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">DefaultThreadFactory</span><span class="hljs-params">(String name, <span class="hljs-type">boolean</span> daemon, ThreadGroup group)</span> &#123;<br>    <span class="hljs-built_in">this</span>(name, daemon, Thread.NORM_PRIORITY, group);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">DefaultThreadFactory</span><span class="hljs-params">(String name, <span class="hljs-type">boolean</span> daemon, <span class="hljs-type">int</span> priority, ThreadGroup group)</span> &#123;<br>    <span class="hljs-built_in">this</span>.prefix = name + <span class="hljs-string">&quot;-&quot;</span> + poolId.incrementAndGet() + <span class="hljs-string">&quot;-thread-&quot;</span>;<br>    <span class="hljs-built_in">this</span>.daemon = daemon;<br>    <span class="hljs-built_in">this</span>.priority = priority;<br>    <span class="hljs-built_in">this</span>.group = group;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable runnable)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(group, runnable, prefix + threadId.incrementAndGet(), <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (thread.isDaemon() != daemon) &#123;<br>      thread.setDaemon(daemon);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (thread.getPriority() != priority) &#123;<br>      thread.setPriority(priority);<br>    &#125;<br>    <span class="hljs-keyword">return</span> thread;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过实现ThreadFactory接口，我们可以完全控制线程的创建过程，使其更适合特定的应用场景：</p><ul><li>需要为线程池中的线程提供有意义的名称时。</li><li>需要统一配置线程属性时。</li><li>需要跟踪线程创建情况时。</li><li>需要为线程添加特殊的异常处理时。</li></ul><h3 id="RejectedExecutionHandler"><a href="#RejectedExecutionHandler" class="headerlink" title="RejectedExecutionHandler"></a>RejectedExecutionHandler</h3><p>Java 线程池 ThreadPoolExecutor 在无法处理新提交的任务时（即线程池已满，且工作队列也已满），会使用 RejectedExecutionHandler 定义的拒绝策略进行处理。Java提供了四种内置的拒绝策略，都在ThreadPoolExecutor.AbortPolicy等静态类中： </p><ul><li><p>AbortPolicy(中止策略)：</p><ul><li>默认策略。直接抛出 RejectedExecutionException 运行时异常，调用者线程可以捕获这个异常，并进行相应处理。</li><li>适用场景：<ul><li>关键任务场景： 当系统负载已满，且新任务非常重要，不允许被静默丢弃时。</li><li>快速失败： 需要立即感知到系统容量已满，并及时向上游反馈或记录日志。</li></ul></li></ul></li><li><p>CallerRunsPolicy：由提交任务的线程（调用者）自己来执行这个任务。</p><ul><li>不抛弃任务，而是将任务回退到调用该线程池的线程中执行。例如，在 main 线程提交任务，如果线程池满了，该任务就在 main 线程中执行。</li><li>适用场景：<ul><li>减缓生产速度： 当上游任务的生产者线程开始执行自己的任务时，它会被阻塞或减慢提交速度，从而实现了天然的“反压”（Backpressure）机制，平衡了系统的负载。</li><li><strong>保障任务不丢失</strong>： 确保每一个任务都会被执行，但会增加调用者线程的负担。</li></ul></li></ul></li><li><p>DiscardPolicy(丢弃策略)：</p><ul><li>默默地丢弃新提交的任务，不做任何处理，也不抛出异常。</li><li>适用场景：<ul><li>非关键任务：适用于那些不重要、丢失了也无妨的日志记录、统计信息收集等任务。</li><li>允许数据丢失的监控系统：在高并发场景下，少量数据丢失可以接受，以保障核心系统的稳定性。</li></ul></li></ul></li><li><p>DiscardOldestPolicy(丢弃最老策略)</p><ul><li>丢弃工作队列中等待时间最长的那个任务（队列头部的任务），然后尝试重新提交当前新任务。如果重新提交失败（例如队列还是满的或线程池已关闭），则继续尝试或失败。</li><li>适用场景：<ul><li>时效性任务： 适用于需要处理最新数据、而旧数据价值不大的场景（例如实时行情数据、传感器最新读数）。</li><li>保持队列最新： 确保队列中保存的任务具有较高的时效性。</li></ul></li></ul></li></ul><p>如果需要自定义丢弃策略可以实现 RejectedExecutionHandler 接口，创建自定义的拒绝逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomRejectedExecutionHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RejectedExecutionHandler</span> &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor executor)</span> &#123;<br>    <span class="hljs-comment">// 在这里实现自定义逻辑，例如：记录日志、将任务保存到数据库或消息队列，稍后重试或发送邮件或告警通知</span><br>    System.out.println(<span class="hljs-string">&quot;Task Rejected: &quot;</span> + r.toString());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color=red>注意：在选择拒绝策略时，需要权衡任务的重要性、系统的稳定性和性能。</font></p><h3 id="自定义-ThreadPoolExecutor-实现"><a href="#自定义-ThreadPoolExecutor-实现" class="headerlink" title="自定义 ThreadPoolExecutor 实现"></a>自定义 ThreadPoolExecutor 实现</h3><ul><li>自定义WorkQueue - 前面基于 LinkedTransferQueue 实现有界队列</li><li>自定义ThreadFactory -  前面实现的 DefaultThreadFactory</li><li>自定义RejectedExecutionHandler - 前面的示例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultThreadPoolExecutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadPoolExecutor</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAXIMUM_POOL_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">200</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">KEEP_ALIVE_TIME</span> <span class="hljs-operator">=</span> <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CORE_POOL_SIZE</span> <span class="hljs-operator">=</span> Runtime.getRuntime().availableProcessors() + <span class="hljs-number">1</span>;<br><br>  <span class="hljs-comment">// 正在处理的任务数</span><br>  <span class="hljs-meta">@Getter</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">submittedTasksCount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-comment">// 最大允许同时处理的任务数</span><br>  <span class="hljs-meta">@Getter</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> maxTask;<br><br>  <span class="hljs-comment">// 其他构造方法省略</span><br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">DefaultThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize, <span class="hljs-type">int</span> maximumPoolSize, <span class="hljs-type">int</span> queueCapacity,</span><br><span class="hljs-params">      <span class="hljs-type">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">      ThreadFactory threadFactory, RejectedExecutionHandler handler)</span> &#123;<br><br>    <span class="hljs-built_in">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);<br>    ((WorkerQueue) getQueue()).setExecutor(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-built_in">this</span>.maxTask = maximumPoolSize + queueCapacity;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(<span class="hljs-meta">@Nonnull</span> Runnable command)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> submittedTasksCount.incrementAndGet();<br>    <span class="hljs-comment">// 超过最大的并发任务限制，进行 reject</span><br>    <span class="hljs-comment">// 依赖的LinkedTransferQueue没有长度限制，因此这里进行控制</span><br>    <span class="hljs-keyword">if</span> (count &gt; maxTask) &#123;<br>      submittedTasksCount.decrementAndGet();<br>      getRejectedExecutionHandler().rejectedExecution(command, <span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-built_in">super</span>.execute(command);<br>    &#125; <span class="hljs-keyword">catch</span> (RejectedExecutionException rx) &#123;<br>      <span class="hljs-keyword">if</span> (!((WorkerQueue) getQueue()).force(command)) &#123;<br>        submittedTasksCount.decrementAndGet();<br>        getRejectedExecutionHandler().rejectedExecution(command, <span class="hljs-built_in">this</span>);<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterExecute</span><span class="hljs-params">(Runnable r, Throwable t)</span> &#123;<br>    submittedTasksCount.decrementAndGet();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DefaultThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultThreadPoolExecutor</span>(<br>    <span class="hljs-number">10</span>, <br>    <span class="hljs-number">30</span>, <br>    <span class="hljs-number">60</span>,<br>    <span class="hljs-number">60</span>, <br>    TimeUnit.SECONDS,<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">WorkerQueue</span>(),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultThreadFactory</span>(<span class="hljs-string">&quot;test&quot;</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomRejectedExecutionHandler</span>());<br>executor.execute(()-&gt; System.out.println(<span class="hljs-string">&quot;test DefaultThreadPoolExecutor execute&quot;</span>));<br>executor.submit(()-&gt; System.out.println(<span class="hljs-string">&quot;test DefaultThreadPoolExecutor submit&quot;</span>));<br></code></pre></td></tr></table></figure><h2 id="ThreadPoolExecutor-运行时原理"><a href="#ThreadPoolExecutor-运行时原理" class="headerlink" title="ThreadPoolExecutor 运行时原理"></a>ThreadPoolExecutor 运行时原理</h2><p><img src="/images/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86_ThreadPoolExecutor%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9E%B6%E6%9E%84.png"></p><p>线程池在内部实际上构建了一个生产者消费者模型，将线程和任务两者解耦，并不直接关联，从而良好的缓冲任务，复用线程。线程池的运行主要分成两部分：任务管理、线程管理。</p><ul><li>任务管理部分充当生产者的角色，当任务提交后，线程池会判断该任务后续的流转：<ul><li>直接申请线程执行该任务；</li><li>缓冲到队列中等待线程执行；</li><li>拒绝该任务。</li></ul></li><li>线程管理部分是消费者，它们被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务的时候，线程就会被回收。</li></ul><h3 id="线程池生命周期"><a href="#线程池生命周期" class="headerlink" title="线程池生命周期"></a>线程池生命周期</h3><p><img src="/images/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86_%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png"></p><p>线程池运行的状态，并不是用户显式设置的，而是伴随着线程池的运行由内部维护。线程池内部使用一个 <code>32</code> 位的整数维护两个值：运行状态 <code>runState</code> 和线程数量 <code>workerCount</code> 两个参数维护在一起，其中高 <code>3</code> 位用于存放线程池状态，低 <code>29</code> 位表示线程数 <code>CAPACITY</code> 。用一个 <code>AtomicInteger</code> 变量存储来个值，可避免数据不一致问题，避免了锁的使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolExecutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractExecutorService</span> &#123;<br>  <span class="hljs-comment">// 状态 RUNNING 线程数 = 0</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">ctl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="hljs-number">0</span>)); <br>  <span class="hljs-comment">// 这里 COUNT_BITS 设置为 29(32-3)，意味着前三位用于存放线程状态，后29位用于存放线程数</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> Integer.SIZE - <span class="hljs-number">3</span>;  <br>  <span class="hljs-comment">// 最大容量（2^29 - 1 = 536870911）</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CAPACITY</span>   <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS) - <span class="hljs-number">1</span>;  <br>    <br>  <span class="hljs-comment">// 线程运行状态，总共有5个状态，需要3位来表示（所以偏移量的29 = 32 - 3）</span><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * RUNNING    :    接受新任务并且处理已经进入阻塞队列的任务</span><br><span class="hljs-comment">  * SHUTDOWN    ：    不接受新任务，但是处理已经进入阻塞队列的任务</span><br><span class="hljs-comment">  * STOP        :    不接受新任务，不处理已经进入阻塞队列的任务并且中断正在运行的任务</span><br><span class="hljs-comment">  * TIDYING    :    所有的任务都已经终止，workerCount为0， 线程转化为TIDYING状态并且调用terminated钩子函数</span><br><span class="hljs-comment">  * TERMINATED:    terminated钩子函数已经运行完成</span><br><span class="hljs-comment">  **/</span><br>  <span class="hljs-comment">//111 00000000000000000000000000000</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RUNNING</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;  <br>  <span class="hljs-comment">// 000 00000000000000000000000000000</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SHUTDOWN</span>   <span class="hljs-operator">=</span>  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;  <br>  <span class="hljs-comment">// 001 00000000000000000000000000000</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">STOP</span>       <span class="hljs-operator">=</span>  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;  <br>  <span class="hljs-comment">// 010 00000000000000000000000000000</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TIDYING</span>    <span class="hljs-operator">=</span>  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;  <br>  <span class="hljs-comment">// 011 00000000000000000000000000000</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TERMINATED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;<br>  <span class="hljs-comment">// 将CAPACITY取非后和c进行取与运算，可以得到高3位的值，即线程池的状态</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">runStateOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>     &#123; <span class="hljs-keyword">return</span> c &amp; ~CAPACITY; &#125; <br><br>  <span class="hljs-comment">// 将c和CAPACITY取与运算，可以得到低29位的值，即线程池的个数</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">workerCountOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>  &#123; <span class="hljs-keyword">return</span> c &amp; CAPACITY; &#125;  <br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ctlOf</span><span class="hljs-params">(<span class="hljs-type">int</span> rs, <span class="hljs-type">int</span> wc)</span> &#123; <span class="hljs-keyword">return</span> rs | wc; &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>由源码可以看到，Java 线程池（ThreadPoolExecutor）有五种状态，由一个名为 ctl 的 AtomicInteger 变量进行管理:<br><strong>RUNNING（运行中）</strong></p><ul><li>状态描述: 线程池的初始状态，也是正常工作状态。</li><li>行为: 接受新提交的任务，并处理任务队列中的任务。</li><li>状态切换: 线程池创建后即处于 RUNNING 状态。</li></ul><p><strong>SHUTDOWN（关闭）</strong></p><ul><li>状态描述: 线程池进入温和的关闭状态。</li><li>行为: 不再接受新的任务，但会继续处理任务队列中已有的任务，直到所有任务都执行完毕。</li><li>状态切换: 调用 shutdown() 方法会使线程池进入 SHUTDOWN 状态。</li></ul><p><strong>STOP（停止）</strong></p><ul><li>状态描述: 线程池进入强制关闭状态。</li><li>行为: 不再接受新任务，不处理任务队列中剩余的任务，并且会中断所有正在执行的任务。</li><li>状态切换: 调用 shutdownNow() 方法会使线程池进入 STOP 状态。</li></ul><p><strong>TIDYING（整理）</strong></p><ul><li>状态描述: 线程池处于资源清理阶段，所有任务都已终止，工作线程数也已变为0。</li><li>行为: 在该状态下，会执行 terminated() 钩子方法，进行最后的清理工作。</li><li>状态切换:<ul><li>从 SHUTDOWN 状态进入：当任务队列为空且线程池中的工作线程数为0时。</li><li>从 STOP 状态进入：当线程池中的工作线程数为0时。</li></ul></li></ul><p><strong>TERMINATED（终止）</strong></p><ul><li>状态描述: 线程池已彻底终止。</li><li>行为: 线程池中的所有任务都已处理完毕，所有工作线程都已退出，terminated() 方法也已执行完成。</li><li>状态切换: 从 TIDYING 状态进入。</li></ul><h3 id="线程池提交任务流程"><a href="#线程池提交任务流程" class="headerlink" title="线程池提交任务流程"></a>线程池提交任务流程</h3><p><img src="/images/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86_ThreadPoolExecutor%E4%BB%BB%E5%8A%A1%E6%8F%90%E4%BA%A4%E6%B5%81%E7%A8%8B.png"></p><p>上图中，当一个任务通过execute()或submit()方法提交给ThreadPoolExecutor时，它会遵循以下步骤：</p><ul><li>检查核心线程数：如果当前运行的线程数少于corePoolSize，线程池会立刻创建一个新的核心线程来执行任务。</li><li>进入任务队列：如果当前运行的线程数已达到corePoolSize，任务会被放入workQueue中排队等待。</li><li>创建非核心线程：如果队列已满，但当前运行的线程数小于maximumPoolSize，线程池会创建新的非核心线程来处理队列中的任务。</li><li>执行拒绝策略：如果线程数已达到maximumPoolSize且队列已满，线程池会根据预设的handler（拒绝策略）来处理这个新任务。</li><li>线程复用：当一个工作线程执行完任务后，它不会被销毁，而是会从任务队列中循环获取下一个任务并执行。如果这个线程是非核心线程，并且空闲时间超过keepAliveTime，它才会被终止。</li></ul><h2 id="线程池调优"><a href="#线程池调优" class="headerlink" title="线程池调优"></a>线程池调优</h2><p>配置线程池的线程数没有一成不变的规则，它主要取决于<strong>任务类型（是CPU密集型还是I&#x2F;O密集型）和服务器的硬件资源（如CPU核心数）</strong>。<br><strong>核心考量因素</strong></p><ul><li>任务类型：CPU密集型 vs I&#x2F;O密集型<ul><li><strong>CPU密集型任务</strong>：这类任务需要大量CPU计算，比如复杂的数学运算、图像处理等。它们会持续占用CPU，如果线程数远大于CPU核心数，会造成频繁的线程上下文切换，反而降低性能。</li><li><strong>I&#x2F;O密集型任务</strong>：这类任务需要频繁地进行磁盘读写、网络通信等I&#x2F;O操作。当一个线程在等待I&#x2F;O时，它会释放CPU，让其他线程有机会执行。因此，可以配置较多的线程数以充分利用CPU的空闲时间。</li></ul></li><li>服务器硬件资源：CPU核心数可以通过 <code>Runtime.getRuntime().availableProcessors()</code> 方法获取当前服务器的CPU核心数。这是配置线程池大小的重要参考值。</li></ul><p><strong>线程池大小配置策略</strong><br><strong>CPU密集型任务</strong>：对于CPU密集型任务，线程池的最佳大小应该等于或略大于CPU核心数。</p><ul><li>推荐大小：CPU核心数 + 1</li><li>原因：多出的一个线程可以防止因偶尔的页缺失或其它系统中断而导致的CPU空闲，确保CPU始终处于忙碌状态。</li></ul><p><strong>I&#x2F;O密集型任务</strong>：对于I&#x2F;O密集型任务，线程池可以配置得更大一些，因为线程在等待I&#x2F;O操作时不会消耗CPU。</p><ul><li>推荐公式：CPU核心数 * (1 + 任务等待时间 &#x2F; 任务计算时间)</li><li>计算等待时间与计算时间比率（Blocking Coefficient）：这个比率需要通过性能测试和监控来估算。例如，如果任务的等待时间是计算时间的5倍，那么比率就是5，<font color=red>如果难以获取精确比率，一个经验值是 2 * CPU核心数</font>。</li><li>注意事项：过多的线程数也会导致内存消耗和上下文切换增加，因此需要进行基准测试和监控来找到最佳平衡点。</li></ul><p><strong>混合型任务</strong>：如果线程池中包含CPU密集型和I&#x2F;O密集型两种任务，最佳实践是：</p><ul><li>拆分线程池：为不同类型的任务创建独立的线程池，然后根据各自的特性进行配置。</li><li>优点：<ul><li>避免互相影响：I&#x2F;O密集型任务的阻塞不会影响CPU密集型任务的执行。</li><li>便于调优：可以针对性地调整不同线程池的参数。</li></ul></li></ul><p>如果需要动态调整ThreadPoolExecutor参数，可以通过对应参数的 set 方法进行操作，set相关的方法是线程安全的，如setMaximumPoolSize(int maximumPoolSize)。但需要注意的是 LinkedBlockingQueue 的容量通常无法动态修改，并且动态参数调整可能会影响正在执行的任务。</p><h2 id="Tomcat线程池"><a href="#Tomcat线程池" class="headerlink" title="Tomcat线程池"></a>Tomcat线程池</h2><p><img src="/images/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86_tomcat%E6%9E%B6%E6%9E%84.png"></p><p>Tomcat 的整体架构包含连接器和容器两大部分，其中连接器负责与外部通信，容器负责内部逻辑处理。在连接器中：</p><ul><li>使用 ProtocolHandler 接口来封装I&#x2F;O模型和应用层协议的差异，其中I&#x2F;O模型可以选择非阻塞I&#x2F;O、异步I&#x2F;O或APR，应用层协议可以选择HTTP、HTTPS或AJP。ProtocolHandler将I&#x2F;O模型和应用层协议进行组合，让EndPoint只负责字节流的收发，Processor负责将字节流解析为Tomcat Request&#x2F;Response对象，实现功能模块的高内聚和低耦合，ProtocolHandler接口继承关系如下图示。</li><li>通过适配器 Adapter 将Tomcat Request对象转换为标准的ServletRequest对象。</li></ul><p>在Tomcat中，通过AbstractEndpoint类提供底层的网络I&#x2F;O的处理，若用户没有配置自定义公共线程池，则AbstractEndpoint通过createExecutor方法来创建Tomcat默认线程池。其中，TaskQueue、ThreadPoolExecutor分别为Tomcat自定义任务队列、线程池实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createExecutor</span><span class="hljs-params">()</span> &#123;<br>  internalExecutor = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">if</span> (getUseVirtualThreads()) &#123;<br>      executor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VirtualThreadExecutor</span>(getName() + <span class="hljs-string">&quot;-virt-&quot;</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-type">TaskQueue</span> <span class="hljs-variable">taskqueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TaskQueue</span>(maxQueueSize);<br>      <span class="hljs-type">TaskThreadFactory</span> <span class="hljs-variable">tf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TaskThreadFactory</span>(getName() + <span class="hljs-string">&quot;-exec-&quot;</span>, daemon, getThreadPriority());<br>      executor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(getMinSpareThreads(), getMaxThreads(), getThreadsMaxIdleTime(),<br>              TimeUnit.MILLISECONDS, taskqueue, tf);<br>      taskqueue.setParent((ThreadPoolExecutor) executor);<br>  &#125;<br>&#125; <br></code></pre></td></tr></table></figure><p>Tomcat自定义线程池继承于java.util.concurrent. ThreadPoolExecutor，并新增了一些成员变量来更高效地统计已经提交但尚未完成的任务数量（submittedCount），包括已经在队列中的任务和已经交给工作线程但还未开始执行的任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">                          TimeUnit unit,</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">                          ThreadFactory threadFactory,</span><br><span class="hljs-params">                          RejectedExecutionHandler handler)</span> &#123;<br>  <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||<br>      maximumPoolSize &lt;= <span class="hljs-number">0</span> ||<br>      maximumPoolSize &lt; corePoolSize ||<br>      keepAliveTime &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>  &#125;<br>  <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-literal">null</span> || threadFactory == <span class="hljs-literal">null</span> || handler == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>  &#125;<br><br>  <span class="hljs-built_in">this</span>.corePoolSize = corePoolSize;<br>  <span class="hljs-built_in">this</span>.maximumPoolSize = maximumPoolSize;<br>  <span class="hljs-built_in">this</span>.workQueue = workQueue;<br>  <span class="hljs-built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);<br>  <span class="hljs-built_in">this</span>.threadFactory = threadFactory;<br>  <span class="hljs-built_in">this</span>.handler = handler;<br><br>  prestartAllCoreThreads();<br>&#125;<br></code></pre></td></tr></table></figure><p>Tomcat在自定义线程池ThreadPoolExecutor中重写了execute()方法，并实现对提交执行的任务进行submittedCount加一。Tomcat在自定义ThreadPoolExecutor中，当线程池抛出RejectedExecutionException异常后，会调用force()方法再次向TaskQueue中进行添加任务的尝试。如果添加失败，则submittedCount减一后，再抛出RejectedExecutionException。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>  submittedCount.incrementAndGet();<br>  <span class="hljs-keyword">try</span> &#123;<br>    executeInternal(command);<br>  &#125; <span class="hljs-keyword">catch</span> (RejectedExecutionException rx) &#123;<br>    <span class="hljs-keyword">if</span> (getQueue() <span class="hljs-keyword">instanceof</span> TaskQueue) &#123;<br>      <span class="hljs-comment">// If the Executor is close to maximum pool size, concurrent</span><br>      <span class="hljs-comment">// calls to execute() may result (due to Tomcat&#x27;s use of</span><br>      <span class="hljs-comment">// TaskQueue) in some tasks being rejected rather than queued.</span><br>      <span class="hljs-comment">// If this happens, add them to the queue.</span><br>      <span class="hljs-keyword">final</span> <span class="hljs-type">TaskQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> (TaskQueue) getQueue();<br>      <span class="hljs-keyword">if</span> (!queue.force(command)) &#123;<br>          submittedCount.decrementAndGet();<br>          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RejectedExecutionException</span>(sm.getString(<span class="hljs-string">&quot;threadPoolExecutor.queueFull&quot;</span>));<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      submittedCount.decrementAndGet();<br>      <span class="hljs-keyword">throw</span> rx;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在Tomcat中重新定义了一个阻塞队列TaskQueue，它继承于LinkedBlockingQueue。在Tomcat中，核心线程数默认值为10，最大线程数默认为200，为了避免线程到达核心线程数后后续任务放入队列等待，Tomcat通过自定义任务队列TaskQueue重写offer方法实现了核心线程池数达到配置数后线程的创建。具体地，从线程池任务调度机制实现可知，当offer方法返回false时，线程池将尝试创建新新线程，从而实现任务的快速响应。TaskQueue核心实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TaskQueue</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt; &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">parent</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">TaskQueue</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-built_in">super</span>();<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">TaskQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>      <span class="hljs-built_in">super</span>(capacity);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">TaskQueue</span><span class="hljs-params">(Collection&lt;? extends Runnable&gt; c)</span> &#123;<br>      <span class="hljs-built_in">super</span>(c);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setParent</span><span class="hljs-params">(ThreadPoolExecutor tp)</span> &#123;<br>      parent = tp;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Used to add a task to the queue if the task has been rejected by the Executor.</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> o         The task to add to the queue</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span>          &#123;<span class="hljs-doctag">@code</span> true&#125; if the task was added to the queue,</span><br><span class="hljs-comment">   *                      otherwise &#123;<span class="hljs-doctag">@code</span> false&#125;</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">force</span><span class="hljs-params">(Runnable o)</span> &#123;<br>    <span class="hljs-keyword">if</span> (parent == <span class="hljs-literal">null</span> || parent.isShutdown()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RejectedExecutionException</span>(sm.getString(<span class="hljs-string">&quot;taskQueue.notRunning&quot;</span>));<br>    &#125;<br>    <span class="hljs-comment">//forces the item onto the queue, to be used if the task is rejected</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.offer(o); <br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(Runnable o)</span> &#123;<br>    <span class="hljs-comment">//we can&#x27;t do any checks</span><br>    <span class="hljs-comment">//forces the item onto the queue, to be used if the task is rejected</span><br>    <span class="hljs-comment">// 1. parent为线程池，Tomcat中为自定义线程池实例</span><br>    <span class="hljs-keyword">if</span> (parent==<span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.offer(o);<br>    &#125;<br>    <span class="hljs-comment">// 2. 当线程数达到最大线程数时，新提交任务入队</span><br>    <span class="hljs-comment">//we are maxed out on threads, simply queue the object</span><br>    <span class="hljs-keyword">if</span> (parent.getPoolSizeNoLock() == parent.getMaximumPoolSize()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.offer(o);<br>    &#125;<br>    <span class="hljs-comment">// 3. 当提交的任务数小于线程池中已有的线程数时，即有空闲线程，任务入队即可</span><br>    <span class="hljs-comment">//we have idle threads, just add it to the queue</span><br>    <span class="hljs-keyword">if</span> (parent.getSubmittedCount() &lt;= parent.getPoolSizeNoLock()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.offer(o);<br>    &#125;<br>    <span class="hljs-comment">// 4. 【关键点】如果当前线程数量未达到最大线程数，直接返回false，让线程池创建新线程</span><br>      <span class="hljs-comment">//if we have less threads than maximum force creation of a new thread</span><br>    <span class="hljs-keyword">if</span> (parent.getPoolSizeNoLock() &lt; parent.getMaximumPoolSize()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 5. 最后的兜底，放入队列</span><br>    <span class="hljs-comment">//if we reached here, we need to add it to the queue</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.offer(o);<br>&#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> Runnable <span class="hljs-title function_">poll</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>          <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>      <span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>.poll(timeout, unit);<br>      <span class="hljs-keyword">if</span> (runnable == <span class="hljs-literal">null</span> &amp;&amp; parent != <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-comment">// the poll timed out, it gives an opportunity to stop the current</span><br>          <span class="hljs-comment">// thread if needed to avoid memory leaks.</span><br>          parent.stopCurrentThreadIfNeeded();<br>      &#125;<br>      <span class="hljs-keyword">return</span> runnable;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> Runnable <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>      <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span> &amp;&amp; parent.currentThreadShouldBeStopped()) &#123;<br>          <span class="hljs-keyword">return</span> poll(parent.getKeepAliveTime(TimeUnit.MILLISECONDS),<br>                  TimeUnit.MILLISECONDS);<br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.take();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="自定义设计实现一个线程池"><a href="#自定义设计实现一个线程池" class="headerlink" title="自定义设计实现一个线程池"></a>自定义设计实现一个线程池</h2><p>一个线程池的核心是一个生产者-消费者模型：</p><ul><li>生产者（任务提交者）：向线程池提交任务。</li><li>缓冲区（任务队列）：存储待执行的任务，使用阻塞队列实现线程安全。</li><li>消费者（工作线程）：不断从任务队列中取出任务并执行。</li></ul><p><strong>实现思路</strong></p><ul><li><p><strong>生产者-消费者模型</strong>：execute 方法是生产者，将 Runnable 任务放入 BlockingQueue（任务队列）。WorkerThread 是消费者，从队列中取出任务并执行。</p></li><li><p><strong>BlockingQueue 的选择</strong>：使用 BlockingQueue（如 LinkedBlockingQueue）来处理线程安全问题。它天生支持阻塞式地“放入”（put）和“取出”（take&#x2F;poll）。</p></li><li><p><strong>Worker 线程的生命周期</strong>：WorkerThread 的 run() 方法是一个核心循环。</p><ul><li>通过调用 getTask() 来获取任务。</li><li>getTask() 必须使用带超时的 poll(timeout)，而不是 take()。如果使用 take()，当调用 shutdown()（优雅关闭）时，如果队列为空，工作线程将永远阻塞在 take()，导致线程池无法终止。使用 poll(timeout) 允许线程在超时后醒来，重新检查 state 变量，从而在 state &#x3D;&#x3D; SHUTDOWN 且队列为空时安全退出。</li></ul></li><li><p><strong>volatile 状态</strong>：使用 volatile int state 来管理线程池的状态（RUNNING, SHUTDOWN, STOP）。volatile 保证了当一个线程（例如调用 shutdown() 的主线程）修改 state 时，所有其他工作线程都能立即看到这个变化。</p></li><li><p><strong>shutdown() vs shutdownNow()：</strong></p><ul><li>shutdown()：将状态设为 SHUTDOWN。getTask() 方法检测到此状态后，会继续处理队列中剩余的任务，但一旦队列为空，getTask() 将返回 null，导致 WorkerThread 退出。</li><li>shutdownNow()：将状态设为 STOP，并调用所有 worker.interrupt()。正在 poll() 或 sleep() 的线程会抛出 InterruptedException。getTask() 捕获此异常后返回 null，导致线程立即退出。</li></ul></li></ul><p><strong>一个简单的实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">LinkedBlockingQueue</span> <span class="hljs-variable">taskQueue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>();<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">AtomicBoolean</span> <span class="hljs-variable">running</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicBoolean</span>(<span class="hljs-literal">true</span>);<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">submitTask</span><span class="hljs-params">(Object task)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>      taskQueue.put(task);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">while</span>(running.get()) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 如果没有任务，会使线程阻塞，一旦有任务，会被唤醒</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> taskQueue.take(); <br>        doSomething(task);<br>      &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>        e.printStackTrace();<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span>(running.compareAndSet(<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>)) &#123;<br>      System.out.println(Thread.currentThread() + <span class="hljs-string">&quot; is stoped&quot;</span>);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">(Object task)</span> &#123;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>juc</category>
      
      <category>并发</category>
      
      <category>线程池</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>juc</tag>
      
      <tag>并发</tag>
      
      <tag>线程池</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java线程模型与多线程基础</title>
    <link href="/2025/07/10/java-juc-java%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <url>/2025/07/10/java-juc-java%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在现代操作系统中，线程是处理器调度和分配的基本单位，进程则是作为资源(内存地址、文件 I&#x2F;O 等)拥有的基本单位。线程是进程内部的一个执行单元，每一个进程至少有一个主执行线程，它无需由用户去主动创建，是由系统自动创建的。用户根据需要在应用程序中创建其它线程，多个线程并发地运行于同一个进程中。</p><span id="more"></span><p>在进行并发编程时，如果希望通过多线程执行任务让程序运行得更快，会面临诸多挑战：</p><ul><li>上下文切换问题；</li><li>死锁问题；</li><li>硬件和硬件资源限制。</li></ul><h3 id="上下文切换问题"><a href="#上下文切换问题" class="headerlink" title="上下文切换问题"></a>上下文切换问题</h3><p>CPU 通过给每个线程分配 CPU 时间片来实现事件推进，CPU分配给各个线程的时间非常短，所以 CPU 通过不停地切换线程执行，让我们感觉多个线程是同时执行的。<font color=green>在CPU切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态，所以任务从保存到再加载的过程就是一次上下文切换</font>。</p><p>线程上下文切换是有成本的，主要体现在以下几个方面：</p><ul><li><strong>CPU 开销</strong>：保存和恢复线程状态需要 CPU 执行额外的指令</li><li><strong>缓存失效</strong>：上下文切换可能导致 CPU 缓存、TLB（Translation Lookaside Buffer）和分支预测器的失效，从而增加内存访问延迟。</li><li><strong>内核态开销</strong>：上下文切换通常涉及从用户态切换到内核态的操作，这进一步增加了开销。</li></ul><p><strong>减少上下文切换的方法：</strong></p><ul><li>减少线程数量：使用合理数量的线程，避免线程过多导致频繁切换;</li><li>无锁编程：减少线程之间的锁竞争，降低阻塞几率；</li><li>使用适当的线程池：利用线程池复用线程，避免频繁的线程创建和销毁；</li><li>CAS 算法：使用 CAS 算法来更新数据，而不需要加锁；</li><li>线程池复用：选择合适的调度策略，减少不必要的上下文切换。</li></ul><h3 id="Linux系统分层架构"><a href="#Linux系统分层架构" class="headerlink" title="Linux系统分层架构"></a>Linux系统分层架构</h3><p>进程作为资源拥有者，其调度及系统资源的分配离不开操作系统。这里以Linux系统为例，为了确保系统的安全性、稳定性和高效性，Linux 使用 <strong>用户空间 (User Space) 与内核空间 (Kernel Space)</strong> 的分离设计。 </p><p><strong>内核空间 (Kernel Space)</strong><br>内核是 Linux 操作系统的核心，直接与硬件层交互，它负责管理系统的所有资源，并为上层软件提供接口。Linux 内核采用<strong>宏内核（monolithic kernel）</strong> 架构，这意味着所有的核心功能（如设备驱动、文件系统、内存管理、进程管理等）都包含在一个单一的、受保护的地址空间内。内核的主要功能包括：</p><ul><li>内存管理：管理系统的 RAM，确保进程高效、安全地使用内存。</li><li>进程管理：负责创建、调度和终止进程，公平地分配 CPU 时间。</li><li>设备驱动程序：控制特定的硬件设备，将硬件操作抽象为统一的接口。</li><li>文件系统：管理数据的存储和检索，提供对不同类型文件系统的支持。</li><li>网络管理：处理网络通信协议和接口。</li><li>系统调用接口：提供应用程序访问内核功能的接口。</li></ul><p><strong>用户空间 (User Space)</strong><br>用户空间是用户与计算机硬件之间的高级抽象层，它提供了一个安全、稳定且灵活的环境，允许各种应用程序运行，同时将复杂的硬件管理和系统控制任务留给特权的内核空间来处理。它是受限的、非特权的环境，与具有完全硬件访问权限的内核空间严格隔离。主要特点：</p><ul><li>隔离性：每个用户空间进程通常运行在自己独立的虚拟内存空间中，无法直接访问其他进程或内核的内存。</li><li>非特权模式 (User Mode)：用户空间的代码在 CPU 的非特权级别（如 x86 架构的 Ring 3）运行，权限受限。</li><li>通过系统调用与内核通信：当用户程序需要执行特权操作（如文件 I&#x2F;O、网络访问、内存分配等）时，必须发起系统调用 (System Call)，请求内核代为执行。</li><li>健壮性与安全性：用户空间的设计提供了一个沙盒环境。即使某个用户程序崩溃，也不会影响到操作系统内核或其他程序，从而保证了系统的稳定性。</li></ul><p><font color=red>总之，用户空间和内核空间的分离通过引入特权隔离层，使得 Linux 操作系统能够在一个多任务、多用户的环境中提供一个健壮、可靠且安全的运行平台。</font></p><h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><p>由于Linux系统的分层架构，线程的实现可以分为两类：<strong>用户级线程(User-LevelThread, ULT)和内核级线程(Kemel-LevelThread, KLT)</strong>。在用户级线程中，线程的创建和销毁都是由用户程序来完成，用户程序需要调用系统提供的接口来创建和销毁线程，而线程的调度则交由操作系统来完成。多线程模型即用户级线程和内核级线程的不同连接方式，线程模型影响着并发规模及操作成本(开销)。通常多线程有如下几种实现：</p><ul><li><p><strong>多对一模式 - 使用用户线程实现(m:1)</strong>：多个用户线程映射到一个内核线程，用户线程建立在用户空间的线程库上，用户线程的建立、同步、销毁和调度完全在用户态中完成，对内核透明。</p><ul><li><p>优点：</p><ul><li>线程的上下文切换都发生在用户空间，避免了模态切换（mode switch），减少了性能的开销。</li><li>用户线程的创建不受内核资源的限制，可以支持更大规模的线程数量。</li></ul></li><li><p>缺点：</p><ul><li>所有的线程基于一个内核调度实体即内核线程，这意味着只有一个处理器可以被利用，浪费了其它处理器资源，不支持并行，在多处理器环境下这是不能够被接受的，如果线程因为 I&#x2F;O 操作陷入了内核态，内核态线程阻塞等待 I&#x2F;O 数据，则所有的线程都将会被阻塞。</li><li>增加了复杂度，所有的线程操作都需要用户程序自己处理，而且在用户空间要想自己实现 “阻塞的时候把线程映射到其他处理器上” 异常困难。</li></ul></li></ul></li><li><p><strong>一对一模式 - 使用内核线程实现(1:1)</strong>：程序使用的是轻量级进程（Light Weight Process, LWP），轻量级进程就是我们通常意义上所讲的线程, 也是属于用户线程。在实现上每个用户线程都映射到一个内核线程，每个线程都成为一个独立的调度单元，由内核调度器独立调度，一个线程的阻塞不会影响到其他线程，从而保障整个进程继续工作。</p><ul><li>优点：<ul><li>每个线程都成为一个独立的调度单元，使用内核提供的线程调度功能及处理器映射，可以完成线程的切换，并将线程的任务映射到其他处理器上，充分利用多核处理器的优势，实现真正的并行。</li></ul></li><li>缺点：<ul><li>每创建一个用户级线程都需要创建一个内核级线程与其对应，因此需要消耗一定的内核资源, 而内核资源是有限的，所以能创建的线程数量也是有限的。</li><li>模态切换频繁，各种线程操作，如创建、析构及同步，都需要进行系统调用，需要频繁的在用户态和内核态之间切换，开销大。</li></ul></li></ul></li><li><p><strong>多对多模式 - 混合模型(m:n)</strong>：内核线程和用户线程的数量比为 M : N，这种模型需要内核线程调度器和用户空间线程调度器相互操作，本质上是多个线程被映射到了多个内核线程。其综合了前面两种模型的优点：</p><ul><li>用户线程的创建、切换、析构及同步依然发生在用户空间，能创建数量更多的线程，支持更大规模的并发。</li><li>大部分的线程上下文切换都发生在用户空间，减少了模态切换带来的开销。</li><li>可以使用内核提供的线程调度功能及处理器映射，充分利用多核处理器的优势，实现真正的并行，并降低了整个进程被完全阻塞的风险。</li></ul></li></ul><h3 id="Java线程模型"><a href="#Java线程模型" class="headerlink" title="Java线程模型"></a>Java线程模型</h3><p>Java 的线程是映射到操作系统的原生线程之上。JVM 只封装了底层操作系统的差异，不同的操作系统可能使用不同的线程模型，例如 Linux 和 windows 可能使用了一对一模型，solaris 和 unix 某些版本可能使用多对多模型，所以谈到 Java 语言的多线程模型，需要针对具体 JVM 实现。</p><p>在Java中Thread类实现了对操作系统线程的抽象。具体来说，在Java中一个操作系统线程与一个Thread对象关联，通过调用Thread对象的start()方法来启动一个操作系统线程执行。其运行逻辑：在调用<code>Thread.start()</code>方法之后，会调用到JVM本地方法，随后申请创建一个新的操作系统线程环境执行<code>Thread.run()</code>，在<code>Thread.run()</code>中最终调用的的<code>Runnable.run()</code>，也就是通过Thread.start()启动的线程最终执行的是Runnable.run()。</p><h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><p>在 Java 中，线程可以使用 <code>java.lang.Thread</code> 类来创建和管理线程，最常见的写法例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadTest</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>());<br>    thread.setName(<span class="hljs-string">&quot;test-thread&quot;</span>);<br>    thread.start();<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;线程运行，线程名称为:&quot;</span> + Thread.currentThread().getName());<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="线程生命周期与状态"><a href="#线程生命周期与状态" class="headerlink" title="线程生命周期与状态"></a>线程生命周期与状态</h3><p>在 Java 中线程的生命周期中一共有 6 种状态：</p><ul><li>New（新创建）</li><li>Runnable（可运行）</li><li>Blocked（被阻塞）</li><li>Waiting（等待）</li><li>Timed Waiting（计时等待）</li><li>Terminated（被终止）</li></ul><p><img src="/images/java-juc-java%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B_java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.png"></p><ul><li><p><strong>New</strong><br>表示线程被创建但尚未启动的状态：当我们用 new Thread() 新建一个线程时，如果线程没有开始运行 start() 方法，所以也没有开始执行 run() 方法里面的代码，那么此时它的状态就是 New。而一旦线程调用了 start()，它的状态就会从 New 变成 Runnable。</p></li><li><p><strong>Runable</strong><br>对应操作系统线程状态中的两种状态，<strong>分别是 Running 和 Ready</strong>。Java 中处于 Runnable 状态的线程有可能正在执行，也有可能没有正在执行，正在等待被分配 CPU 资源。所以，如果一个正在运行的线程是 Runnable 状态，当它运行到任务的一半时，执行该线程的 CPU 被调度去做其他事情，导致该线程暂时不运行，它的状态依然不变，还是 Runnable，因为它有可能随时被调度回来继续执行任务。</p></li><li><p><strong>Blocked</strong> 从箭头的流转方向可以看出，从 Runnable 状态进入 Blocked 状态只有一种可能，就是进入 synchronized 保护的代码时没有抢到 monitor 锁，无论是进入 synchronized 代码块，还是 synchronized 方法，都是一样。</p></li><li><p><strong>Waiting</strong> 状态有三种可能性：</p><ul><li>没有设置 Timeout 参数的 Object.wait() 方法。</li><li>没有设置 Timeout 参数的 Thread.join() 方法。</li><li>LockSupport.park() 方法。</li></ul></li><li><p><strong>Timed Waiting</strong> 状态：</p><ul><li>设置了时间参数的 Thread.sleep(long millis) 方法；</li><li>设置了时间参数的 Object.wait(long timeout) 方法；</li><li>设置了时间参数的 Thread.join(long millis) 方法；</li><li>设置了时间参数的 LockSupport.parkNanos(long nanos) 方法和 LockSupport.parkUntil(long deadline) 方法。</li></ul></li></ul><h3 id="Thread-运行逻辑"><a href="#Thread-运行逻辑" class="headerlink" title="Thread 运行逻辑"></a>Thread 运行逻辑</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>   <span class="hljs-comment">/* What will be run. */</span><br>  <span class="hljs-keyword">private</span> Runnable target;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//省略</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">started</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      start0();<br>      started = <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-comment">//省略</span><br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start0</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (target != <span class="hljs-literal">null</span>) &#123;<br>      target.run();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的代码可以看到，在执行 thread.start() 时会调用 JNI 方法 start0()，JVM 执行 start0() 会创建并启动一个真正的操作系统级线程，并将该线程的执行入口与 Java 线程的 run() 方法关联起来。 具体过程如下：</p><ul><li><strong>调用JNI接口</strong>：JVM 通过 Java Native Interface (JNI) 调用预先加载好的本地库（例如, 在 Linux 中是 libpthread，在 Windows 中是使用 Win32 API 的 kernel32.lib）中对应的 C&#x2F;C++ 函数。</li><li><strong>创建操作系统线程</strong>：在本地代码中，JVM 调用底层的操作系统API来创建一个新的原生线程。例如，在 POSIX 系统（如 Linux、macOS）上，会调用 pthread_create() 函数；在 Windows 上，会调用 CreateThread() 函数。这个新的操作系统线程会拥有自己独立的堆栈空间 (stack)。</li><li>指定执行入口函数: 在调用操作系统 API 创建线程时，JVM 会传递一个特定的 C&#x2F;C++ 函数地址作为新线程的执行入口点。在 OpenJDK 源码中，这个入口函数通常是 thread_entry() 或类似的函数。</li><li><strong>回调Java</strong>：当新的操作系统线程开始执行时，它首先运行上述指定的 C&#x2F;C++ 入口函数 (thread_entry)。这个入口函数负责进行必要的设置（如与 JVM 环境的关联），然后 <strong>回调（thunk back）</strong> 到 Java 层，最终执行对应 Java Thread 对象的 run() 方法。</li><li><strong>并发执行</strong>: 此时，原来的主线程从 start() 方法返回，继续执行其后续代码；新创建的线程则开始并发执行其 run() 方法中的业务逻辑。</li></ul><p>总之：<font color=red>start0() 是连接 Java 世界和底层操作系统线程机制的桥梁，它利用 JNI 请求OS创建新线程，并确保新线程的起点是用户定义的 run() 方法</font>。</p><h2 id="virtual-thread"><a href="#virtual-thread" class="headerlink" title="virtual thread"></a>virtual thread</h2><p><strong>虚拟线程（Virtual Threads）是JDK 21引入的，其实现原理是一种用户态线程（User-mode threads）模型，由 JVM 而非操作系统（OS）管理和调度，使用载体线程（Carrier Threads）</strong> 作为底层执行资源的抽象层。传统的平台线程（Platform Threads）采用 1:1 模型，即一个 Java 线程永久绑定一个 OS 线程。虚拟线程则采用 M:N 模型，M 个虚拟线程复用 N 个（数量少得多的）平台线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">sealed</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseVirtualThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span><br>        <span class="hljs-keyword">permits</span> VirtualThread, ThreadBuilders.BoundVirtualThread &#123;<br>  <span class="hljs-comment">// 省略</span><br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VirtualThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseVirtualThread</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">DEFAULT_SCHEDULER</span> <span class="hljs-operator">=</span> createDefaultScheduler();<br>  <span class="hljs-comment">// scheduler and continuation</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Executor scheduler;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Continuation cont;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Runnable runContinuation;<br>&#125;<br></code></pre></td></tr></table></figure><p>由上面代码可看到，与平台线程类似，虚拟线程也是平台线程的一个实例<code>java.lang.Thread</code>。但虚拟线程的实际执行依赖于由平台线程组成的、小的、共享的线程池，这些平台线程称为<code>载体线程</code>。JVM 在实现上依赖于线程池，默认使用 ForkJoinPool 实例作为调度器，管理这些载体线程，通常其并行度与可用 CPU 核心数相当。</p><p>虚拟线程的核心思想是解耦：将业务逻辑（虚拟线程）与底层执行资源（载体线程&#x2F;OS线程）分离。通过在 I&#x2F;O 阻塞时动态切换任务，JVM 可以在少量 OS 线程上高效地运行海量的并发任务，同时保留了简单易懂的一个请求一个线程的同步编程模型。</p><h3 id="virtual-thread-使用"><a href="#virtual-thread-使用" class="headerlink" title="virtual thread 使用"></a>virtual thread 使用</h3><p><strong>使用 Thread 类和 Thread.Builder 接口创建虚拟线程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> Thread.ofVirtual().start(() -&gt; System.out.println(<span class="hljs-string">&quot;Hello&quot;</span>));<br><br>Thread.<span class="hljs-type">Builder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> Thread.ofVirtual().name(<span class="hljs-string">&quot;MyThread&quot;</span>);<br><span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;Running thread&quot;</span>);<br>&#125;;<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> builder.start(task);<br></code></pre></td></tr></table></figure><p><strong>使用 Executors.newVirtualThreadPerTaskExecutor() 方法创建和运行虚拟线程</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">myExecutor</span> <span class="hljs-operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;<br>    Future&lt;?&gt; future = myExecutor.submit(() -&gt; System.out.println(<span class="hljs-string">&quot;Running thread&quot;</span>));<br>    future.get();<br>    System.out.println(<span class="hljs-string">&quot;Task completed&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>juc</category>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>juc</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java锁基础与实现</title>
    <link href="/2025/07/04/java-juc-%E9%94%81/"/>
    <url>/2025/07/04/java-juc-%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java中的锁是多线程编程的核心机制，用于控制对共享资源的并发访问，确保线程安全（Thread Safety）和数据一致性。主要有两种实现方式：<strong>内置锁（synchronized 关键字） 和 显式锁（java.util.concurrent.locks.Lock 接口及其实现类）</strong>。根据锁的不同行为特性，可以进行如下分类:</p><span id="more"></span> <ul><li><strong>独占锁（Exclusive Lock）vs 共享锁（Shared Lock）</strong>:<ul><li>独占锁: 在任何时刻只允许一个线程访问资源（如 synchronized, ReentrantLock, ReentrantReadWriteLock 的写锁）。</li><li>共享锁: 允许多个线程同时访问资源（如 ReentrantReadWriteLock 的读锁, Semaphore）。</li></ul></li><li><strong>公平锁（Fair Lock）vs 非公平锁（Non-fair Lock）</strong>:<ul><li>公平锁: 严格按照线程请求锁的顺序来分配锁。</li><li>非公平锁: 不保证请求顺序，新请求的线程可能插队获取锁（默认情况下性能通常更高）。ReentrantLock 默认是非公平锁。</li></ul></li><li><strong>悲观锁（Pessimistic Lock）vs 乐观锁（Optimistic Lock）</strong>:<ul><li>悲观锁: 认为并发冲突经常发生，因此在访问前就加锁（大多数Java锁如 synchronized 和 ReentrantLock 属于此类）。</li><li>乐观锁: 认为冲突很少发生，不加锁，而是在更新时检查是否有冲突（如使用CAS操作实现的原子类 AtomicInteger 或 StampedLock 的乐观读）。</li></ul></li><li><strong>可重入锁（Reentrant Lock）vs 不可重入锁（Non-reentrant Lock）</strong>: 允许持有锁的线程再次获取该锁而不会死锁（Java中 synchronized, ReentrantLock 都是可重入的）。</li></ul><h3 id="锁的内存语义"><a href="#锁的内存语义" class="headerlink" title="锁的内存语义"></a>锁的内存语义</h3><p>在分析<a href="https://ares081.github.io/2025/07/01/java-juc-JMM%E5%9F%BA%E7%A1%80/">JMM</a>是聊到，Java内存模型始终围绕着如何保证并发的<strong>原子性、可见性和有序性</strong>。对于java锁来说必须实现<strong>互斥性和内存可见性</strong>，JJava内存模型围绕这两个核心目标来保证锁的语义：</p><ul><li>原子性（Mutual Exclusion）: 确保同一时刻只有一个线程能够持有同一个锁并执行临界区代码。这是通过监视器（Monitor）机制或AQS（ReentrantLock 等的实现）在JVM层面实现的。</li><li>可见性（Visibility）: 确保一个线程在释放锁时对共享变量的修改，对随后获取同一个锁的另一个线程是可见的。这是通过刷新和加载内存的操作实现的。</li></ul><p>具体来说，锁操作具有与 volatile 变量读写相似的内存语义: </p><ul><li><strong>锁释放（Unlock）</strong> 的内存语义：类似于 volatile 写。在释放锁时，JMM 会把该线程工作内存（本地缓存）中的所有共享变量的修改强制刷新到主内存（Main Memory）中。</li><li><strong>锁获取（Lock Acquire）</strong> 的内存语义：类似于 volatile 读。在获取锁时，JMM 会清空当前线程工作内存中该锁保护的共享变量的本地缓存值，强制要求线程从主内存中重新读取这些变量的最新值。</li></ul><p>在实现上Java内存模型（JMM）通过定义 <strong>happens-before 关系和在底层插入内存屏障（Memory Barrier）</strong> 来实现锁的语义（互斥性和内存可见性）。</p><ul><li><p>happens-before 规则<br>JMM 通过 <strong>监视器锁规则（Monitor Lock Rule）</strong> 将上述语义形式化，这是实现可见性的关键：对一个监视器锁的解锁操作，happens-before（先行发生）随后对这个锁的加锁操作。 这意味着，如果线程 A 释放了一个锁，而线程 B 随后获取了同一个锁，那么线程 A 在释放锁之前进行的所有操作（包括对共享变量的修改）的效果，对线程 B 都是可见的。</p></li><li><p>底层实现：内存屏障<br>JVM并不会直接在所有平台上实现一套固定的锁机制，而是利用 <strong>内存屏障指令（Memory Barrier&#x2F;Fence）</strong> 来适应不同硬件架构的内存模型。 JMM 保证只要遵守了锁的使用规范（例如，在 finally 块中释放 ReentrantLock），无论底层硬件内存模型是强一致性（如x86）还是弱一致性（如ARM），Java程序都会表现出一致的并发行为。使用内存屏障在JVM层面进行保证:</p><ul><li>在释放锁时，JVM会插入写屏障（Store Barrier），确保屏障前所有的写操作都被刷新到主内存，并且不会被重排序到屏障后。</li><li>在获取锁时，JVM会插入读屏障（Load Barrier）或全屏障（Full Barrier），清空本地缓存，并防止重排序，确保在临界区内的操作都能看到最新的共享变量值。</li></ul></li></ul><p>总之：<font color=red>JMM 实现锁语义的核心在于结合互斥机制（如监视器）和内存可见性保证（通过 happens-before 规则和内存屏障），确保临界区内的代码能够顺序执行，并且对共享变量的所有修改能在线程间正确同步</font>。</p><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>synchronized是java内置的锁，Java 中的每个对象都与其关联，用于实现线程的同步。 </p><h3 id="synchronized使用"><a href="#synchronized使用" class="headerlink" title="synchronized使用"></a>synchronized使用</h3><p>synchronized是Java中用于实现线程同步的关键字，用于控制多个线程对共享资源的并发访问，防止数据不一致和线程冲突问题。它主要有三种使用方式：<strong>修饰实例方法、修饰静态方法和修饰代码块</strong>。</p><ul><li>修饰实例方法：<font color=red>当synchronized修饰一个普通实例方法时，锁定的是当前实例对象（this）</font> 。这意味着，同一时刻，只有一个线程可以执行该实例的任何一个synchronized实例方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>      count++;<br>      System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; incremented, current count: &quot;</span> + count);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>修饰静态方法：<font color=red>当synchronized修饰一个静态方法时，锁定的是当前类的所有实例，即Class对象</font> 。这意味着，同一时刻，无论有多少个该类的实例，都只有一个线程可以执行该类的任何一个synchronized静态方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticCounter</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">staticCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">staticIncrement</span><span class="hljs-params">()</span> &#123;<br>    staticCount++;<br>    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; static incremented, current staticCount: &quot;</span> + staticCount);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>修饰代码块：修饰代码块是synchronized提供的更细粒度的控制机制，可以只对方法中的一部分代码进行同步。它需要指定一个锁对象，该对象可以是任意一个非null的对象实例。</p><ul><li>实例锁：锁定的是指定的对象实例。不同实例的synchronized代码块互不影响。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedBlockExample</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">performAction</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>      count++;<br>      System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; updated, count: &quot;</span> + count);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>类锁：当代码块锁定的对象是Class对象时，它实现了与静态方法一样的效果，即对整个类进行同步。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassLockExample</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">staticCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">performAction</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (ClassLockExample.class) &#123;<br>      staticCount++;<br>      System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; static updated, staticCount: &quot;</span> + staticCount);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>synchronized 使用小结：</p><table><thead><tr><th align="left">类型</th><th align="left">关键字位置</th><th align="left">锁定对象</th><th align="left">影响范围</th></tr></thead><tbody><tr><td align="left"><strong>实例方法</strong></td><td align="left"><code>public synchronized void method()</code></td><td align="left">实例对象（<code>this</code>）</td><td align="left">属于同一实例的所有<code>synchronized</code>实例方法</td></tr><tr><td align="left"><strong>静态方法</strong></td><td align="left"><code>public static synchronized void method()</code></td><td align="left">Class对象（<code>类名.class</code>）</td><td align="left">属于该类的所有<code>synchronized</code>静态方法</td></tr><tr><td align="left"><strong>代码块</strong></td><td align="left"><code>synchronized (锁对象)</code></td><td align="left">指定的锁对象</td><td align="left">所有在同一<code>锁对象</code>上进行同步的代码块</td></tr></tbody></table><h3 id="synchronized-实现机制"><a href="#synchronized-实现机制" class="headerlink" title="synchronized 实现机制"></a>synchronized 实现机制</h3><p>synchronized 的底层实现主要依赖于Java <strong>对象头中的监视器锁（Monitor），并通过JVM 字节码指令来控制锁的获取和释放</strong>。</p><h4 id="核心原理：监视器锁（Monitor）"><a href="#核心原理：监视器锁（Monitor）" class="headerlink" title="核心原理：监视器锁（Monitor）"></a><strong>核心原理：监视器锁（Monitor）</strong></h4><p>每个Java对象都可以关联一个监视器（Monitor），当一个线程试图获取一个对象的锁时，它就是去竞争这个对象所关联的 Monitor 的所有权。</p><ul><li><strong>监视器入口（Entry Set）</strong>：当一个线程试图获取锁时，如果该锁已被其他线程持有，这个线程就会进入 Monitor 的入口集（Entry Set）并阻塞等待。</li><li><strong>锁的重入性</strong>：Monitor 内部有一个计数器。当一个线程成功获取锁后，计数器会加一。如果同一个线程再次进入同步代码块，计数器会继续增加，这就是synchronized可重入的原理。线程每次退出同步代码块时，计数器会减一，直到减为零时，锁才真正被释放。</li><li><strong>等待队列（Wait Set）</strong>：当线程获取锁后，如果调用了 wait() 方法，它会释放锁并进入 Monitor 的等待队列。当其他线程调用 notify() 或 notifyAll() 方法时，等待队列中的线程会被唤醒，重新进入入口集去竞争锁。</li></ul><p>Monitor依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的。每个对象都对应于一个可称为” 互斥锁” 的标记，这个标记用来保证在任一时刻，只能有一个线程访问该对象。</p><p><img src="/images/java-juc-%E9%94%81_synchronized%E9%94%81%E7%8A%B6%E6%80%81%E8%BD%AC%E7%A7%BB.png"></p><p>每个 Java 对象都可以关联一个监视器（Monitor）。当一个线程试图获取一个对象的锁时，它就是去竞争这个对象所关联的 Monitor 的所有权。那Java对象是如何关联的呢？<br>在HotSpot虚拟机中，一个Java对象在堆内存中的存储布局主要包括三个部分：<strong>对象头（Object Header）、实例数据（Instance Data） 和对齐填充（Padding）</strong>。</p><ul><li><strong>对象头 (Object Header)</strong>：对象头是每个Java对象都必须有的，用于存储对象自身的运行时数据和类型信息。它主要包含两部分（数组对象有三部分）：<ul><li><strong>Mark Word (标记字段)</strong>：这部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志（无锁、偏向锁、轻量级锁、重量级锁）、偏向线程ID、偏向时间戳等。在32位或64位JVM中，其大小和结构会有所不同。</li><li><strong>Klass Pointer (类型指针)</strong>：这是对象指向其类元数据（在方法区中）的指针，虚拟机通过这个指针来确定该对象是哪个类的实例。</li><li><strong>数组长度 (Array Length)</strong>：如果对象是一个Java数组，对象头中还会有一块额外的数据用于记录数组的长度。普通Java对象的大小可以从其元数据中确定，但数组的大小不能，因此需要单独记录。</li></ul></li><li>实例数据 (Instance Data)<br>这部分是真正存储对象有效信息的地方，即代码中所定义的各种字段（成员变量）的数据，包括从父类继承下来的和子类中定义的字段。JVM会根据字段的类型、在代码中的定义顺序以及内存对齐规则进行排列。 </li><li>对齐填充 (Padding)<br>对齐填充并不是必然存在的，它仅起到占位符的作用。HotSpot虚拟机要求对象的总内存大小必须是8字节的倍数，如果对象头和实例数据加起来的大小不足8字节的倍数，就会通过对齐填充来补齐，以确保对象在内存中是8字节对齐的。</li></ul><p>在这里我们只需要关注对象头的Mark Word，以32位JVM Mark Word为例：</p><p><img src="/images/java-juc-%E9%94%81_java32%E4%BD%8D%E5%AF%B9%E8%B1%A1%E5%A4%B4MarkWord%E7%BB%93%E6%9E%84.png"></p><p><strong>字段说明：</strong></p><ul><li><strong>锁标志位（lock）</strong>：区分锁状态，11时表示对象待GC回收状态, 只有最后2位锁标识(11)有效。</li><li>biased_lock：是否偏向锁，由于无锁和偏向锁的锁标识都是 01，没办法区分，这里引入一位的偏向锁标识位。</li><li>分代年龄（age）：表示对象被GC的次数，当该次数到达阈值的时候，对象就会转移到老年代。</li><li>对象的hashcode（hash）：运行期间调用System.identityHashCode()来计算，延迟计算，并把结果赋值到这里。当对象加锁后，计算的结果31位不够表示，在偏向锁，轻量锁，重量锁，hashcode会被转移到Monitor中。</li><li>偏向锁的线程ID（JavaThread）：偏向模式的时候，当某个线程持有对象的时候，对象这里就会被置为该线程的ID。 在后面的操作中，就无需再进行尝试获取锁的动作。</li><li>epoch：偏向锁在CAS锁操作过程中，偏向性标识，表示对象更偏向哪个锁。</li><li>指向栈中锁记录的指针(ptr_to_lock_record)：轻量级锁状态下，指向栈中锁记录的指针。当锁获取是无竞争的时，JVM使用原子操作而不是OS互斥。这种技术称为轻量级锁定。在轻量级锁定的情况下，JVM通过CAS操作在对象的标题字中设置指向锁记录的指针。</li><li><strong>指向Montor指针(ptr_to_heavyweight_monitor)</strong>：重量级锁状态下，指向对象监视器Monitor的指针。如果两个不同的线程同时在同一个对象上竞争，则必须将轻量级锁定升级到Monitor以管理等待的线程。在重量级锁定的情况下，JVM在对象的ptr_to_heavyweight_monitor设置指向Monitor的指针。</li></ul><p>从Mark Word结构中，当轻量级锁竞争失败后，JVM会为对象创建一个Monitor对象（通常涉及操作系统级别的互斥量 Mutex），这就是synchronized锁。所有竞争的线程都会进入 Monitor 的等待队列并阻塞（涉及用户态到内核态的切换）。</p><p>另外，Mark Word通过其内部比特位的重用和状态标志位，实现了JVM对synchronized锁的优化升级路径。这种机制使得JVM可以根据实际的并发竞争情况，动态地调整锁的实现方式，从未竞争时的无开销（偏向锁&#x2F;无锁）平滑过渡到高竞争时的操作系统级同步（重量级锁），从而在保证线程安全的同时最大化性能。</p><h4 id="字节码层面实现"><a href="#字节码层面实现" class="headerlink" title="字节码层面实现"></a><strong>字节码层面实现</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SynchronizedDemo2</span> &#123;<br>  <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">synchronized</span> (object) &#123;<br>        <br>      &#125;<br>      method2();<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;<br><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>同步代码块</strong>：在编译时，编译器会在同步代码块的入口和出口分别插入 monitorenter 和 monitorexit 这两个字节码指令。<ul><li>monitorenter：线程试图获取 Monitor 的所有权。</li><li>monitorexit：线程释放 Monitor 的所有权。为了确保锁在任何情况下（包括发生异常时）都能被释放，编译器会生成两个monitorexit指令，一个用于正常退出，一个用于异常退出。</li></ul></li><li><strong>同步方法</strong>：synchronized修饰的方法，其字节码中会添加 <strong>ACC_SYNCHRONIZED</strong> 标志。JVM 在调用这个方法时，会根据这个标志自动处理 Monitor 的获取和释放，无需显式插入 monitorenter 和 monitorexit 指令。</li></ul><p><img src="/images/java-juc-%E9%94%81_synchronized%E9%94%81%E5%AD%97%E8%8A%82%E7%A0%81%E6%94%AF%E6%8C%81.png"></p><h3 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h3><p>Java虚拟机（JVM）中的锁升级过程是其对synchronized关键字进行性能优化的核心机制。为了在线程安全和性能之间找到平衡，JVM（特别是HotSpot虚拟机）引入了四种锁状态，并根据竞争情况进行动态升级。锁的状态从低到高（性能从高到低，竞争程度从低到高）依次是：<strong>无锁状态 (Unlocked)、偏向锁 (Biased Locking)、轻量级锁 (Lightweight Locking)、重量级锁 (Heavyweight Locking)</strong>。整个升级过程是不可逆的：锁只能从低级状态升级到高级状态，不能降级（重量级锁在释放后可以回到无锁状态，但过程是升级）。</p><ul><li><p>无锁状态 (Unlocked)：当对象刚创建时，其对象头中的 Mark Word 处于无锁状态。此时，任何线程都可以访问该对象而无需同步开销。</p></li><li><p>偏向锁 (Biased Locking)：</p><ul><li>当第一个线程 A 试图获取一个处于无锁状态的对象的锁时，JVM会尝试使用一个CAS（Compare-AndSwap）操作，将线程 A 的ID记录到对象的 Mark Word 中，并把标志位设为偏向锁状态。</li><li>如果CAS成功，线程 A 获得偏向锁。此后，只要是线程 A 再次访问这个同步块，无需进行任何同步操作，只需简单检查 Mark Word 中的线程 ID 是否是自己。</li><li>如果另一个线程 B 尝试获取这个锁，偏向锁就会被撤销，并升级到轻量级锁。</li></ul></li><li><p>轻量级锁 (Lightweight Locking)：</p><ul><li>当线程 B 发现对象处于偏向锁状态（且线程ID不是自己）或无锁状态时，会进入轻量级锁的获取流程。</li><li>线程 B 会在自己的栈帧中创建一个Lock Record（锁记录），并将对象 Mark Word 的当前值复制进去。</li><li>线程 B 使用CAS操作尝试将对象的 Mark Word 替换为指向自己栈中 Lock Record 的指针。</li><li>如果CAS成功，线程 B 获得轻量级锁。</li><li>如果CAS失败（说明有其他线程同时在竞争，此时可能另一个线程也试图加轻量级锁），锁会膨胀（升级）为重量级锁。</li><li>线程在释放轻量级锁时，也会尝试使用CAS将Displaced Mark Word（之前复制的原始Mark Word值）写回对象头。如果CAS失败，同样意味着发生了竞争，需要升级到重量级锁。</li></ul></li><li><p>重量级锁 (Heavyweight Locking)：</p><ul><li>当轻量级锁的 CAS 操作失败时，JVM 会将锁膨胀为重量级锁。</li><li>重量级锁依赖于操作系统底层的 <strong>互斥量（Mutex）</strong> 来实现。</li><li>对象的 Mark Word 会存储一个指向 Monitor（监视器）对象的指针。</li><li>未能获取锁的线程将被阻塞，并进入 Monitor 的等待队列中，涉及用户态到内核态的切换，这是所有锁状态中开销最大的。</li></ul></li></ul><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock 的实现原理核心在于 AbstractQueuedSynchronizer（AQS） 这个同步器框架。AQS 提供了一套通用的机制，用于构建锁和同步器，而 ReentrantLock 则是基于 AQS 实现的一种独占锁：</p><ul><li><strong>同步状态（state）</strong>：volatile int 类型的变量，用于表示同步状态。<ul><li>state &#x3D;&#x3D; 0：表示当前没有线程持有锁。</li><li>state &gt; 0：表示锁被某个线程持有。对于 ReentrantLock，这个值就是重入的次数。</li></ul></li><li><strong>独占模式</strong>：在 ReentrantLock 中，一次只能有一个线程持有锁，属于独占模式。</li><li><strong>CLH 同步队列（等待队列）</strong>：双向链表，用于存放因未能获取锁而被阻塞的线程。<ul><li>节点（Node）：队列中的每个元素是一个 Node，封装了等待线程、等待状态等信息。</li><li>CAS 操作：所有对 state 变量的修改都是通过 CAS (Compare-And-Swap) 指令来保证原子性的。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReentrantLockExample</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testLock</span><span class="hljs-params">()</span> &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;ReentrantLock example&quot;</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      lock.unlock();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">ReentrantLockExample</span> <span class="hljs-variable">example</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLockExample</span>();<br>    example.testLock();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="AQS（AbstractQueuedSynchronizer：抽象队列同步器）"><a href="#AQS（AbstractQueuedSynchronizer：抽象队列同步器）" class="headerlink" title="AQS（AbstractQueuedSynchronizer：抽象队列同步器）"></a>AQS（AbstractQueuedSynchronizer：抽象队列同步器）</h3><p>AQS（AbstractQueuedSynchronizer，抽象队列同步器）的实现原理核心是：<font color=red> <strong>一个volatile修饰的整型状态变量（state）、一个基于CAS操作的原子性机制，以及一个先进先出（FIFO）的双向等待队列</strong>。 </font>它定义了一套多线程访问共享资源的同步器框架，许多Java并发包中的同步器都基于AQS实现，例如ReentrantLock、Semaphore、CountDownLatch和ReentrantReadWriteLock。</p><ul><li><p><strong>同步状态（state）</strong><br>AQS内部使用一个volatile int类型的变量state来表示共享资源的状态。volatile保证了state变量在多线程之间的可见性。<br>子类需要通过getState()、setState()和compareAndSetState()三个方法来操作这个状态变量。不同的同步器对state的定义不同：</p><ul><li>ReentrantLock：state表示锁被重入的次数。</li><li>Semaphore：state表示当前可用的许可证数量。</li><li>CountDownLatch：state表示需要倒数的次数。</li></ul></li><li><p><strong>同步队列（CLH队列）</strong></p><ul><li>当线程尝试获取资源失败时，AQS会将该线程及其相关信息封装成一个Node节点，并将其加入一个FIFO的双向链表队列中进行阻塞等待。</li><li>这个队列是CLH（Craig, Landin, Hagersten）队列的变体，它将等待中的线程以节点的形式排队。</li><li>队列中的Node节点除了包含线程本身，还包含了<strong>等待模式（独占&#x2F;共享）和等待状态（waitStatus）</strong> 等信息。</li><li>使用双向队列的优势在于，当前一个节点释放锁时，可以更高效地唤醒其后继节点。</li></ul></li><li><p><strong>CAS（比较并交换）机制</strong></p><ul><li>AQS依赖CAS（Compare And Swap）机制来原子性地修改state变量。</li><li>获取资源过程：线程在获取锁时，会尝试使用CAS操作来修改state。如果修改成功，则表示获取锁成功；如果失败，则表明有其他线程正在竞争，该线程需要进入等待队列。</li><li>释放资源过程：当持有锁的线程释放资源时，会通过CAS操作来更新state的值。更新成功后，会唤醒同步队列中的下一个等待线程。</li></ul></li></ul><h3 id="ReentrantLock加锁（lock-）的实现流程"><a href="#ReentrantLock加锁（lock-）的实现流程" class="headerlink" title="ReentrantLock加锁（lock()）的实现流程"></a>ReentrantLock加锁（lock()）的实现流程</h3><ul><li>尝试获取锁：<ul><li>线程尝试使用 CAS 操作修改 state 状态。如果 state 为0，则CAS成功，将state设置为1，表示该线程成功获取锁。</li><li>如果 state 不为0，表明锁已被其他线程持有，或本线程重入。</li></ul></li><li>处理重入：<ul><li>如果发现持有锁的线程是当前线程，则将state加1，实现可重入。</li></ul></li><li>入队等待：<ul><li>如果尝试获取锁失败（state 不为0，且持有锁的线程不是当前线程），线程会创建一个 Node，将其封装起来，然后通过 CAS 操作将这个节点添加到 CLH 队列的尾部，进入等待状态。</li><li>线程会进入自旋，并检查自己是否是队列的第一个节点（头节点的下一个）。</li><li>如果不是，线程会通过 park() 方法挂起自身，进入阻塞状态，等待被唤醒。</li></ul></li><li>公平锁与非公平锁：<ul><li>非公平锁（默认）：新来的线程在入队前会先尝试 CAS 获取锁。如果锁刚好被释放，这个新线程可能比等待队列中的老线程先抢到锁。这提升了吞吐量，但可能导致队列中的线程饥饿。</li><li>公平锁：新来的线程会先检查队列是否为空，只有当队列为空时才会尝试获取锁。如果队列不为空，则直接入队等待，严格按照排队顺序获取锁，但性能稍低。</li></ul></li></ul><h3 id="ReentrantLock解锁（unlock-）的实现流程"><a href="#ReentrantLock解锁（unlock-）的实现流程" class="headerlink" title="ReentrantLock解锁（unlock()）的实现流程"></a>ReentrantLock解锁（unlock()）的实现流程</h3><ul><li>修改同步状态：<ul><li>调用 unlock() 方法时，线程会递减 state 的值。</li></ul></li><li>释放锁：<ul><li>当 state 的值减为0时，表明锁被完全释放。</li></ul></li><li>唤醒等待线程：<ul><li>锁被释放后，会唤醒 CLH 队列中等待时间最长的线程（即队列头节点的后继节点），让它重新尝试获取锁。</li><li>被唤醒的线程会从 park() 处返回，再次尝试获取锁。</li></ul></li></ul><h3 id="公平锁的获取流程"><a href="#公平锁的获取流程" class="headerlink" title="公平锁的获取流程"></a>公平锁的获取流程</h3><p>ReentrantLock 实现公平锁的核心在于 AbstractQueuedSynchronizer（AQS） 中的 CLH 同步队列，以及在尝试获取锁时，对队列是否存在等待者进行额外的检查。公平锁的获取流程与非公平锁的主要区别在于：<strong>新来的线程在尝试获取锁时，会先检查 CLH 队列中是否有比自己等待时间更长的线程</strong>。</p><ul><li>调用 lock()：线程调用 lock() 方法尝试获取锁。</li><li>检查等待队列：<ul><li>ReentrantLock 的公平模式在内部会调用 AQS 的 hasQueuedPredecessors() 方法。</li><li>这个方法会检查同步队列中，当前线程之前是否还有等待的线程。</li></ul></li><li>判断是否可以获取锁：<ul><li>有等待者：如果 hasQueuedPredecessors() 返回 true（即队列中有比自己先到的等待者），即使当前锁是空闲的，新线程也不会尝试通过 CAS 直接抢占锁。它会老老实实地排队，避免“插队”行为。</li><li>无等待者：如果 hasQueuedPredecessors() 返回 false，或者当前线程就是队列中的第一个节点，它才会尝试通过 CAS 竞争锁。</li></ul></li><li>排队等待：如果无法获取锁（无论是排队还是竞争失败），线程都会被封装成一个 Node，加入到 CLH 队列的尾部，进入等待状态，然后被 park() 挂起。</li><li>按序唤醒：当持有锁的线程调用 unlock() 释放锁时，会从 CLH 队列中唤醒等待时间最长的那个线程（即队列头部的下一个节点）。被唤醒的线程才能继续尝试获取锁。</li></ul><h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><p>ReentrantReadWriteLock 的实现原理同样基于 AQS（AbstractQueuedSynchronizer），但它利用一个32位的整型变量 state 分别表示读锁和写锁的状态，从而实现了“读-读共享，读-写互斥，写-写互斥”的并发访问控制。ReentrantReadWriteLock 的核心在于如何巧妙地用一个 int 类型的 state 变量来管理两种不同的锁：</p><ul><li>高16位：用来表示读锁的持有次数，即有多少个线程正在持有读锁。</li><li>低16位：用来表示写锁的持有次数，因为写锁是独占锁，这个值只可能为0或1，而它同时还表示了写锁的重入次数。</li></ul><h3 id="写锁的获取与释放（独占模式）"><a href="#写锁的获取与释放（独占模式）" class="headerlink" title="写锁的获取与释放（独占模式）"></a>写锁的获取与释放（独占模式）</h3><ul><li>获取（acquire）：<ul><li>CAS 尝试：线程尝试通过 CAS 操作将 state 变量的低16位从0设置为1。<ul><li>如果 state 的高16位不为0（即有读锁存在），或者低16位不为0（即有其他线程持有写锁），则获取写锁失败。</li><li>如果 state 为0，表示当前没有其他读锁或写锁，CAS 成功，当前线程成功获取写锁，并进入临界区。</li></ul></li><li>排队等待：如果获取失败，该线程会被封装成一个独占模式的节点，进入 AQS 的同步等待队列。</li></ul></li><li>重入（Reentrancy）：<ul><li>如果当前线程已经持有了写锁，再次尝试获取写锁时，只需要将 state 的低16位加1，实现可重入。</li></ul></li><li>释放（release）：<ul><li>持有写锁的线程调用 unlock() 时，会将 state 的低16位减1。</li><li>如果低16位减为0，则完全释放写锁，并唤醒 AQS 队列中等待的线程（包括读线程和写线程）。</li></ul></li></ul><h3 id="读锁的获取与释放（共享模式）"><a href="#读锁的获取与释放（共享模式）" class="headerlink" title="读锁的获取与释放（共享模式）"></a>读锁的获取与释放（共享模式）</h3><ul><li>获取（acquireShared）：<ul><li>如果 state 的低16位不为0（即有写锁存在），则获取读锁失败。</li><li>如果没有写锁，线程尝试通过 CAS 操作将 state 的高16位加1，表示读锁计数加1。</li></ul></li><li>入队等待：如果获取失败，线程被封装成一个共享模式的节点，进入 AQS 同步队列。</li><li>释放（releaseShared）：<ul><li>线程调用 unlock() 时，会将 state 的高16位减1。</li><li>如果高16位减为0，则释放读锁，并唤醒 AQS 队列中等待的下一个线程。</li></ul></li></ul><h3 id="核心锁状态逻辑"><a href="#核心锁状态逻辑" class="headerlink" title="核心锁状态逻辑"></a>核心锁状态逻辑</h3><ul><li>读-写互斥：写锁在获取时会检查 state 的高16位（读锁状态）和低16位（写锁状态），只要任何一方不为0，就无法获取。这保证了写操作的独占性。</li><li>读-读共享：读锁在获取时，只检查 state 的低16位（写锁状态）。只要没有写锁，多个线程就可以并发地通过 CAS 操作增加 state 的高16位，共享读锁。</li><li>写锁降级：ReentrantReadWriteLock 支持写锁降级。一个持有写锁的线程可以先获取读锁，然后再释放写锁。持有写锁的线程在获取读锁时，因为是同一个线程，所以不会被阻塞。然后释放写锁，其他线程就可以并发地获取读锁了。</li><li>写锁升级（不支持）：ReentrantReadWriteLock 不支持写锁升级，即持有读锁的线程无法直接获取写锁。：如果允许写锁升级，多个持有读锁的线程都试图升级为写锁，将导致死锁。</li></ul><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h2><p>在Java中，CAS（Compare-And-Swap） 的实现原理依赖于底层的 CPU 硬件指令和 Unsafe 类，这是一种实现无锁（lock-free）编程的乐观并发机制。CAS 的基本思想：CAS 操作包含三个核心参数：</p><ul><li>内存位置（V）：要更新的变量在内存中的地址。</li><li>预期旧值（A）：线程认为该变量当前应有的值。</li><li>新值（B）：希望将该变量更新成的值。</li></ul><p><font color=red><strong>CAS 操作的逻辑是：如果内存位置 V 的值与预期旧值 A 相匹配，那么就将 V 的值原子地更新为新值 B；否则，不做任何操作。</strong></font></p><h3 id="Java-CAS-的实现细节"><a href="#Java-CAS-的实现细节" class="headerlink" title="Java CAS 的实现细节"></a>Java CAS 的实现细节</h3><p>Java 中的 CAS 操作主要由 <code>java.util.concurrent.atomic</code> 包下的原子类（如 AtomicInteger）通过调用 <code>sun.misc.Unsafe</code> 类中的 native 方法实现。Unsafe提供了直接操作内存的能力，是Java中CAS操作的基石。compareAndSet 方法它实际上会调用 Unsafe 类的 compareAndSwapxxx() 本地方法。Unsafe 类的本地方法最终会通过 JNI（Java Native Interface） 调用操作系统的 C&#x2F;C++ 代码，并利用 CPU 提供的特殊硬件指令来实现原子操作，在 x86 处理器上，CAS 操作通常会使用 lock cmpxchg 汇编指令， lock cmpxchg指令保证原子性：</p><ul><li>锁定总线：lock 前缀会锁定处理器总线，确保在指令执行期间，其他处理器无法访问共享内存，从而保证了比较和交换操作的原子性。</li><li>缓存一致性：对于多核处理器，lock 指令还会触发 缓存一致性协议（如 MESI），将当前处理器的操作通知给其他处理器，使其他处理器中缓存了该变量的副本无效，确保数据是最新的。</li></ul><h3 id="CAS-的工作流程（以-AtomicInteger-为例）"><a href="#CAS-的工作流程（以-AtomicInteger-为例）" class="headerlink" title="CAS 的工作流程（以 AtomicInteger 为例）"></a>CAS 的工作流程（以 AtomicInteger 为例）</h3><ul><li>获取当前值：线程首先获取共享变量的当前值，例如 int current &#x3D; atomicInt.get()。</li><li>计算新值：线程基于 current 值进行计算，得到新值。</li><li>循环尝试：<ul><li>线程调用 compareAndSet(current, newValue)，尝试将 atomicInt 的值从 current 替换为 newValue。</li><li>如果在这期间，没有其他线程修改该变量，CAS 操作成功，循环结束。</li><li>如果CAS操作失败（说明在线程计算新值期间，有其他线程修改了变量），线程会重新读取最新的值，再次计算新值，并重新尝试 CAS 操作。这个过程被称为自旋，会一直持续直到成功。</li></ul></li></ul><h3 id="CAS-的局限性"><a href="#CAS-的局限性" class="headerlink" title="CAS 的局限性"></a>CAS 的局限性</h3><ul><li>ABA 问题：一个值从 A 变为 B，然后又变回 A。一个线程的 CAS 操作会认为变量没有被修改过，但实际上已经有其他线程对其进行了操作。可以引入版本号或时间戳，使用 AtomicStampedReference 来解决，在更新变量时，也更新版本号，确保操作的唯一性。</li><li>开销大：如果长时间自旋，会占用 CPU 资源。在竞争激烈的情况下，CAS 性能不如传统的锁。</li><li>只能保证一个共享变量的原子操作：对于多个共享变量的操作，CAS 无法保证原子性。要实现多个变量的原子操作，可以考虑使用 AtomicReference 将多个变量封装成一个对象，或者使用传统的锁机制。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>juc</category>
      
      <category>并发</category>
      
      <category>锁</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>juc</tag>
      
      <tag>并发</tag>
      
      <tag>锁</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java内存模型</title>
    <link href="/2025/07/01/java-juc-JMM%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/07/01/java-juc-JMM%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>现代计算机内存架构是一个复杂的多层次系统，旨在平衡速度、容量和成本。其核心特征是 <strong>内存层次结构（Memory Hierarchy）和虚拟内存（Virtual Memory）</strong> 技术。 </p><p><img src="/images/java-juc-JMM%E5%9F%BA%E7%A1%80_%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%88%86%E5%B1%82%E5%86%85%E5%AD%98%E6%9E%B6%E6%9E%84.png"></p><span id="more"></span><p>计算机内存被组织成一个金字塔形的层次结构，层级越高，速度越快、成本越高、容量越小；层级越低，速度越慢、成本越低、容量越大。 </p><ul><li>寄存器 (Registers): 位于CPU内部，速度最快，容量最小。它们用于存储CPU当前正在执行的指令和数据，供CPU直接访问和修改。</li><li>高速缓存 (Cache Memory): 通常分为L1、L2、L3多级缓存，集成在或靠近CPU核心。它存储从主内存中频繁使用的数据和指令的副本，以减少访问主内存的延迟。L1缓存最小最快，L3最大最慢。高速缓存使用快速但昂贵的SRAM（静态随机存取存储器）实现。</li><li>主内存 (Main Memory &#x2F; RAM): 即我们通常所说的内存条，使用DRAM（动态随机存取存储器）实现。它的容量远大于缓存，但速度比缓存慢。操作系统和当前运行的程序及数据都驻留在主内存中。</li></ul><p>现代计算机分层内存架构虽然提高了内存访问性能，但同时也引入了新的挑战：</p><ul><li>缓存一致性协议 (Cache Coherence Protocols): 在多核系统中，不同核心可能有同一个共享数据的本地缓存副本。硬件通过缓存一致性协议（如MESI协议）来确保数据在所有缓存中的一致性。</li><li>指令重排序 (Instruction Reordering): 编译器和CPU为了优化执行效率，可能会改变指令的执行顺序，只要不影响单线程下的结果。</li><li>写缓冲区 (Write Buffers): CPU将数据写入缓存或主内存时，可能不会立即完成，而是先写入一个写缓冲区，然后继续执行后续指令。</li></ul><p>这些优化虽然提升了性能，但在多线程环境下可能导致数据不一致或不可见的问题，这也是Java内存模型等高级语言规范需要解决的核心问题。</p><h2 id="java内存模型"><a href="#java内存模型" class="headerlink" title="java内存模型"></a>java内存模型</h2><p><strong>Java内存模型（Java Memory Model, JMM）</strong> 是一个抽象概念模型，它定义了在多线程环境中，一个线程对共享变量的写入何时对其他线程可见，以及如何保证操作的原子性、可见性和有序性，其核心思想是为了屏蔽底层硬件和操作系统的内存访问差异，确保Java并发程序在各种平台上都能保持一致的行为。在Java内存模型中，它有如下规范：</p><ul><li>所有的变量都存储在主内存（<code>Main Memory</code>）中；</li><li>线程都有一个私有的本地内存（<code>Local Memory</code>），本地内存中存储了该线程以读&#x2F;写共享变量的拷贝副本；</li><li>线程对变量的所有操作都必须在本地内存中进行，而不能直接读写主内存；</li><li>不同的线程之间无法直接访问对方本地内存中的变量。</li></ul><p><img src="/images/java-juc-JMM%E5%9F%BA%E7%A1%80_java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png"></p><p>在上面模型中主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存这一类的实现细节，Java内存模型中定义了以下8种操作来完成，Java虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的：</p><ul><li><code>lock（锁定）</code>​：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</li><li><code>unlock（解锁）</code>​：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li><li><code>read（读取）​</code>：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li><li><code>load（载入）</code>​：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li><li><code>use（使用）</code>​：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li><li><code>assign（赋值）</code>​：作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li><li><code>store（存储）​</code>：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。</li><li><code>write（写入）</code>​：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</li></ul><p><img src="/images/java-juc-JMM%E5%9F%BA%E7%A1%80_java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%AE%9A%E4%B9%89%E8%AF%BB%E5%86%99.png"></p><p>从上图中，如果要把一个变量从内存中复制到工作内存中，就需要顺序的执行 read 和 load 操作，如果把变量从工作内存同步到主内存中，就需要执行 store 和 write 操作。 Java 内存模型只定义了上述操作必须按顺序执行，却没要求是连续执行，如果多个线程同时读取修改同一个共享变量，这种情况可能会导致每个线程中的本地内存中缓存变量一致的问题。</p><p>在并发场景下，java内存模型其实就是围绕着原子性、可见性和有序性三个特性展开：</p><ul><li>原子性（Atomicity）：确保指令是不可分割的。例如，对非long和double类型变量的读取和写入操作是原子性的。</li><li>可见性（Visibility）：当一个线程修改了共享变量的值，其他线程能够立即看到修改后的值。由于工作内存的缓存机制，这一点默认是无法保证的。</li><li>有序性（Ordering）：编译器和处理器为了优化性能，可能会对指令进行重排序。JMM需要确保在不影响单线程程序正确性的前提下，多线程程序的执行顺序也符合预期。</li></ul><h3 id="Happens-Before-原则（核心规则）"><a href="#Happens-Before-原则（核心规则）" class="headerlink" title="Happens-Before 原则（核心规则）"></a>Happens-Before 原则（核心规则）</h3><p>为了解决可见性和有序性问题，JMM引入了Happens-Before关系，它定义了多线程环境中操作之间的顺序关系，是判断数据竞争和线程安全的主要依据。如果操作 A Happens-Before 操作 B (记作 A hb B)， JMM 会保证：</p><ul><li>有序性： 无论编译器和处理器如何重排序，操作 A 的执行结果在时间上看起来总是在操作 B 之前。</li><li>可见性： 操作 A 的所有内存写入效果对操作 B 必须是可见的。</li></ul><p>如果两个操作之间不存在 Happens-Before 关系，那么JVM可以对它们进行任意重排序，其内存可见性也无法保证。以下是 JMM 规范定义的详细 Happens-Before 规则：</p><ul><li><p>程序次序规则 (Program Order Rule)：这是最直观的规则，适用于单线程环境。在一个线程内，控制流前面的操作 Happens-Before 于控制流后面的操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 线程 A</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;      <span class="hljs-comment">// 操作 A1</span><br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;      <span class="hljs-comment">// 操作 A2</span><br><span class="hljs-comment">// A1 hb A2，尽管可能发生重排序，但单线程内的结果一致性得到保证。</span><br></code></pre></td></tr></table></figure></li><li><p>锁定规则 (Monitor Lock Rule)：这条规则涉及 synchronized 关键字（或显式锁 Lock）。一个线程对一个监视器（Monitor）的 <strong>解锁（unlock）操作 Happens-Before 于后续任何线程对同一个监视器的加锁（lock）</strong> 操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 线程 A</span><br><span class="hljs-keyword">synchronized</span> (lockObj) &#123;<br>    data = <span class="hljs-number">10</span>; <span class="hljs-comment">// 操作 A1 (包含隐式解锁操作 A2)</span><br>&#125;<br><span class="hljs-comment">// 线程 B</span><br><span class="hljs-keyword">synchronized</span> (lockObj) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> data; <span class="hljs-comment">// 操作 B1 (包含隐式加锁操作 B0)</span><br>&#125;<br><span class="hljs-comment">// A2 hb B0，因此 A1 对 data 的写入对 B1 可见。</span><br></code></pre></td></tr></table></figure></li><li><p>volatile 变量规则 (Volatile Variable Rule)：这条规则保证了 volatile 变量的可见性，并不保证原子性。对一个 volatile 变量的 <strong>写入（write）操作 Happens-Before 于后续任何线程对同一个 volatile 变量的读取（read）</strong> 操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 线程 A</span><br><span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// ...</span><br>flag = <span class="hljs-literal">true</span>; <span class="hljs-comment">// 操作 A1 (写 volatile)</span><br><br><span class="hljs-comment">// 线程 B</span><br><span class="hljs-keyword">while</span>(!flag) &#123;<br>    <span class="hljs-comment">// 等待</span><br>&#125;<br><span class="hljs-comment">// 操作 B1 (读 volatile)</span><br><span class="hljs-comment">// A1 hb B1，A1对flag的修改对B1立即可见。</span><br></code></pre></td></tr></table></figure></li><li><p>线程启动规则 (Thread Start Rule)：这条规则保证了线程启动时的初始化可见性。在一个线程对象上调用 start() 方法（操作 A） Happens-Before 于该线程中的任何操作（操作 B）。如：线程 A 调用 threadB.start() 之前对共享变量的所有修改，在 threadB 中都是可见的。 </p></li><li><p>线程加入规则 (Thread Join Rule)：这条规则保证了线程终止后的数据可见性。如果线程 A 执行 threadB.join() 方法并成功返回，那么线程 B 中的所有操作（操作 A） Happens-Before 于线程 A 从 threadB.join() 方法返回（操作 B）。</p></li><li><p>传递性 (Transitivity)：Happens-Before 关系是可传递的偏序关系。如果操作 A Happens-Before 操作 B，且操作 B Happens-Before 操作 C，那么操作 A Happens-Before 操作 C。</p></li><li><p>final 字段规则：对象构建过程中对 final 字段的写入 Happens-Before 于将对象的引用发布给其他线程（只要构造函数正确执行且没有“逸出”）。</p></li></ul><h3 id="内存屏障（Memory-Barriers）"><a href="#内存屏障（Memory-Barriers）" class="headerlink" title="内存屏障（Memory Barriers）"></a>内存屏障（Memory Barriers）</h3><p>Java内存模型（JMM）中的 <strong>内存屏障（Memory Barriers）</strong> 是一种底层指令，用于强制处理器执行特定的内存操作顺序，并确保不同CPU核心之间的缓存数据一致性。编码工作中通常不需要直接使用内存屏障，而是通过使用Java并发关键字（如 volatile、synchronized）来间接利用它们，JVM编译器在生成机器码时会自动插入适当的内存屏障指令，以确保遵循JMM的 Happens-Before 规则。Java内存模型中内存屏障主要解决两个问题：</p><ul><li><strong>防止指令重排序（Reordering）</strong>： 现代编译器和处理器为了优化性能，会重排指令执行顺序。内存屏障会像一道“栅栏”，阻止特定类型指令越过屏障，从而维护程序的有序性。</li><li><strong>强制缓存同步（Cache Synchronization）</strong>：确保一个线程对共享变量的修改能够及时地从其本地工作内存（CPU缓存）刷新到主内存，并且其他线程能够从主内存读取到最新值，从而保证可见性。</li></ul><p>根据操作类型（加载 Load - 读取，存储 Store - 写入），JMM抽象出四种主要的内存屏障类型： </p><table><thead><tr><th align="left">屏障类型</th><th align="left">作用描述</th></tr></thead><tbody><tr><td align="left"><strong>LoadLoad</strong></td><td align="left">确保屏障前的所有读操作（Load）都在屏障后的所有读操作之前完成并发可见。</td></tr><tr><td align="left"><strong>StoreStore</strong></td><td align="left">确保屏障前的所有写操作（Store）都在屏障后的所有写操作之前完成并发可见（刷新到主内存）。</td></tr><tr><td align="left"><strong>LoadStore</strong></td><td align="left">确保屏障前的所有读操作都在屏障后的所有写操作之前完成。</td></tr><tr><td align="left"><strong>StoreLoad</strong></td><td align="left">确保屏障前的所有写操作都在屏障后的所有读操作之前完成。这是最昂贵的屏障，因为它强制刷新写缓冲区并使其他CPU缓存失效。</td></tr></tbody></table><p>内存屏障在并发原语中的应用：</p><ul><li>volatile 变量：<ul><li>写入 volatile 变量时： JVM 会在写入操作前插入 StoreStore 屏障，并在写入操作后插入 StoreLoad 屏障。这确保了在写入 volatile 变量之前的所有普通写入操作都已完成，并且该写入操作对后续任何线程的读取都立即可见。</li><li>读取 volatile 变量时： JVM 会在读取操作后插入 LoadLoad 和 LoadStore 屏障。这确保了读取操作总是获取最新值，并且该读取后的任何操作都不会被重排序到读取操作之前。</li></ul></li><li>synchronized（锁）：<ul><li>进入 synchronized 块（获取锁）： 相当于执行了一个 acquire 操作，通常会插入一个全屏障（Full Fence），确保后续操作不会被重排序到锁获取之前，并从主内存同步数据。</li><li>退出 synchronized 块（释放锁）： 相当于执行了一个 release 操作，也会插入一个全屏障，确保屏障前的所有操作（对共享变量的修改）都刷新到主内存，对其他线程可见。</li></ul></li></ul><p>总之：内存屏障是JMM底层实现可见性和有序性的关键机制，它弥合了Java语言规范与不同硬件平台内存模型之间的差异。 </p><h3 id="MESI-协议-Modified-Exclusive-Shared-Invalid-Protocol"><a href="#MESI-协议-Modified-Exclusive-Shared-Invalid-Protocol" class="headerlink" title="MESI 协议(Modified, Exclusive, Shared, Invalid Protocol)"></a>MESI 协议(Modified, Exclusive, Shared, Invalid Protocol)</h3><p>MESI含义：</p><ul><li><code>M(Modified，已修改)</code>：<code>MESI</code>第一个字母M，代表着<code>CPU</code>当前<code>L1 cache</code>中某个变量i的状态被修改了，而且这个数据在其他核心中都没有。</li><li><code>E(Exclusive，独占)</code>：说白了就是CPUA将数据加载自己的L1 cache时，其他核心的cache中并没有这个数据，所以CPUA将这个数据加载到自己的cache时标记为E。</li><li><code>(S：Shared，共享)</code>：说明CPUA在加载这个数据时，其他CPU已经加载过这个数据了，这时CPUA就会从其他CPU中拿到这个数据并加载到L1 cache中，并且所有拥有这个值的CPU都会将cache中的这个值标记为S。</li><li><code>(I：Invalidated，已失效)</code>：当CPUA修改了L1 cache中的变量i时，发现这个值是S即共享的数据，那么就需要通知其他核心这个数据被改了，其他CPU都需要将cache中的这个值标为I，后面要操作的时，必须拿到最新的数据在进行操作。</li></ul><p>JMM是一个语言级别的规范，定义了多线程编程的规则，JMM 通过 <strong>内存屏障（Memory Barriers）</strong> 作为桥梁，将抽象的保证转换为具体的硬件操作，而MESI协议就是执行这些硬件操作的底层机制之一。</p><p>当Java代码中使用 volatile 或 synchronized 等关键字时，JVM 编译器会插入特定的内存屏障指令（如 x86 架构下的 lock 前缀指令）。这些硬件指令会触发CPU使用其内部的缓存一致性协议（如MESI）来协调内存访问：</p><ul><li>保证可见性：当一个线程写入一个 volatile 变量时，JVM会插入一个屏障，强制将工作内存（CPU缓存）中的修改数据刷新回主内存。在硬件层面上，这会触发一个 <strong>写失效（Write Invalidate）</strong> 操作（通过总线命令），使其他所有CPU缓存中对应的缓存行副本变为<strong>失效（Invalid）</strong> 状态。当其他线程尝试读取该变量时，发现本地缓存行为<strong>失效</strong>状态，就会强制从主内存或拥有最新数据的其他核心缓存中重新加载最新值，从而保证了可见性。</li><li>保证有序性：内存屏障阻止了编译器和处理器的指令重排序。在硬件层面，这确保了在屏障之前的内存操作先于屏障之后的操作执行，满足了JMM的有序性要求。</li></ul><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>Java中的 volatile 关键字是Java内存模型（JMM）提供的一种轻量级的同步机制，它主要用于保证共享变量的<strong>可见性（Visibility）和有序性（Ordering）</strong>，但不保证原子性。volatile 在实现上是通过插入 <strong>内存屏障（Memory Barriers）</strong> 来确保对变量的读写操作能够直接与主内存交互，并防止指令重排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> a;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">update</span><span class="hljs-params">()</span> &#123;<br>      a = <span class="hljs-number">1</span>;<br>  &#125;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>      <span class="hljs-type">Test</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Test</span>();<br>      test.update();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>查看字节码：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs text">public class Test &#123;<br><br>  // 字段声明 (private volatile int a;)<br>  // (这部分通常在 javap -c 中不显示，但在类文件中有定义)<br><br>  public Test();<br>    Code:<br>       0: aload_0<br>       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V<br>       4: return<br><br>  public void update();<br>    Code:<br>       0: aload_0<br>       1: iconst_1<br>       2: putfield      #7                  // Field a:I<br>       5: return<br><br>  public static void main(java.lang.String[]);<br>    Code:<br>       0: new           #8                  // class Test<br>       3: dup<br>       4: invokespecial #13                 // Method &quot;&lt;init&gt;&quot;:()V<br>       7: astore_1<br>       8: aload_1<br>       9: invokevirtual #14                 // Method update:()V<br>      12: return<br>&#125;<br></code></pre></td></tr></table></figure><p>上述字节码中，并没有看到 volatile，这是因为 volatile 关键字是一个字段修饰符，它不是一个字节码指令。它告诉 Java 虚拟机（JVM），在执行 putfield（写入）或 getfield（读取）这个特定字段（#7）时，必须遵守特殊的内存可见性和有序性规则，即插入内存屏障，防止指令重排序。字节码指令本身（putfield）保持不变，但是 JVM 在解释和执行这条指令时，会检查字段的 volatile 标记，并采取与非 volatile 字段不同的操作。因此，volatile 关键字的魔力在于 JVM 如何执行 putfield 指令，而不是在于生成不同的指令。</p><h3 id="CPU缓存一致性协议（MESI协议）对volatile支持-硬件层面"><a href="#CPU缓存一致性协议（MESI协议）对volatile支持-硬件层面" class="headerlink" title="CPU缓存一致性协议（MESI协议）对volatile支持 - 硬件层面"></a>CPU缓存一致性协议（MESI协议）对volatile支持 - 硬件层面</h3><p>查看上述测试代码的汇编码(重点关注update())：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs text">==================== C2-Compiled Method ====================<br>                   (Test::update)<br>------------------------------------------------------------<br>[Code]<br>  0x00007f9c8d10a2e0: mov    %eax,-0x14000(%rsp)  ; 方法序言 (prologue)<br>  0x00007f9c8d10a2e7: push   %rbp                 ; 保存 &#x27;rbp&#x27; 寄存器<br>  0x00007f9c8d10a2e8: sub    $0x10,%rsp           ; 分配栈空间<br>  0x00007f9c8d10a2ec: mov    %rdx,0x8(%rsp)       ; (安全点轮询)<br>  <br>  ; -------------------<br>  ; Java 代码: a = 1;<br>  ; -------------------<br>  ; 假设 %rdx 寄存器中是 &#x27;this&#x27; 对象的指针<br>  ; 假设 0x10 (16 字节) 是字段 &#x27;a&#x27; 在对象头之后的偏移量<br>  <br>  0x00007f9c8d10a2f1: movl   $0x1,0x10(%rdx)      ; 步骤 1: 将 1 写入内存 [rdx + 0x10]<br>                                                ; 这就是 a = 1<br>  <br>  ; -------------------<br>  ; VOLATILE <br>  ; -------------------<br>  ; 插入一个内存屏障 (Memory Fence / Barrier) 来保证可见性和有序性<br>  ; 在 x86 上，HotSpot 喜欢使用一个 &quot;lock&quot; 前缀的 &quot;空操作&quot;<br>  <br>  0x00007f9c8d10a2f8: lock addl $0x0,(%rsp)      ; 步骤 2: 内存屏障<br>                                                ; (将 0 添加到栈顶指针，这是一个空操作)<br>                                                ; (但 &#x27;lock&#x27; 前缀是关键)<br>  ; -------------------<br>  ; 方法尾声 (epilogue)<br>  ; -------------------<br>  0x00007f9c8d10a300: add    $0x10,%rsp           ; 恢复栈<br>  0x00007f9c8d10a304: pop    %rbp                 ; 恢复 &#x27;rbp&#x27; 寄存器<br>  0x00007f9c8d10a305: retq                        ; 返回<br>[Constants]<br></code></pre></td></tr></table></figure><p>从上面可以看到，当写入 volatile 变量通常会使用一个特殊的汇编指令，例如，带有 lock 前缀的指令，如 lock addl 或直接是 movl 伴随内存屏障。在硬件层面发生如下操作：</p><ul><li>强制刷新缓存： lock 前缀指令会导致CPU缓存中的数据被立即写回主内存。</li><li>总线嗅探与失效： 这个写入操作会产生一个总线信号，其他CPU核心通过“总线嗅探”机制监听到这个信号。</li><li>缓存失效： 其他CPU核心会检查自己本地缓存中是否有这个变量的副本，如果有，则标记为“失效”（Invalidated）。</li><li>重新加载： 当其他线程再次尝试读取该变量时，发现本地缓存已失效，被迫从主内存中重新加载最新数据，从而实现了可见性。</li></ul><h3 id="内存屏障对volatile支持-JVM层面"><a href="#内存屏障对volatile支持-JVM层面" class="headerlink" title="内存屏障对volatile支持 - JVM层面"></a>内存屏障对volatile支持 - JVM层面</h3><p>内存屏障是一种特殊的CPU指令，它可以防止编译器和处理器对指令进行重排序。JVM在对volatile变量进行读写时，会插入特定类型的内存屏障，以确保操作的顺序性。</p><ul><li>对volatile变量进行写操作时：<ul><li>写入前屏障（StoreStore Barrier）：确保在写volatile变量之前，所有普通写操作都已完成，并且不会被重排到volatile写之后。</li><li>写入后屏障（StoreLoad Barrier）：这个屏障会刷新工作内存（CPU缓存）中的数据到主内存，并使其他CPU缓存中该变量的副本失效。它确保在写volatile变量之后，其后的任何读操作都不会被重排到volatile写之前。</li></ul></li><li>对volatile变量进行读操作时：<ul><li>读取后屏障（LoadLoad Barrier）：确保在读volatile变量之后，其后的任何普通读操作都不会被重排到volatile读之前。</li><li>读取后屏障（LoadStore Barrier）：确保在读volatile变量之后，其后的任何普通写操作都不会被重排到volatile读之前。</li></ul></li></ul><h3 id="volatile特性实现"><a href="#volatile特性实现" class="headerlink" title="volatile特性实现"></a>volatile特性实现</h3><p>volatile特性：<font color=red><strong>对一个 volatile 字段的写入操作（Write）， Happens-Before（先行发生） 于后续任何线程对同一个 volatile 字段的读取操作（Read）</strong></font>。</p><p>volatile在底层实现上是通过 <strong>软件层面（JVM）和硬件层面（CPU）</strong> 协同工作的过程。JVM通过插入内存屏障来限制指令重排，并结合CPU的缓存一致性协议（通过lock指令）来确保跨线程的内存可见性，从而为开发者提供了轻量级的线程同步保障。它解决了共享变量的可见性与有序性，但并不完全保证原子性，只能保证单个读&#x2F;写操作的原子性，但对于复合操作（如 i++，它包含“读-改-写”三个独立步骤）则无法保证原子性。</p><ul><li>解决可见性问题：<ul><li>写操作：volatile写操作通过内存屏障和缓存一致性协议，强制将修改后的值立即写回主内存，并使其他线程的缓存副本失效。</li><li>读操作：volatile读操作会先检查缓存副本是否失效，如果失效则强制从主内存重新读取最新值，从而保证了读取到的是最新的数据。</li></ul></li><li>解决有序性问题：<ul><li>禁止重排：JVM插入的内存屏障确保了volatile操作不会被编译器或处理器重排。</li><li>happens-before保障：<ul><li>volatile写：一个线程对volatile变量的写入，happens-before后续任何线程对该变量的读取。这意味着，在volatile写入之前的所有操作（包括对非volatile变量的写入），其结果都会对后续读取该volatile变量的线程可见。</li><li>volatile读：一个线程对volatile变量的读取，happens-before后续任何线程对该变量的写入。这意味着，在volatile读取之后的所有操作，其结果都会看到volatile读取时的最新值。</li></ul></li></ul></li></ul><h3 id="volatile对性能的影响"><a href="#volatile对性能的影响" class="headerlink" title="volatile对性能的影响"></a>volatile对性能的影响</h3><p>volatile 关键字在多线程编程中用于解决变量的可见性和有序性问题，但它会对性能产生一定的影响。volatile对性能的影响主要表现在四个个方面：</p><ul><li>禁止编译器优化：volatile 会告诉编译器该变量可能会被程序之外的因素（如硬件、中断、其他线程）修改，因此编译器不能对变量的读写操作进行优化（如缓存、指令重排）。<ul><li>强制从主内存读写：每次访问 volatile 变量时，编译器必须生成代码直接从主内存读取或写入，而不是使用寄存器或 CPU 缓存；</li><li>指令重排限制：volatile 会插入内存屏障（Memory Barrier），禁止编译器和处理器对 volatile 变量的操作进行重排序，这会增加额外的指令开销。</li></ul></li><li>内存屏障的开销：volatile 的底层实现依赖于内存屏障（Memory Barrier），它会强制处理器刷新缓存或无效化其他核心的缓存行。<ul><li>写操作更慢：volatile 写操作需要将数据立即刷新到主内存，而普通变量可能在 CPU 缓存中停留更长时间；</li><li>多核处理器的同步开销：在多核系统中，volatile 写操作可能导致其他核心的缓存行失效，触发缓存一致性协议（如 MESI 协议），增加总线流量和延迟。</li></ul></li><li>频繁访问的性能瓶颈：如果 volatile 变量被频繁读写，每次操作都绕过缓存直接访问主内存，会导致性能显著下降。<ul><li>主内存访问速度比缓存慢：主内存的访问延迟远高于 CPU 寄存器或 L1&#x2F;L2 缓存（例如，L1 缓存访问延迟约为 1-3 纳秒，而主内存访问延迟约为 100-200 纳秒）。</li><li>高并发下的竞争：多个线程频繁读写 volatile 变量可能导致缓存行竞争（False Sharing），进一步降低性能。</li></ul></li><li>缓存行竞争：多个线程频繁修改不同 volatile 变量时，可能因缓存行竞争（False Sharing）导致性能下降。通过填充字段（Padding）对齐缓存行，避免竞争。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在并发编程中，我们需要处理两个关键问题：<strong>线程之间如何通信及线程之间如何同步</strong>。Java 的并发采用的是共享内存模型，Java 线程之间的通信总是隐式进行，整个通信过程对程序员完全透明，在这种隐式消息传递实现中必须要保证可见性、原子性、有序性，从而保证并发的安全性。在实现上，JMM通过定义主内存与工作内存的交互，并使用Happens-Before规则和内存屏障等机制，为Java并发编程提供了可靠的内存可见性和有序性保证，使开发者能够编写出平台一致的、线程安全的程序。 </p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>juc</category>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>juc</tag>
      
      <tag>并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql-sql基础</title>
    <link href="/2025/06/17/mysql-sql%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/06/17/mysql-sql%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p><strong>mysql中主要包括以下五大类：</strong></p><ul><li><strong>整数类型</strong> ：BIT、BOOL、TINY INT、SMALL INT、MEDIUM INT、 INT、 BIG INT</li><li><strong>浮点数类型</strong> ：FLOAT、DOUBLE、DECIMAL</li><li><strong>字符串类型</strong> ：CHAR、VARCHAR、TINY TEXT、TEXT、MEDIUM TEXT、LONGTEXT、TINY BLOB、BLOB、MEDIUM BLOB、LONG BLOB</li><li><strong>日期类型</strong> ：Date、DateTime、TimeStamp、Time、Year</li><li><strong>其他数据类型</strong>：BINARY、VARBINARY、ENUM、SET、Geometry、Point、MultiPoint、LineString、MultiLineString、Polygon、GeometryCollection等</li></ul><span id="more"></span><ol><li><strong>整型：</strong></li></ol><table><thead><tr><th>MySQL数据类型</th><th>含义（有符号）</th></tr></thead><tbody><tr><td>tinyint(m)</td><td>1个字节 范围(-128~127)</td></tr><tr><td>smallint(m)</td><td>2个字节 范围(-32768~32767)</td></tr><tr><td>mediumint(m)</td><td>3个字节 范围(-8388608~8388607)</td></tr><tr><td>int(m)</td><td>4个字节 范围(-2147483648~2147483647)</td></tr><tr><td>bigint(m)</td><td>8个字节 范围(+-9.22*10的18次方)</td></tr></tbody></table><p>int(m) m 用于指定显示宽度，int(5)表示5位数的宽度。注意显示宽度属性不能控制列可以存储的值范围，显示宽度属性通常由应用程序用于格式化整数值。</p><ol start="2"><li><strong>浮点型：</strong></li></ol><table><thead><tr><th>数据类型</th><th>含义</th></tr></thead><tbody><tr><td>float(m,d)</td><td>单精度浮点型 4字节 m总个数，d小数位</td></tr><tr><td>double(m,d)</td><td>双精度浮点型 8字节 m总个数，d小数位</td></tr></tbody></table><p>浮点型数据类型会有精度丢失的问题，比如小数位设置6位，存入0.45，0.45转换成二进制是个无限循环小数0.01110011100…，无法准确表示，存储的时候会发生精度丢失。</p><p>不论是定点还是浮点类型，如果用户指定的精度超出精度范围，则会四舍五入进行处理。</p><ol start="3"><li><p><strong>定点数：</strong><br>浮点型在数据库中存放的是近似值，而定点类型在数据库中存放的是精确值，不会丢失精度。定点数以字符串形式存储。decimal(m,d) 参数m是总个数，d是小数位。</p></li><li><p><strong>字符串：</strong></p></li></ol><table><thead><tr><th>MySQL数据类型</th><th>含义</th></tr></thead><tbody><tr><td>char(n)</td><td>固定长度，最多255个字节</td></tr><tr><td>varchar(n)</td><td>可变长度，最多65535个字节</td></tr><tr><td>tinytext</td><td>可变长度，最多255个字节</td></tr><tr><td>text</td><td>可变长度，最多65535个字节</td></tr><tr><td>mediumtext</td><td>可变长度，最多2的24次方-1个字节</td></tr><tr><td>longtext</td><td>可变长度，最多2的32次方-1个字节</td></tr></tbody></table><p>查询速度：char &gt; varchar &gt; text</p><ul><li>char：定长，效率高，一般用于固定长度的表单提交数据存储 ；例如：身份证号，手机号，电话，密码等。char长度不足时，在右边使用空格填充，而varchar值保存时只保存需要的字符数。</li><li>varchar：不定长，效率偏低，内容开头用1到2个字节表示实际长度（长度超过255时需要2个字节），因此最大长度不能超过65535。</li><li>nvarchar（存储的是Unicode数据类型的字符）不管是一个字符还是一个汉字，都存为2个字节 ，一般用作中文或者其他语言输入，这样不容易乱码 ；varchar存储汉字是2个字节，其他字符存为1个字节 ，varchar适合输入英文和数字。</li><li>text：不需要指定存储长度，能用varchar就不用text。</li></ul><ol start="5"><li><strong>二进制数据(BLOB)：</strong></li></ol><p>二进制数据类型可存储任何数据，如图像、多媒体、文档等。BLOB和TEXT存储方式不同，TEXT以文本方式存储，英文存储区分大小写；而Blob是以二进制方式存储，不区分大小写。</p><ol start="6"><li><strong>日期时间类型:</strong></li></ol><table><thead><tr><th>MySQL数据类型</th><th>含义</th></tr></thead><tbody><tr><td>date</td><td>日期 ‘2008-12-2’</td></tr><tr><td>time</td><td>时间 ‘12:25:36’</td></tr><tr><td>datetime</td><td>日期时间 ‘2008-12-2 22:06:44’</td></tr><tr><td>timestamp</td><td>自动存储记录修改时间</td></tr></tbody></table><p>若定义一个字段为timestamp，这个字段里的时间数据会随其他字段修改的时候自动刷新，所以这个数据类型的字段可以存放这条记录最后被修改的时间。</p><h2 id="基础sql命令"><a href="#基础sql命令" class="headerlink" title="基础sql命令"></a>基础sql命令</h2><ol><li><p><strong>服务管理</strong></p><p>启动服务：<code>service mysqld start</code></p><p>关闭服务：<code>service mysqld stop</code></p><p>启动客户端：<code>mysql -uroot -p</code> -u 后不要有空格（Ubuntu有空格）</p></li><li><p><strong>表操作</strong></p></li></ol><ul><li><p>创建表：<code>create table user (id int, name varchar(10))</code></p></li><li><p>清空表数据：<code>truncate table user;</code></p></li><li><p>重命名表：<code>RENAME TABLE cusmtomers TO cust</code></p></li><li><p>更新表：</p><ul><li>添加列：<code>ALTER TABLE ADD phone char(2)</code></li><li>删除列：<code>ALTER TABLE vendors DROP COLUMN vend_phone;</code></li><li>更改列：<code>ALTER TABLE vendors MODIFY vend_phone CHAR(16);</code></li></ul></li><li><p>查看表结构：<code>desc table_name/select columns from table_name</code>或<code>SHOW CREATE db</code> | <code>SHOW CREATE table</code>：显示创建特定数据库或表的MySQL语句</p></li><li><p>删除表（truncate、delete与drop）：<code>DROP TABLE cumstomers</code></p><ul><li><strong>相同点：</strong><ul><li>truncate和不带where子句的delete、以及drop都会删除表内的数据。</li><li>drop、truncate都是DDL语句(数据定义语言)，执行后会自动提交。</li></ul></li><li><strong>不同点：</strong><ul><li>truncate 和 delete 只删除数据不删除表的结构；drop 语句将删除表的结构被依赖的约束、触发器、索引；</li><li>速度，一般来说: drop&gt; truncate &gt; delete。</li></ul></li></ul></li></ul><ol start="3"><li><strong>查询</strong></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>    [<span class="hljs-keyword">ALL</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">DISTINCT</span> <span class="hljs-operator">|</span> DISTINCTROW ]<br>    [HIGH_PRIORITY]<br>    [STRAIGHT_JOIN]<br>    [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT]<br>    [SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS]<br>    select_expr [, select_expr] ...<br>    [into_option]<br>    [<span class="hljs-keyword">FROM</span> table_references<br>      [<span class="hljs-keyword">PARTITION</span> partition_list]]<br>    [<span class="hljs-keyword">WHERE</span> where_condition]<br>    [<span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> &#123;col_name <span class="hljs-operator">|</span> expr <span class="hljs-operator">|</span> position&#125;, ... [<span class="hljs-keyword">WITH</span> <span class="hljs-keyword">ROLLUP</span>]]<br>    [<span class="hljs-keyword">HAVING</span> where_condition]<br>    [<span class="hljs-keyword">WINDOW</span> window_name <span class="hljs-keyword">AS</span> (window_spec)<br>        [, window_name <span class="hljs-keyword">AS</span> (window_spec)] ...]<br>    [<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> &#123;col_name <span class="hljs-operator">|</span> expr <span class="hljs-operator">|</span> position&#125;<br>      [<span class="hljs-keyword">ASC</span> <span class="hljs-operator">|</span> <span class="hljs-keyword">DESC</span>], ... [<span class="hljs-keyword">WITH</span> <span class="hljs-keyword">ROLLUP</span>]]<br>    [LIMIT &#123;[<span class="hljs-keyword">offset</span>,] row_count <span class="hljs-operator">|</span> row_count <span class="hljs-keyword">OFFSET</span> <span class="hljs-keyword">offset</span>&#125;]<br>    [into_option]<br>    [<span class="hljs-keyword">FOR</span> &#123;<span class="hljs-keyword">UPDATE</span> <span class="hljs-operator">|</span> SHARE&#125;<br>        [<span class="hljs-keyword">OF</span> tbl_name [, tbl_name] ...]<br>        [NOWAIT <span class="hljs-operator">|</span> <span class="hljs-keyword">SKIP</span> LOCKED]<br>      <span class="hljs-operator">|</span> LOCK <span class="hljs-keyword">IN</span> SHARE MODE]<br>    [into_option]<br><br>into_option: &#123;<br>    <span class="hljs-keyword">INTO</span> OUTFILE <span class="hljs-string">&#x27;file_name&#x27;</span><br>        [<span class="hljs-keyword">CHARACTER SET</span> charset_name]<br>        export_options<br>  <span class="hljs-operator">|</span> <span class="hljs-keyword">INTO</span> DUMPFILE <span class="hljs-string">&#x27;file_name&#x27;</span><br>  <span class="hljs-operator">|</span> <span class="hljs-keyword">INTO</span> var_name [, var_name] ...<br>&#125;<br><br>export_options:<br>    [&#123;FIELDS <span class="hljs-operator">|</span> COLUMNS&#125;<br>        [TERMINATED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;string&#x27;</span>]<br>        [[OPTIONALLY] ENCLOSED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;char&#x27;</span>]<br>        [ESCAPED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;char&#x27;</span>]<br>    ]<br>    [LINES<br>        [STARTING <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;string&#x27;</span>]<br>        [TERMINATED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;string&#x27;</span>]<br>    ]<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> vend_id <span class="hljs-keyword">FROM</span> products;<br><br>#开始位置，行数<span class="hljs-operator">|</span>返回从第<span class="hljs-number">0</span>行开始的<span class="hljs-number">5</span>行数据<br><span class="hljs-keyword">SELECT</span> prod_name <span class="hljs-keyword">FROM</span> products LIMIT <span class="hljs-number">0</span>, <span class="hljs-number">5</span>; <br><br># 先按名称排序，再按价格排序 <span class="hljs-operator">|</span> <span class="hljs-keyword">DESC</span>降序排列，默认<span class="hljs-keyword">ASC</span>升序<br><span class="hljs-keyword">SELECT</span> prod_name <span class="hljs-keyword">FROM</span> products <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> prod_name, prod_price <span class="hljs-keyword">DESC</span>;<br><br># <span class="hljs-operator">=</span>等于, <span class="hljs-operator">&lt;&gt;</span>不等于, <span class="hljs-operator">!=</span>不等于, <span class="hljs-operator">&lt;</span>小于, <span class="hljs-operator">&lt;=</span>小于等于, <span class="hljs-keyword">BETWEEN</span>两值之间 <br><span class="hljs-keyword">SELECT</span> vend_id, prod_name <span class="hljs-keyword">FROM</span> products <span class="hljs-keyword">WHERE</span> vend_id <span class="hljs-operator">&lt;&gt;</span> <span class="hljs-number">1003</span>;<br><span class="hljs-keyword">SELECT</span> prod_name <span class="hljs-keyword">FROM</span> products <span class="hljs-keyword">WHERE</span> prod_price <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NULL</span>;<br><br># <span class="hljs-keyword">AND</span>优先级大于<span class="hljs-keyword">OR</span><br><span class="hljs-keyword">SELECT</span> prod_name, prod_price <span class="hljs-keyword">FROM</span> products <span class="hljs-keyword">WHERE</span> vend_id <span class="hljs-operator">=</span> <span class="hljs-number">1002</span> <span class="hljs-keyword">OR</span> vend_id <span class="hljs-operator">=</span> <span class="hljs-number">1003</span> <span class="hljs-keyword">AND</span> prod_price <span class="hljs-operator">&gt;=</span> <span class="hljs-number">10</span>; <br><br># <span class="hljs-keyword">IN</span>操作符一般比<span class="hljs-keyword">OR</span>操作符清单执行更快。<span class="hljs-keyword">IN</span>的最大优点是可以包含其他<span class="hljs-keyword">SELECT</span>语句，使得能够更动态地建立<span class="hljs-keyword">WHERE</span>子句。<br><span class="hljs-keyword">SELECT</span> prod_name, product_price <span class="hljs-keyword">FROM</span> products <span class="hljs-keyword">WHERE</span> vend_id <span class="hljs-keyword">IN</span> (<span class="hljs-number">1002</span>, <span class="hljs-number">1003</span>) <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> prod_name;<br><span class="hljs-keyword">SELECT</span> prod_name, product_price <span class="hljs-keyword">FROM</span> products <span class="hljs-keyword">WHERE</span> vend_id <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">IN</span> (<span class="hljs-number">1002</span>, <span class="hljs-number">1003</span>)<br><span class="hljs-keyword">SELECT</span> prod_id, prod_name <span class="hljs-keyword">FROM</span> products <span class="hljs-keyword">WHERE</span> prod_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%jet%&#x27;</span>;<br><br># _ 匹配单个字符<br><span class="hljs-keyword">SELECT</span> prod_id, prod_name <span class="hljs-keyword">FROM</span> products <span class="hljs-keyword">WHERE</span> prod_name <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;_jet_&#x27;</span>;<br><br># 正则表达式<br><span class="hljs-keyword">SELECT</span> prod_name <span class="hljs-keyword">FROM</span> products <span class="hljs-keyword">WHERE</span> prod_name REGEXP <span class="hljs-string">&#x27;1000|2000&#x27;</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> prod_name;<br><br>#匹配<span class="hljs-number">1</span>或<span class="hljs-number">2</span>或<span class="hljs-number">3</span> [<span class="hljs-operator">^</span><span class="hljs-number">123</span>]取反<br><span class="hljs-keyword">SELECT</span> prod_name <span class="hljs-keyword">FROM</span> products <span class="hljs-keyword">WHERE</span> prod_name REGEXP <span class="hljs-string">&#x27;[123] Rely&#x27;</span>  <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> prod_name;<br><br>#匹配<span class="hljs-number">1</span><span class="hljs-number">-5</span>任意一个数字，[a<span class="hljs-operator">-</span>z]同理<br><span class="hljs-keyword">SELECT</span> prod_name <span class="hljs-keyword">FROM</span> products <span class="hljs-keyword">WHERE</span> prod_anem REGEXP <span class="hljs-string">&#x27;[1-5] Ton&#x27;</span>;<br><br>#转义<br><span class="hljs-keyword">SELECT</span> prod_name <span class="hljs-keyword">FROM</span> products <span class="hljs-keyword">WHERE</span> prod_anem REGEXP <span class="hljs-string">&#x27;\\.&#x27;</span>;<br><br>#?匹配它前面的任何字符出现<span class="hljs-number">0</span>次或<span class="hljs-number">1</span>次<br><span class="hljs-keyword">SELECT</span> prod_name <span class="hljs-keyword">FROM</span> products <span class="hljs-keyword">WHERE</span> prod_anem REGEXP <span class="hljs-string">&#x27;\\([0-9] sticks?\\)&#x27;</span>; <br><br>#[:digit:]匹配任意数字<br><span class="hljs-keyword">SELECT</span> prod_name <span class="hljs-keyword">FROM</span> products <span class="hljs-keyword">WHERE</span> prod_anem REGEXP <span class="hljs-string">&#x27;[[:digit:]]&#123;4&#125;&#x27;</span>; <br><span class="hljs-keyword">SELECT</span> prod_name <span class="hljs-keyword">FROM</span> products <span class="hljs-keyword">WHERE</span> prod_name REGEXP <span class="hljs-string">&#x27;^[0-9\\.]&#x27;</span> <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> prod_name;<br><br>#REGEXP检查返回<span class="hljs-number">0</span>或<span class="hljs-number">1</span>；此处返回<span class="hljs-number">0</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-string">&#x27;hello&#x27;</span> REGEXP <span class="hljs-string">&#x27;[0-9]&#x27;</span>;<br></code></pre></td></tr></table></figure><p>正则表达定位符：</p><table><thead><tr><th>元字符</th><th>说明</th></tr></thead><tbody><tr><td>^</td><td>文本开始</td></tr><tr><td>$</td><td>文本结束</td></tr><tr><td>[[:&lt;:]]</td><td>词开始</td></tr><tr><td>[[:&gt;:]]</td><td>词结束</td></tr></tbody></table><p><strong>高级查询：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 将结果按列<span class="hljs-number">1</span>分组，并计算每组的数量。<br><span class="hljs-keyword">SELECT</span> 列<span class="hljs-number">1</span>, <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> 列<span class="hljs-number">1</span>;<br><br># 在分组后，使用 <span class="hljs-keyword">HAVING</span> 对分组进行进一步筛选<br><span class="hljs-keyword">SELECT</span> 列<span class="hljs-number">1</span>, <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> 列<span class="hljs-number">1</span> <span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span>;<br><br># 内连接<br><span class="hljs-keyword">SELECT</span> A.列<span class="hljs-number">1</span>, B.列<span class="hljs-number">2</span> <span class="hljs-keyword">FROM</span> 表A <span class="hljs-keyword">INNER</span> <span class="hljs-keyword">JOIN</span> 表B <span class="hljs-keyword">ON</span> A.id <span class="hljs-operator">=</span> B.a_id;<br><br># 左连接<br><span class="hljs-keyword">SELECT</span> A.列<span class="hljs-number">1</span>, B.列<span class="hljs-number">2</span> <span class="hljs-keyword">FROM</span> 表A <span class="hljs-keyword">LEFT</span> <span class="hljs-keyword">JOIN</span> 表B <span class="hljs-keyword">ON</span> A.id <span class="hljs-operator">=</span> B.a_id;<br><br># 子查询<br><span class="hljs-keyword">SELECT</span> 列<span class="hljs-number">1</span> <span class="hljs-keyword">FROM</span> 表A <span class="hljs-keyword">WHERE</span> 列<span class="hljs-number">2</span> <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> 列<span class="hljs-number">2</span> <span class="hljs-keyword">FROM</span> 表B);<br></code></pre></td></tr></table></figure><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图为虚拟的表。视图提供了一种MySQL的SELECT语句层次的封装，可用来简化数据处理以及重新格式化基础数据或保护基础数据。</p><p><strong>应用：</strong></p><ul><li>重用SQL语句。</li><li>保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限。</li><li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</li></ul><p><strong>限制：</strong></p><ul><li><p>与表一样，视图必须唯一命名</p></li><li><p>视图不能索引，也不能有关联的触发器或默认值。</p></li><li><p>视图可以和表一起使用。例如，编写一条联结表和视图的SELECT语句。</p></li><li><p>ORDER BY可以用在视图中，但如果从该视图检索数据SELECT中也含有ORDER BY，那么该视图中的ORDER BY将被覆盖</p></li></ul><p><strong>语法:</strong></p><ul><li><p><code>CREATE VIEW</code>：创建视图</p></li><li><p><code>SHOW CREATE VIEW viewname</code>：查看创建视图的语句</p></li><li><p><code>DROP VIEW viewname</code>：删除视图</p></li><li><p><code>CREATE ORREPLACE VIEW</code>：更新视图，相当于先用<code>DROP</code>再用&#96;CREATE</p></li></ul><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>为以后的使用而保存的一条或多条MySQL语句的集合。可将其视为批文件。 为什么使用存储过程：</p><ul><li>把复杂处理进行封装，简化复杂的操作；</li><li>提高性能，存储过程比单独SQL语句更快；</li></ul><p><strong>创建：</strong></p><p>返回产品平均价格的存储过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE PROCEDURE productpricing() # 可以接受参数<br>BEGIN<br>SELECT Avg(prod_price) AS priceaverage<br>FROM products;<br>END;<br></code></pre></td></tr></table></figure><p>BEGIN&#x2F;END 用来限定存储过程体。此段代码仅创建了存储过程，未执行。</p><p><strong>调用：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CALL</span> productpricing()<br><br></code></pre></td></tr></table></figure><p><strong>删除：</strong></p><p>存储过程在创建之后，被保存在服务器上以供使用，直至被删除。 <code>DROP PROCEDURE productpricing IF EXISTS</code></p><p><strong>参数：</strong></p><p>MySQL支持IN（传递给存储过程）、OUT（从存储过程传出）和INOUT（对存储过程传入和传出）类型的参数。 接受订单号并返回该订单的金额：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE PROCEDURE ordertotal(<br>IN ordernum INT,<br>OUT ordersum DECIMAL(8, 2)<br>)<br>BEGIN<br>SELECT Sum(item_price * quantity)<br>FROM orderitems<br>WHERE order_num = ordernum<br>INTO ordersum;<br>END;<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><p>获取订单税后金额（订单金额+税收）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE PROCEDURE ordertotal(<br>IN onum INT,<br>IN taxable BOOLEAN, # 是否计税<br>OUT ototal DECIMAL(8, 2)<br>) COMMENT &#x27;order total, adding tax&#x27;<br>BEGIN<br>DECLARE total DECIMAL(8, 2);<br>DECLARE taxrate INT DEFAULT 6;<br><br>SELECT Sum(item_price * quanlity)<br>FROM orderitems<br>WHERE order_num = onum<br>INTO total;<br><br>IF taxable THEN<br>SELECT total + (total / 100 * taxrate) INTO total;<br>END IF;<br>-- SELECT total INTO ototal;<br>END;<br></code></pre></td></tr></table></figure><p>调用存储过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CALL ordertotal(20005, 1, @total);<br>SELECT @total;<br></code></pre></td></tr></table></figure><p><strong>查看：</strong></p><p>创建存储过程的 CREATE 语句。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW CREATE PROCEDURE ordertotal;<br></code></pre></td></tr></table></figure><p>获得包括何时、由谁创建等详细信息的存储过程列表，使用<code>SHOW PROCEDURE STATUS LIKE &#39;ordertotal&#39;;</code></p><p>查看存储过程状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SHOW PROCEDURE status;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>mysql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>reactor模型原理与实现</title>
    <link href="/2025/06/14/network-reactor%E6%A8%A1%E5%9E%8B%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <url>/2025/06/14/network-reactor%E6%A8%A1%E5%9E%8B%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<p>Java 中的 Reactor 模型是一种基于事件驱动的设计模式，常用于处理并发 I&#x2F;O 操作。它特别适用于高并发、网络服务开发（如 Web 服务器、数据库连接池、消息队列等），是现代 Java NIO（非阻塞 I&#x2F;O）编程的核心设计思想之一。Reactor 模型的核心思想是：<font color =red>将 I&#x2F;O 事件注册到一个事件循环中，由事件循环监听这些事件并分发给相应的处理器进行处理。<br></font>这种模型可以高效地管理大量并发连接，而不需要为每个连接创建一个线程，从而避免了传统多线程模型中线程切换和资源消耗的问题。</p><span id="more"></span><p><strong>Reactor模型组成：</strong><br>Reactor：负责监听和分发事件。通常使用 Selector来监控多个通道（Channel）上的 I&#x2F;O 事件（如读、写）。<br>Acceptor：当监听到客户端连接请求时，由 Acceptor 接收连接，并将其注册到 Reactor 中。<br>Handler：处理具体的 I&#x2F;O 事件。每个 Channel 对应一个 Handler，负责处理该 Channel 上发生的事件（如连接建立、数据读取、写入等）。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">Client --&gt; ServerSocketChannel (OP_ACCEPT)<br>                    |<br>                    v<br>                Reactor (Selector)<br>                    |<br>        +-----------v--------------+<br>        |                          |<br>Acceptor(SocketChannel )   ... (多个连接)<br>        |<br>     Handler (读/写)<br></code></pre></td></tr></table></figure><h2 id="单Reactor单线程模式"><a href="#单Reactor单线程模式" class="headerlink" title="单Reactor单线程模式"></a>单Reactor单线程模式</h2><p>所有操作都在一个线程中完成：事件监听、事件分发、业务处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Reactor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>  <span class="hljs-keyword">final</span> Selector selector;<br>  <span class="hljs-keyword">final</span> ServerSocketChannel serverSocket;<br><br>  Reactor(<span class="hljs-type">int</span> port) <span class="hljs-keyword">throws</span> IOException &#123;<br>    selector = Selector.open();<br>    serverSocket = ServerSocketChannel.open();<br>    serverSocket.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(port));<br>    serverSocket.configureBlocking(<span class="hljs-literal">false</span>);<br>    <span class="hljs-comment">// 注册keys</span><br>    <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> serverSocket.register(selector, OP_ACCEPT);<br>    key.attach(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Acceptor</span>());<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">while</span> (!Thread.interrupted()) &#123;<br>      selector.select();<br>      Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();<br>      Iterator&lt;SelectionKey&gt; iterator = selectedKeys.iterator();<br>      <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>        dispatch(iterator.next());<br>        iterator.remove();<br>      &#125;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 事件分发: 将就绪通道的注册键关联的处理器取出并执行</span><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatch</span><span class="hljs-params">(SelectionKey key)</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> key.attachment();<br>    <span class="hljs-keyword">if</span> (handler <span class="hljs-keyword">instanceof</span> Runnable) &#123;<br>      ((Runnable) handler).run();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">class</span> <span class="hljs-title class_">Acceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">clientSocket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>        <span class="hljs-keyword">if</span> (clientSocket != <span class="hljs-literal">null</span>)&#123;<br>          <span class="hljs-keyword">new</span> <span class="hljs-title class_">Handler</span>(clientSocket, selector);<br>        &#125;<br>      &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        e.printStackTrace();<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>ChannelHandler接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ChannelHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRead</span><span class="hljs-params">(SelectionKey key)</span> <span class="hljs-keyword">throws</span> IOException;<br><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleWrite</span><span class="hljs-params">(SelectionKey key)</span> <span class="hljs-keyword">throws</span> IOException;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>EchoServerHandler</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EchoServerHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ChannelHandler</span> &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">if</span> (state == ChannelState.READING) &#123;<br>        handleRead(selectionKey);<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == ChannelState.SENDING) &#123;<br>        handleWrite(selectionKey);<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      log.error(<span class="hljs-string">&quot;read or write error&quot;</span>, e);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRead</span><span class="hljs-params">(SelectionKey selectionKey)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// read ....</span><br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleWrite</span><span class="hljs-params">(SelectionKey selectionKey)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// write ....</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="单Reactor多线程模型实现"><a href="#单Reactor多线程模型实现" class="headerlink" title="单Reactor多线程模型实现"></a>单Reactor多线程模型实现</h2><p>Reactor 作用就是要迅速的触发 Handler ，在单线程 Reactor 中，Handler 与 Reactor 处于同一线程，Handler 进行业务处理的过程会导致 Reactor 变慢。根据上面分而治之的优化思想，可以将业务处理过程从 Reactor 线程中拆出来，到单独的 Handler 线程池中处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EchoServerHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ChannelHandler</span> &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">if</span> (state == ChannelState.READING) &#123;<br>        executor.submit(()-&gt;handleRead(selectionKey));<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state == ChannelState.SENDING) &#123;<br>        executor.submit(()-&gt;handleWrite(selectionKey));<br>      &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>      log.error(<span class="hljs-string">&quot;read or write error&quot;</span>, e);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRead</span><span class="hljs-params">(SelectionKey selectionKey)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// read ....</span><br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleWrite</span><span class="hljs-params">(SelectionKey selectionKey)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// write ....</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="主从Reactor模型"><a href="#主从Reactor模型" class="headerlink" title="主从Reactor模型"></a>主从Reactor模型</h2><p>单 Reactor 多线程的情况下，Handler 线程池中业务可能处理很快，大部分的时间都花在 Reactor 线程处理 I&#x2F;O 上，导致 CPU 闲置，降低了响应速度。主从Reactor模型主要就是把IO连接事事件处理交给主Reactor，从Reactor处理实际的 I&#x2F;O（OP_READ、OP_WRITE）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Reactor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(Reactor.class);<br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Selector selector;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Reactor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    selector = Selector.open();<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (selector.select() == <span class="hljs-number">0</span>) &#123;<br>          <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        Set&lt;SelectionKey&gt; keys = selector.selectedKeys();<br>        Iterator&lt;SelectionKey&gt; iterator = keys.iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>          <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">selectionKey</span> <span class="hljs-operator">=</span> iterator.next();<br>          <span class="hljs-comment">// 必须先移除，避免重复处理</span><br>          iterator.remove();<br>          <span class="hljs-keyword">if</span> (!selectionKey.isValid()) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>          &#125;<br>          <span class="hljs-keyword">try</span> &#123;<br>            dispatch(selectionKey);<br>          &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            logger.error(<span class="hljs-string">&quot;Error handling key: &quot;</span> + selectionKey, e);<br>            selectionKey.cancel();<br>            <span class="hljs-keyword">try</span> &#123;<br>              selectionKey.channel().close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException ex) &#123;<br>              logger.error(<span class="hljs-string">&quot;Error closing channel&quot;</span>, ex);<br>            &#125;<br>          &#125;<br>        &#125;<br>      &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        logger.error(<span class="hljs-string">&quot;selector error&quot;</span>, e);<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatch</span><span class="hljs-params">(SelectionKey selectionKey)</span> <span class="hljs-keyword">throws</span> IOException;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>MainReactor</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainReactor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Reactor</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServerSocketChannel serverSocketChannel;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServerBootstrapAcceptor acceptor;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatch</span><span class="hljs-params">(SelectionKey key)</span> &#123;<br>    <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> serverSocketChannel.accept();<br>        <span class="hljs-keyword">if</span> (socketChannel != <span class="hljs-literal">null</span>) &#123;<br>          acceptor.handleAccept(socketChannel);<br>        &#125;<br>      &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        log.error(<span class="hljs-string">&quot;get socket channel error&quot;</span>, e);<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SubReactor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Reactor</span> &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dispatch</span><span class="hljs-params">(SelectionKey selectionKey)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    executor.execute(() -&gt; &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (!selectionKey.isValid()) &#123;<br>          <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">ChannelHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> (ChannelHandler) selectionKey.attachment();<br>        <span class="hljs-keyword">if</span> (selectionKey.isReadable()) &#123;<br>          handler.handleRead(selectionKey);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (selectionKey.isWritable()) &#123;<br>          handler.handleWrite(selectionKey);<br>        &#125;<br>      &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        log.error(<span class="hljs-string">&quot;Handler processing error&quot;</span>, e);<br>        <span class="hljs-keyword">try</span> &#123;<br>          selectionKey.cancel();<br>          selectionKey.channel().close();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException ex) &#123;<br>          log.error(<span class="hljs-string">&quot;Error closing channel&quot;</span>, ex);<br>        &#125;<br>      &#125;<br>    &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>EchoServerHandler</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EchoServerHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ChannelHandler</span> &#123;<br> <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRead</span><span class="hljs-params">(SelectionKey selectionKey)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// read ....</span><br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleWrite</span><span class="hljs-params">(SelectionKey selectionKey)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// write ....</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NIO实践与原理</title>
    <link href="/2025/06/14/network-NIO%E5%AE%9E%E8%B7%B5%E4%B8%8E%E5%8E%9F%E7%90%86/"/>
    <url>/2025/06/14/network-NIO%E5%AE%9E%E8%B7%B5%E4%B8%8E%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>Java NIO是 Java 1.4 引入的一组新的 I&#x2F;O API，相较于传统的 Java IO（即 BIO，Blocking I&#x2F;O），它提供了更高效、非阻塞的 I&#x2F;O 操作方式。它的核心思想是<strong>面向缓冲区和非阻塞</strong>，结合 Selector 实现高效的事件驱动模型，更适合用于高并发、高性能的网络编程场景，例如服务器端通信、文件传输等。</p><span id="more"></span><h2 id="Java-NIO-的核心组件"><a href="#Java-NIO-的核心组件" class="headerlink" title="Java NIO 的核心组件"></a>Java NIO 的核心组件</h2><ul><li>Channel（通道）</li><li>Buffer（缓冲区）</li><li>Selector（选择器）</li></ul><h3 id="Channel（通道）"><a href="#Channel（通道）" class="headerlink" title="Channel（通道）"></a><strong>Channel（通道）</strong></h3><p>Channel 是对传统 IO 流的改进，可以同时进行读写操作。 Channel 是双向的，可以读和写，并且支持<strong>异步</strong>读&#x2F;写。它必须从 Buffer 读取或写入数据。Channel 可以通过 <code>configureBlocking(false)</code> 方法配置为非阻塞模式。常见的Channel类型:</p><ul><li>FileChannel：用于文件读写。它只能在阻塞模式下运行，其他 3 个 Channel 都可以配置成非阻塞模式。</li><li>SocketChannel：用于 TCP 客户端通信。</li><li>ServerSocketChannel：用于 TCP 服务端监听连接。</li><li>DatagramChannel：用于 UDP 通信。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 示例：打开一个 FileChannel</span><br><span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(<span class="hljs-string">&quot;file.txt&quot;</span>, <span class="hljs-string">&quot;rw&quot;</span>);<br><span class="hljs-type">FileChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> file.getChannel();<br></code></pre></td></tr></table></figure><h3 id="Buffer（缓冲区）"><a href="#Buffer（缓冲区）" class="headerlink" title="Buffer（缓冲区）"></a><strong>Buffer（缓冲区）</strong></h3><p>Buffer 是一个容器对象，本质上是一块内存，内部实现是一个数组，用于向 Channel 写入和读取数据。<br><img src="/images/network-NIO%E5%AE%9E%E8%B7%B5%E4%B8%8E%E5%8E%9F%E7%90%86_Buffer%E7%B1%BB%E5%9B%BE.png"></p><ul><li><p><strong>Buffer 的几个关键属性</strong>：</p><ul><li>capacity：容量，最大存储数据量。</li><li>position：当前位置，下一次读写的位置。</li><li>limit：限制，表示可操作的数据长度。</li><li>mark：标记位置，可用于重置 position。</li></ul></li><li><p><strong>Buffer 的常用方法：</strong></p><ul><li>flip()：切换为读模式（将 limit 设置为当前 position，position 设置为 0）。</li><li>clear()：清空 buffer，准备重新写入。</li><li>rewind()：重置 position 为 0，重新读取 buffer 中的数据。</li></ul></li><li><p><strong>Buffer使用示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个 1024 字节的缓冲区</span><br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>); <br><span class="hljs-comment">// 写入数据</span><br>buffer.put(<span class="hljs-string">&quot;Hello, NIO!&quot;</span>.getBytes()); <br><span class="hljs-comment">// 切换到读模式</span><br>buffer.flip(); <br><span class="hljs-keyword">while</span> (buffer.hasRemaining()) &#123;<br>  System.out.print((<span class="hljs-type">char</span>) buffer.get());<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>Buffer源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Invariants: mark &lt;= position &lt;= limit &lt;= capacity  </span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">mark</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;  <br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">position</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> limit;  <br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> capacity;  <br>  <br><span class="hljs-comment">// Used only by direct buffers  </span><br><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> hoisted here for speed in JNI GetDirectBufferAddress  </span><br><span class="hljs-type">long</span> address;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">byte</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">return</span> hb[ix(nextGetIndex())];<br>&#125;<br><br><span class="hljs-comment">// 切换为读模式</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Buffer <span class="hljs-title function_">flip</span><span class="hljs-params">()</span> &#123;  <br>  limit = position;  <br>  position = <span class="hljs-number">0</span>;  <br>  mark = -<span class="hljs-number">1</span>;  <br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;  <br>&#125;<br><br><span class="hljs-comment">// 切换为写模式</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Buffer <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;  <br>  position = <span class="hljs-number">0</span>;  <br>  limit = capacity;  <br>  mark = -<span class="hljs-number">1</span>;  <br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;  <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Buffer <span class="hljs-title function_">mark</span><span class="hljs-params">()</span> &#123;  <br>  mark = position;  <br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;  <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Buffer <span class="hljs-title function_">reset</span><span class="hljs-params">()</span> &#123;  <br>  <span class="hljs-type">int</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> mark;  <br>  <span class="hljs-keyword">if</span> (m &lt; <span class="hljs-number">0</span>)  <br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidMarkException</span>();  <br>  position = m;  <br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;  <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Buffer <span class="hljs-title function_">rewind</span><span class="hljs-params">()</span> &#123;  <br>  position = <span class="hljs-number">0</span>;  <br>  mark = -<span class="hljs-number">1</span>;  <br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;  <br>&#125;<br><br><span class="hljs-comment">// 清空</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">truncate</span><span class="hljs-params">()</span> &#123;                           <br>  position = <span class="hljs-number">0</span>;  <br>  limit = <span class="hljs-number">0</span>;  <br>  capacity = <span class="hljs-number">0</span>;  <br>  mark = -<span class="hljs-number">1</span>;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p><font color=red>rewind ()方法主要是调整了缓冲区的position属性与mark属性。 mark() + reset() 实现相同功能，rewind()方法与flip()方法很相似，区别在于倒带方法rewind()不会影响limit属性值，而翻转方法flip()会重设limit属性值。</font></p><h3 id="Selector-选择器"><a href="#Selector-选择器" class="headerlink" title="Selector(选择器)"></a><strong>Selector(选择器)</strong></h3><p>这Selector是用来实现多路复用 I&#x2F;O，它可以监听多个 Channel 是否有事件就绪（如连接、读、写）。这样就可以通过一个线程管理多个 Channel，从而管理多个网络连接。</p><p>通过 Selector 注册通道的事件，Selector 会不断地轮询注册在其上的 Channel。当事件发生时，比如：某个 Channel 上面有新的 TCP 连接接入、读和写事件，这个 Channel 就处于就绪状态，会被 Selector 轮询出来。Selector 会将相关的 Channel 加入到就绪集合中。通过 SelectionKey 可以获取就绪 Channel 的集合，然后对这些就绪的 Channel 进行相应的 I&#x2F;O 操作。</p><p>一个多路复用器 Selector 可以同时轮询多个 Channel，由于 JDK 使用了 <code>epoll()</code> 代替传统的 <code>select</code> 实现，所以它并没有最大连接句柄 <code>1024/2048</code> 的限制。这也就意味着只需要一个线程负责 Selector 的轮询，就可以接入成千上万的客户端。</p><p><strong>Selector 可以监听以下四种事件类型：</strong></p><ul><li><code>SelectionKey.OP_ACCEPT</code>：表示通道接受连接的事件，这通常用于 <code>ServerSocketChannel</code>。</li><li><code>SelectionKey.OP_CONNECT</code>：表示通道完成连接的事件，这通常用于 <code>SocketChannel</code>。</li><li><code>SelectionKey.OP_READ</code>：表示通道准备好进行读取的事件，即有数据可读。</li><li><code>SelectionKey.OP_WRITE</code>：表示通道准备好进行写入的事件，即可以写入数据。</li></ul><p><strong>一个 Selector 实例有三个 <code>SelectionKey</code> 集合：</strong></p><ul><li>所有的 <code>SelectionKey</code> 集合：代表了注册在该 Selector 上的 <code>Channel</code>，这个集合可以通过 <code>keys()</code> 方法返回。</li><li>被选择的 <code>SelectionKey</code> 集合：代表了所有可通过 <code>select()</code> 方法获取的、需要进行 <code>IO</code> 处理的 Channel，这个集合可以通过 <code>selectedKeys()</code> 返回。</li><li>被取消的 <code>SelectionKey</code> 集合：代表了所有被取消注册关系的 <code>Channel</code>，在下一次执行 <code>select()</code> 方法时，这些 <code>Channel</code> 对应的 <code>SelectionKey</code> 会被彻底删除，程序通常无须直接访问该集合，也没有暴露访问的方法。</li></ul><h4 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h4><ul><li><p><code>register(Selector sel, int ops)</code>：Channel 的方法，用于注册 Channel 到 Selector，让 Selector 多路复用地监听 Channel 上感兴趣的事件。第二个参数可以是上面 4 种类型的事件中的一种或几种。<code>SelectionKey</code>：注册后返回的选择键，表示 Channel 在 Selector 上的注册信息，当中包含这些方法：</p><ul><li><code>interestOps()</code>：监听事件的集合</li><li><code>readyOps()</code>：当前收到的事件集合</li><li><code>channel()</code>：被注册的通道</li><li><code>selector()</code>：注册到的选择器</li><li><code>attachment()</code>：附加的一个对象（可选）。在 Reactor 模式中，会把 Acceptor 添加到 Selector 中，Acceptor 是用于处理客户端连接的组件，attach 到 Selector 上之后就可以在客户端连接事件到达时取出 Acceptor，处理客户端连接。</li></ul></li><li><p><code>select()</code> ：阻塞当前线程，直到至少有一个 Channel 在这个 Selector 上注册的事件就绪。返回当前就绪的 Channel 的数量。</p></li><li><p><code>selectedKeys()</code>：返回已经就绪的通道的选择键，通常在 <code>select()</code> 方法之后调用，获取就绪的 <code>SelectionKey</code>，然后遍历它们处理 IO 事件。可以通过 <code>selectedKeys().iterator().next().channel()</code> 方法遍历和访问这些通道。</p></li></ul><h4 id="StandardSocketOptions"><a href="#StandardSocketOptions" class="headerlink" title="StandardSocketOptions"></a>StandardSocketOptions</h4><ul><li>SO_KEEPALIVE: 设置长连接</li><li>SO_BACKLOG: 设置等待连接队列的最大长度</li><li>SO_SNDBUF: 设置发送缓冲区的大小</li><li>SO_RCVBUF: 设置接收缓冲区的大小</li><li>SO_REUSEADDR&#x2F;SO_REUSEPORT: 允许重用本地地址和端口（通常用于快速重启服务器）</li><li>SO_LINGER：当启用了 SO_LINGER 并设置了非零的 linger 时间（以秒为单位），套接字在调用 close() 后不会立即返回。套接字会尝试将所有排队的数据发送出去。如果在这段时间内未能成功发送所有数据，则强制关闭套接字，并丢弃剩余的数据。如果在这段时间内成功发送了所有数据，则正常关闭套接字。当禁用了 SO_LINGER 或设置了 linger 时间为零，套接字在调用 close() 后会立即返回。任何排队的数据都会被丢弃，可能导致数据丢失。</li><li>TCP_NODELAY: 禁用 Nagle 算法，确保数据立即发送而不是合并成更大的数据包</li><li>IP_TOS: 设置 IP 数据报头中的服务类型字段（Type of Service）</li><li>IP_MULTICAST_IF</li><li>IP_MULTICAST_TTL</li><li>IP_MULTICAST_LOOP</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleNIOServer</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">serverSocketChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();<br>    serverSocketChannel.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br>    serverSocketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>      <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">socketChannel</span> <span class="hljs-operator">=</span> serverSocketChannel.accept();<br>      <span class="hljs-keyword">if</span> (socketChannel != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">bytesRead</span> <span class="hljs-operator">=</span> socketChannel.read(buffer);<br>        <span class="hljs-keyword">while</span> (bytesRead != -<span class="hljs-number">1</span>) &#123;<br>          buffer.flip();<br>          <span class="hljs-keyword">while</span> (buffer.hasRemaining()) &#123;<br>            System.out.print((<span class="hljs-type">char</span>) buffer.get());<br>          &#125;<br>          buffer.clear();<br>          bytesRead = socketChannel.read(buffer);<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO模型</title>
    <link href="/2025/06/14/network-IO%E6%A8%A1%E5%9E%8B/"/>
    <url>/2025/06/14/network-IO%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>内核（kernel）和用户（user）是操作系统中常用的两个术语。它们的定义很明确：内核空间是操作系统的一部分，以较高的权限级别运行；而用户空间通常指的是权限受限运行的应用程序。</p><p><img src="/images/network-IO%E6%A8%A1%E5%9E%8B_%E5%85%B8%E5%9E%8B%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84.png"></p><p>操作系统内核提供了一组 API 供应用程序调用，通常它们称为“系统调用”。这些 API 与普通的库 API 有所不同，它们标志着执行模式从用户态切换到内核态的界限。为了确保应用程序的兼容性，系统调用的变动非常少，Linux 特别严格地执行这一原则。核心内核可以细分为多个逻辑子系统，如文件访问、网络和进程管理等。</p><span id="more"></span><p>系统资源，在用户进程中是无法被直接访问的，只能通过操作系统来访问，所以也把操作系统提供的这些功能成为:<code>系统调用</code>。</p><p><img src="/images/network-IO%E6%A8%A1%E5%9E%8B_%E7%94%A8%E6%88%B7%E6%80%81%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%9E%B6%E6%9E%84.png"></p><p>上图是一个默认的系统调用模型，用户进程先要通过系统调用read()，进入内核态，然后把数据读取到内核态的Buffer Cache中，最终把数据 copy 到用户态 BufferCache。<br>从上图可以发现，用户进程受限权限没法直接磁盘和网络资源，所以需要来回的在内核态切换。这样一次IO过程就产生了4次上下文切换：</p><ul><li>read 系统调用读磁盘上的文件时：用户态切换到内核态；</li><li>read 系统调用完毕：内核态切换回用户态；</li><li>write 系统调用写到socket时：用户态切换到内核态；</li><li>write 系统调用完毕：内核态切换回用户态。</li></ul><p>上Linux 内核以 buffer cache 为介质，会通过预读和回写的机制，提高了文件 I&#x2F;O 速度，和磁盘访问效率。</p><ul><li><strong>数据预读（read_ahead）</strong>： 数据预读指的是，当程序发起 read() 系统调用时，内核会比请求更多地读取磁盘上的数据，保存在缓冲区，以备程序后续使用。这种数据的预取基于一种预设：程序会重复地访问最近访问过的数据，且这种访问往往是顺序访问。当用户向内核请求读取数据时，内核会先从自己的 buffer cache 去寻找，如果命中数据，则不需要进行真正的磁盘 I&#x2F;O，直接从内存中返回数据；如果缓存未命中，则内核会从磁盘中读取请求的 page，并同时读取紧随其后的几个 page（比如三个），如果文件是顺序访问的，那么下一个读取请求就会命中之前预读的缓存。预读提供了以下好处：<ul><li>减少了 I&#x2F;O 时间对进程的影响。 因为进程的读取操作和真正的 I&#x2F;O 可能发生在不同的时空，数据是预取的，当进程需要它的时候早已经在内存中准备好了，对于这个进程来说，I&#x2F;O 时间是不存在的，但是对于整个系统来说，I&#x2F;O 时间是一个必要成本，因为总要从磁盘读数据，只是发生的时间早晚罢了；</li><li>提供了缓存。 当进程对文件重复访问时，buffer cache 提供了缓存，把本来应该发生的 I&#x2F;O 省掉了，这个和第一点不同，是结结实实得省掉了一次 I&#x2F;O 时间；</li><li>减少了磁盘处理器的命令数，因为每个命令多读了几个相邻扇区，或者说，把小块的 I&#x2F;O 变成了大块的 I&#x2F;O，提升了磁盘性能；</li></ul></li><li><strong>回写</strong>：指的是，当程序发起 write() 系统调用时，内核并不会直接把数据写入到磁盘文件中，而仅仅是写入到缓冲区中，几秒后才会真正将数据刷新到磁盘中。对于系统调用来说，数据写入缓冲区后，就返回了，因此一个 <code>read() / write()</code> 并非真正执行 I&#x2F;O 操作，它只代表数据在用户空间 &#x2F; 内核空间传递的完成。延迟往磁盘写入数据的一个最大的好处就是，可以合并更多的数据一次性写入磁盘。也就是上面说的，把小块的 I&#x2F;O 变成大块 I&#x2F;O，减少磁盘处理命令次数，提高提盘性能。<br>另一个好处是，当其它进程紧接着访问该文件时，内核可以从直接从缓冲区中提供更新的文件数据。</li></ul><p><img src="/images/network-IO%E6%A8%A1%E5%9E%8B_Linux%E7%B3%BB%E7%BB%9F%E9%BB%98%E8%AE%A4IO%E6%A8%A1%E5%9E%8B%E8%B0%83%E7%94%A8%E8%BF%87%E7%A8%8B.png"></p><p>上面linux系统的默认模型的IO调用成本太高，因此操作系统实现了多种不的系统IO的调用方式:</p><p><img src="/images/network-IO%E6%A8%A1%E5%9E%8B_Linux%E5%A4%9A%E7%A7%8DIO%E6%A8%A1%E5%9E%8B%E6%9E%B6%E6%9E%84.png"></p><p>在Linux系统中，处理文件I&#x2F;O操作有多种方式，包括<strong>Buffered I&#x2F;O、mmap和Direct I&#x2F;O</strong>：</p><ul><li><strong>Buffered I&#x2F;O</strong>： Buffered I&#x2F;O是操作系统默认提供的I&#x2F;O方式。在这种模式下，数据首先被读入到操作系统内核空间的缓冲区（也称为页面缓存），然后从这里复制到用户空间的缓冲区。写操作也是类似的，数据首先从用户空间缓冲区复制到内核空间缓冲区，之后操作系统决定何时将数据实际写入磁盘。</li><li><strong>mmap</strong>: mmap是一种内存映射文件的方法，它允许将一个文件或者其它对象映射到进程的地址空间。通过这种方式，可以直接像访问内存一样访问文件内容，无需调用read或write等函数。提供了一种高效的方式来访问文件内容，减少了数据复制的次数。</li><li><strong>Direct I&#x2F;O</strong>: Direct I&#x2F;O是指绕过操作系统内核缓冲区直接进行I&#x2F;O操作的方式。在这种模式下，数据直接在用户空间和存储设备之间传输，没有经过操作系统内核的页面缓存。这种IO方式可以减少内存拷贝次数，提高读写效率，由于缺少缓存机制，可能导致更多的磁盘I&#x2F;O操作，降低性能，同时需要应用程序自己负责缓存管理和同步问题。</li></ul><p>当一个应用程序发起I&#x2F;O请求时，这个请求会经过上述多个层次的处理，从用户空间进入内核空间，然后根据请求类型可能涉及页面缓存、文件系统、块I&#x2F;O层以及最终到达设备驱动，由后者完成与物理硬件的实际交互。这一过程体现了Linux系统高度模块化的设计理念，同时也展示了其在保证灵活性的同时如何高效地管理资源。</p><h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><p><strong>阻塞&amp;非阻塞调用：</strong> 阻塞与非阻塞的概念是针对调用方</p><ul><li>阻塞调用：<code>图1</code>中<code>步骤1、2</code>执行期间，没有数据到达内核缓冲区，这个时候web服务器进程发起的获取数据的请求会被直接阻塞，当前相关线程会被挂起，直到<code>步骤1、2</code>完成，有数据写入内核缓冲区，这个时候才会唤醒线程执行<code>步骤3和4</code>.</li><li>非阻塞调用： 与<code>阻塞调用</code>相反，当没有数据到达内核缓冲区时，web服务发起的获取数据的请求不会发生阻塞，相关线程可以选择做其他事情，然后轮询着查询请求结果即可，当某次轮询出结果，则进行<code>步骤3和4</code>的操作。</li></ul><p><strong>同步&amp;异步处理：</strong> 同步与异步的概念是针对被调用方</p><ul><li>同步处理：被调用方得到最终处理结果才返回给调用方。</li><li>异步处理：被调用方不用得到结果，只需返回一个状态给调用方，然后开始IO处理，处理完了就主动返回通知调用方。</li></ul><p>以一个网络请求为例，当应用收到一个请求，底层会有一个recvfrom 函数(经 Socket 接收数据)视为<strong>系统调用</strong> 。在阻塞式 I&#x2F;O 模型中的 <code>recvfrom</code> 是一个用于接收数据报的系统调用或函数。它通常用于网络编程中，特别是在UDP协议中。这个函数会阻塞应用程序的进程，直到有数据报准备好可以被接收。</p><p>具体来说， <code>recvfrom</code> 通常用于接收来自网络的数据报，例如从套接字（socket）中接收数据。当应用程序调用 <code>recvfrom</code> 时，如果没有数据报可用，它会等待直到有数据报到达，然后将数据报的内容复制到应用程序指定的缓冲区中，并返回成功。</p><p>在阻塞式 I&#x2F;O 模型中，这个调用会导致应用程序阻塞，即应用程序的执行被暂停，直到数据可用为止。这通常意味着应用程序无法执行其他操作，直到 <code>recvfrom</code> 返回并提供接收的数据。这种模型在某些情况下非常简单，但也可能导致应用程序出现延迟，因为它必须等待数据的到达。</p><h3 id="阻塞式I-O模型"><a href="#阻塞式I-O模型" class="headerlink" title="阻塞式I&#x2F;O模型"></a>阻塞式I&#x2F;O模型</h3><p><img src="/images/network-IO%E6%A8%A1%E5%9E%8B_%E9%98%BB%E5%A1%9EIO%E6%A8%A1%E5%9E%8B.png"><br><strong>阻塞IO模型</strong>是指从应用程序发起从 <code>socket</code> 获取数据（ <code>recvfrom</code> )那一刻起，如果内核里没有准备好的数据报，则直接阻塞应用程序，导致应用程序无法去做别的任何事情，直到数据报准备好，被阻塞的程序才会被唤醒，继续处理下面拿到的数据报。</p><ul><li>优点：程序简单，在阻塞等待数据期间进程&#x2F;线程挂起，基本不会占用 CPU 资源。</li><li>缺点：每个连接需要独立的进程&#x2F;线程单独处理，当并发请求量大时为了维护程序，内存、线程切换开销较大，这种模型在实际生产中很少使用。</li></ul><h3 id="非阻塞IO模型"><a href="#非阻塞IO模型" class="headerlink" title="非阻塞IO模型"></a>非阻塞IO模型</h3><p><img src="/images/network-IO%E6%A8%A1%E5%9E%8B_%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%BC%8FIO%E6%A8%A1%E5%9E%8B.png"><br>在非阻塞式 I&#x2F;O 模型中，应用程序把一个套接口设置为非阻塞，就是告诉内核，当所请求的 I&#x2F;O 操作无法完成时，不要将进程睡眠。而是返回一个错误，应用程序基于 I&#x2F;O 操作函数将不断的轮询数据是否已经准备好，如果没有准备好，继续轮询，直到数据准备好为止。</p><ul><li>优点：不会阻塞在内核的等待数据过程，每次发起的 I&#x2F;O 请求可以立即返回，不用阻塞等待，实时性较好。</li><li>缺点：轮询将会不断地询问内核，这将占用大量的 CPU 时间，系统资源利用率较低，所以一般 Web 服务器不使用这种 I&#x2F;O 模型。</li></ul><p>上面轮询阶段返回的是<code>EWOULDBLOCK</code>错误码，通常在网络编程和非阻塞 I&#x2F;O 中使用。它表示某个操作（通常是非阻塞的）因为当前状态而无法立即执行，但并不算是一种错误。在不同的操作系统和编程语言中，它有时也被称为 <code>EAGAIN</code> ，表示 “操作再次尝试”。当你在非阻塞模式下进行 I&#x2F;O 操作（如读取或写入数据），有时可能会遇到 <code>EWOULDBLOCK</code> 错误。</p><h3 id="I-O-复用模型"><a href="#I-O-复用模型" class="headerlink" title="I&#x2F;O 复用模型"></a>I&#x2F;O 复用模型</h3><p><img src="/images/network-IO%E6%A8%A1%E5%9E%8B_IO%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B.png"></p><p>在 I&#x2F;O 复用模型中，会用到 Select 或 Poll 函数或 Epoll 函数(Linux 2.6 以后的内核开始支持)，这两个函数也会使进程阻塞，但是和阻塞 I&#x2F;O 有所不同。这两个函数可以同时阻塞多个 I&#x2F;O 操作，而且可以同时对多个读操作，多个写操作的 I&#x2F;O 函数进行检测，直到有数据可读或可写时，才真正调用 I&#x2F;O 操作函数。</p><ul><li>优点：可以基于一个阻塞对象，同时在多个描述符上等待就绪，而不是使用多个线程(每个文件描述符一个线程)，这样可以大大节省系统资源。</li><li>缺点：当连接数较少时效率相比多线程+阻塞 I&#x2F;O 模型效率较低，可能延迟更大，因为单个连接处理需要 2 次系统调用，占用时间会有增加。</li></ul><h3 id="信号驱动模型"><a href="#信号驱动模型" class="headerlink" title="信号驱动模型"></a>信号驱动模型</h3><p><img src="/images/network-IO%E6%A8%A1%E5%9E%8B_%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%A8%A1%E5%9E%8B.png"><br>在信号驱动式 I&#x2F;O 模型中，应用程序使用套接口进行信号驱动 I&#x2F;O，并安装一个信号处理函数，进程继续运行并不阻塞。当数据准备好时，进程会收到一个 SIGIO 信号，可以在信号处理函数中调用 I&#x2F;O 操作函数处理数据。</p><ul><li>优点：线程并没有在等待数据时被阻塞，可以提高资源的利用率。</li><li>缺点：信号 I&#x2F;O 在大量 IO 操作时可能会因为信号队列溢出导致没法通知。</li></ul><p>信号驱动 I&#x2F;O 尽管对于处理 UDP 套接字来说有用，即这种信号通知意味着到达一个数据报，或者返回一个异步错误。但是，<strong>对于</strong> <strong>TCP</strong> <strong>而言，信号驱动的 I&#x2F;O 方式近乎无用，因为导致这种通知的条件为数众多，每一个来进行判别会消耗很大资源，与前几种方式相比优势尽失</strong>。</p><h3 id="异步-I-O-模型"><a href="#异步-I-O-模型" class="headerlink" title="异步 I&#x2F;O 模型"></a>异步 I&#x2F;O 模型</h3><p><img src="/images/network-IO%E6%A8%A1%E5%9E%8B_%E5%BC%82%E6%AD%A5IO%E6%A8%A1%E5%9E%8B.png"></p><p>由 POSIX 规范定义，应用程序告知内核启动某个操作，并让内核在整个操作（包括将数据从内核拷贝到应用程序的缓冲区)完成后通知应用程序。这种模型与信号驱动模型的主要区别在于：信号驱动 I&#x2F;O 是由内核通知应用程序何时启动一个 I&#x2F;O 操作，而异步 I&#x2F;O 模型是由内核通知应用程序 I&#x2F;O 操作何时完成。</p><ul><li>优点：异步 I&#x2F;O 能够充分利用 DMA 特性，让 I&#x2F;O 操作与计算重叠。</li><li>缺点：要实现真正的异步 I&#x2F;O，操作系统需要做大量的工作。目前 <strong>Windows</strong> <strong>下通过 IOCP 实现了真正的异步 I&#x2F;O</strong>。<br>而在 Linux 系统下，Linux 2.6才引入，目前 AIO 并不完善，因此在 Linux 下实现高并发网络编程时都是以 IO 复用模型模式为主。</li></ul><h4 id="Linux异步IO缺陷"><a href="#Linux异步IO缺陷" class="headerlink" title="Linux异步IO缺陷"></a>Linux异步IO缺陷</h4><ul><li>有限的文件系统支持：Linux AIO 主要对直接 I&#x2F;O（O_DIRECT）有效，这意味着数据不会经过操作系统缓存。因此，它对于大多数标准文件系统操作的支持是有限的，特别是当不使用 O_DIRECT 标志打开文件时，可能会遇到意外的行为。</li><li>不完全异步：虽然 Linux AIO 设计为异步操作，但在实践中，并非所有情况下都能保证完全异步。例如，某些类型的 I&#x2F;O 操作可能仍会导致进程被阻塞，尤其是在处理磁盘 I&#x2F;O 时，如果请求无法立即排队，则调用可能会阻塞直到请求可以被处理。</li><li>复杂性增加：与传统的同步 I&#x2F;O 相比，正确地使用 AIO 需要更复杂的编程模型。这包括管理回调函数、处理错误情况以及确保资源的正确释放等，增加了开发和维护的难度。</li><li>调试困难：由于其异步特性，跟踪和调试基于 AIO 的应用程序可能会更加困难。比如，确定某个特定的 I&#x2F;O 操作何时完成及其结果状态可能不如同步 I&#x2F;O 那样直观。</li><li>性能问题：在某些情况下，Linux AIO 可能不会带来预期的性能提升，甚至可能导致性能下降。这是因为底层实现细节、硬件特性和工作负载都会影响 AIO 的实际表现。</li><li>库支持不足：相比于其他平台上的 AIO 实现，Linux AIO 在高级语言中的库支持相对较少，这限制了它在跨平台应用中的使用。</li><li>内核版本兼容性：不同版本的 Linux 内核对 AIO 的支持程度可能有所不同，这要求开发者注意目标环境的具体版本，以避免兼容性问题。</li></ul><h3 id="io-uring"><a href="#io-uring" class="headerlink" title="io_uring"></a>io_uring</h3><p><a href="https://kernel.dk/io_uring.pdf">io_uring</a> 来自资深内核开发者 Jens Axboe 的想法，从最早的 patch aio: support for IO polling 可以看出，这项工作始于一个很简单的观察：随着设备越来越快，中断驱动（interrupt-driven）模式效率已经低于轮询模式(polling for completions)。<br>通常IO只负责对发生在fd描述符上的事件进行通知，事件的获取和通知部分是非阻塞的，但收到通知之后的操作，却是阻塞的，即使使用多线程去处理这些事件，它依然是阻塞的。如果把这些系统调用都放在操作系统里完成，那么就可以节省下这些系统调用的时间。io_uring 的核心原理是<font color=red>基于用户空间与内核空间共享的环形缓冲区，通过减少系统调用和上下文切换来大幅提升I&#x2F;O性能。它采用<strong>生产者-消费者</strong>模型，用户程序向提交队列（Submission Queue）提交I&#x2F;O请求，内核处理后将结果放入完成队列（Completion Queue），用户程序再从完成队列中获取结果</font>。这里io_uring 实例包含两个环形队列（ring），在内核和应用程序之间共享：</p><ul><li><strong>提交队列</strong>：submission queue (SQ)</li><li><strong>完成队列</strong>：completion queue (CQ)</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs text">-----------------------------------------------------------------<br>|user space                                                     |<br>|                                                               |<br>|                                                               |<br>|      application produces           application consumes      |<br>|              |                               ^                |<br>|              v                               |                |<br>|       ------------------             ------------------       |<br>|------| submission queue |-----------| completion queue |------|<br>|       ------------------             ------------------       |<br>|              |                               ^                |<br>|              v                               |                |<br>|       kenel consumes -&gt; exec syscalls -&gt;  kernel produces     |<br>|                                                               |<br>|kernel                                                         |<br>-----------------------------------------------------------------<br></code></pre></td></tr></table></figure><h4 id="实现机制"><a href="#实现机制" class="headerlink" title="实现机制"></a>实现机制</h4><ul><li>提交队列（Submission Queue, SQ）：用户进程作为生产者，将I&#x2F;O请求（称作SQE，Submission Queue Entry）放入SQ。之后，用户程序只需更新SQ的尾部指针，通知内核有新的请求。</li><li>完成队列（Completion Queue, CQ）：内核作为生产者，在完成I&#x2F;O请求后，将结果（称作CQE，Completion Queue Entry）放入CQ，并更新CQ的尾部指针。用户程序通过读取CQ来获取完成的I&#x2F;O结果。</li><li>共享内存：通过 io_uring_setup() 和 mmap() 系统调用，用户空间和内核空间映射同一块内存区域，用于SQ和CQ的读写。这种共享内存的设计消除了用户态和内核态之间的数据拷贝开销，是io_uring高性能的关键。</li></ul><p>在实现上，SQ和CQ都是无锁的环形缓冲区，通过原子操作和内存屏障来协调用户态和内核态对环形缓冲区的访问，这种访问方式避免了锁带来的性能开销。同时，用户程序写入SQ尾部，内核读取SQ头部，内核写入CQ尾部，用户程序读取CQ头部，形成高效的单生产者单消费者模型。</p><p>io_uring支持三种主要的工作模式，以平衡性能和CPU开销：</p><ul><li><p>提交请求时唤醒（默认）：用户程序填充SQE并更新SQ尾部指针后，通过 io_uring_enter() 系统调用通知内核。内核被唤醒后处理SQ中的请求，并将结果放入CQ。如果CQ为空，用户程序可以进入睡眠等待完成事件，或继续执行其他任务。<strong>这种模式在有大量I&#x2F;O请求时会产生上下文切换，但在空闲时能有效节约CPU资源</strong>。</p></li><li><p>提交队列轮询（SQ Poll）：启动io_uring时，通过 IORING_SETUP_SQPOLL 标志来开启。这种模式下，io_uring会创建一个内核线程，专门负责轮询SQ，主动检查是否有新的I&#x2F;O请求。用户程序提交请求后，甚至可以完全不调用系统调用，由内核线程自动处理。只有在内核线程长时间空闲进入睡眠时，用户程序才需要 io_uring_enter() 唤醒它。<strong>这种模式减少了每次提交I&#x2F;O时的系统调用和上下文切换，但会消耗更多的CPU资源用于轮询</strong>。</p></li><li><p>完全轮询（IO Poll）通过 IORING_SETUP_IOPOLL 标志，结合SQ Poll模式使用。在这种模式下，内核线程不仅轮询SQ，还会轮询底层的设备驱动队列。这实现了真正的无系统调用I&#x2F;O，用户程序和内核线程完全通过轮询环形队列进行通信和处理I&#x2F;O，进一步降低延迟，但CPU开销最大。</p></li></ul><p>io_uring 通过用户&#x2F;内核共享的环形缓冲区、生产者-消费者模型以及批量提交&#x2F;完成等机制，极大地优化了I&#x2F;O操作的性能。它通过减少系统调用和上下文切换，并提供灵活的轮询模式，解决了传统Linux异步I&#x2F;O（AIO）的诸多限制，成为了现代高性能I&#x2F;O应用的首选框架。 </p><h2 id="零拷贝技术操作系统层面支持"><a href="#零拷贝技术操作系统层面支持" class="headerlink" title="零拷贝技术操作系统层面支持"></a>零拷贝技术操作系统层面支持</h2><p>零拷贝技术目的是为了减少<code>上下文切换与数据复制</code>，在系统层面有两种实现方式：</p><ul><li>mmap() + write()</li><li>sendfile()</li></ul><h3 id="mmap-write"><a href="#mmap-write" class="headerlink" title="mmap + write"></a>mmap + write</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">buf = mmap(file, len);<br>write(sockfd, buf, len);<br></code></pre></td></tr></table></figure><p>read()系统调用把内核缓冲区的数据拷贝到用户的缓冲区里，用 mmap() 替换 read(), mmap() 直接把内核缓冲区里的数据映射到用户空间，减少这一次拷贝。</p><p>具体调用过程如下：</p><ul><li>应用进程调用了 mmap() 后，DMA 会把磁盘的数据拷贝到内核的缓冲区里。因为建立了这个内存的mapping，所以用户态的数据可以直接访问了；</li><li>应用进程再调用 write()，CPU将内核缓冲区的数据拷贝到 socket 缓冲区中，这一切都发生在内核态</li><li>DMA把内核的 socket 缓冲区里的数据，拷贝到网卡的缓冲区里</li></ul><p>mmap + write 并没有实现零拷贝，mmap()相对于使用read()减少了一次拷贝。</p><h3 id="sendfile"><a href="#sendfile" class="headerlink" title="sendfile"></a>sendfile</h3><p>sendfile()系统调用允许直接在两个文件描述符之间传输数据，而无需将数据复制到用户空间。它通常用于高效地将数据从一个文件（通常是磁盘上的文件）传输到另一个文件（如网络套接字）。这个过程完全由操作系统内核管理，极大程度上减少了CPU的参与。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">sendfile</span><span class="hljs-params">(<span class="hljs-type">int</span> out_fd, <span class="hljs-type">int</span> in_fd, <span class="hljs-type">off_t</span> *offset, <span class="hljs-type">size_t</span> count)</span>;<br></code></pre></td></tr></table></figure><ul><li>真正实现了零拷贝，即数据从磁盘直接传输到网络接口，完全绕过了用户空间，减少了CPU的使用和数据复制次数。</li><li>简化了编程模型，因为不需要显式地管理内存映射或数据传输逻辑。<br><img src="/images/network-IO%E6%A8%A1%E5%9E%8B_sendfile%E5%A4%84%E7%90%86%E9%80%BB%E8%BE%91.png"></li></ul><p>使用sendfile()可以替代前面的 read() 和 write() 这两个系统调用，减少一次系统调用和 2 次上下文切换。在linux内核2.1(上图虚线部分)实现上，sendfile可以直接把内核缓冲区里的数据拷贝到 socket 缓冲区里，不再拷贝到用户态，优化后只有 2 次上下文切换，和 3 次数据拷贝。</p><p>从 Linux 内核 2.4 版本开始起，对于支持网卡支持 SG-DMA 技术的情况下， sendfile() 可以从Buffer Cache 复制数据到网卡。因为没有内存层面去拷贝数据，也就是说全程没有通过 CPU 来搬运数据，所有的数据都是通过 DMA 来进行传输的。</p><h3 id="MappedByteBuffer-java-mmap实现"><a href="#MappedByteBuffer-java-mmap实现" class="headerlink" title="MappedByteBuffer(java mmap实现)"></a>MappedByteBuffer(java mmap实现)</h3><p>Java 中的通过MappedByteBuffer可以将文件或部分文件映射到内存中，适用于大文件的读写操作，能够显著提高性能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MMapFileSender</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendFile</span><span class="hljs-params">(String filePath, SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">FileChannel</span> <span class="hljs-variable">fileChannel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filePath).getChannel()) &#123;<br>      <span class="hljs-type">long</span> <span class="hljs-variable">fileSize</span> <span class="hljs-operator">=</span> fileChannel.size();<br>      <span class="hljs-type">MappedByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> fileChannel.map(FileChannel.MapMode.READ_ONLY, <span class="hljs-number">0</span>, fileSize);<br><br>      <span class="hljs-comment">// 使用 socketChannel 直接发送内存映射缓冲区</span><br>      <span class="hljs-keyword">while</span> (buffer.hasRemaining()) &#123;<br>        socketChannel.write(buffer);<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="FileChannel-transferTo-与transferFrom-java-sendfile实现"><a href="#FileChannel-transferTo-与transferFrom-java-sendfile实现" class="headerlink" title="FileChannel.transferTo()与transferFrom()-(java sendfile实现)"></a>FileChannel.transferTo()与transferFrom()-(java sendfile实现)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.io.*;<br><span class="hljs-keyword">import</span> java.nio.channels.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SendFileExample</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendFile</span><span class="hljs-params">(SocketChannel socketChannel, String filePath)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">FileChannel</span> <span class="hljs-variable">fileChannel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(filePath).getChannel()) &#123;<br>      <span class="hljs-type">long</span> <span class="hljs-variable">fileSize</span> <span class="hljs-operator">=</span> fileChannel.size();<br>      <span class="hljs-type">long</span> <span class="hljs-variable">offset</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>      <span class="hljs-keyword">while</span> (offset &lt; fileSize) &#123;<br>        <span class="hljs-comment">// transferTo 返回实际传输的字节数</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">transferred</span> <span class="hljs-operator">=</span> fileChannel.transferTo(offset, fileSize - offset, socketChannel);<br>        <span class="hljs-keyword">if</span> (transferred == <span class="hljs-number">0</span>) &#123;<br>          System.out.println(<span class="hljs-string">&quot;No data transferred. Wait or retry.&quot;</span>);<br>          Thread.sleep(<span class="hljs-number">100</span>);  <span class="hljs-comment">// 可选等待</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          offset += transferred;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>网络编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring-ObjectProvider基础与原理</title>
    <link href="/2025/06/11/spring-ObjectProvider%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%8E%9F%E7%90%86/"/>
    <url>/2025/06/11/spring-ObjectProvider%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p><code>ObjectProvider&lt;T&gt;</code> 是 Spring 框架（从 Spring 5 开始）中用于延迟获取 Bean 的一个接口，位于 <code>org.springframework.beans.factory</code> 包下。它是对 <code>ObjectFactory&lt;T&gt;</code> 的增强版，提供了更灵活的方式来获取和筛选容器中的 Bean。</p><span id="more"></span><h2 id="ObjectProvider-使用场景"><a href="#ObjectProvider-使用场景" class="headerlink" title="ObjectProvider 使用场景"></a>ObjectProvider 使用场景</h2><ul><li><strong>延迟依赖查找</strong>：允许在需要时才获取依赖对象，而不是在应用启动时</li><li><strong>安全地获取可选依赖项（Optional-like Behavior）</strong>：更灵活地获取特定类型的所有 Bean</li><li><strong>避免循环依赖问题</strong>：通过延迟加载可以帮助解决构造器循环依赖场景  </li><li><strong>获取多个匹配的 Bean</strong></li></ul><h3 id="延迟依赖查找"><a href="#延迟依赖查找" class="headerlink" title="延迟依赖查找"></a>延迟依赖查找</h3><p>ObjectProvider 可以延迟获取某个 Bean，而不是在注入时立即初始化。这在某些场景下可以提升性能，尤其是当 Bean 的创建成本较高或者可能不会被用到的时候。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ObjectProvider&lt;HeavyResource&gt; heavyResourceProvider;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyService</span><span class="hljs-params">(ObjectProvider&lt;HeavyResource&gt; heavyResourceProvider)</span> &#123;<br>        <span class="hljs-built_in">this</span>.heavyResourceProvider = heavyResourceProvider;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">HeavyResource</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> heavyResourceProvider.getIfAvailable(); <span class="hljs-comment">// 只有需要时才获取</span><br>        <span class="hljs-keyword">if</span> (resource != <span class="hljs-literal">null</span>) &#123;<br>            resource.use();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="获取多个Bean"><a href="#获取多个Bean" class="headerlink" title="获取多个Bean"></a>获取多个Bean</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span><br><span class="hljs-keyword">public</span> RedisDelayQueueManager <span class="hljs-title function_">redisDelayQueueManager</span><span class="hljs-params">(</span><br><span class="hljs-params">        StringRedisTemplate redisTemplate,</span><br><span class="hljs-params">        DelayQueueProperties properties,</span><br><span class="hljs-params">        ObjectProvider&lt;List&lt;DelayQueueListener&lt;?&gt;&gt;&gt; listenersProvider)</span> &#123;<br>    <br>    <span class="hljs-type">RedisDelayQueueManager</span> <span class="hljs-variable">manager</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisDelayQueueManager</span>(redisTemplate, properties);<br>    <br>    <span class="hljs-comment">// 注册所有监听器</span><br>    List&lt;DelayQueueListener&lt;?&gt;&gt; listeners = listenersProvider.getIfAvailable(Collections::emptyList);<br>    <span class="hljs-keyword">for</span> (DelayQueueListener&lt;?&gt; listener : listeners) &#123;<br>        manager.addListener(listener);<br>    &#125;<br>    <span class="hljs-keyword">return</span> manager;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="安全地获取可选依赖项（Optional-like-Behavior）"><a href="#安全地获取可选依赖项（Optional-like-Behavior）" class="headerlink" title="安全地获取可选依赖项（Optional-like Behavior）"></a>安全地获取可选依赖项（Optional-like Behavior）</h3><ul><li>getIfAvailable()：如果存在该 Bean，则返回它；否则返回 null。</li><li>getIfUnique()：如果存在且只有一个该类型的 Bean，则返回；否则返回 null 或抛出异常。</li><li>stream()：返回所有匹配的 Bean 的流式接口，方便筛选。</li></ul><h3 id="缓解构造循环依赖问题"><a href="#缓解构造循环依赖问题" class="headerlink" title="缓解构造循环依赖问题"></a>缓解构造循环依赖问题</h3><p>在 Spring 中，常见的循环依赖有：</p><ul><li>构造器注入引起的循环依赖（无法自动处理）</li><li>字段&#x2F;Setter 注入引起的循环依赖（Spring 可以处理）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java">Component<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ObjectProvider&lt;B&gt; bProvider;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">A</span><span class="hljs-params">(ObjectProvider&lt;B&gt; bProvider)</span> &#123;<br>        <span class="hljs-built_in">this</span>.bProvider = bProvider;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">B</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> bProvider.getIfAvailable(); <span class="hljs-comment">// 延迟获取</span><br>        b.doSomethingElse();<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ObjectProvider&lt;A&gt; aProvider;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">B</span><span class="hljs-params">(ObjectProvider&lt;A&gt; aProvider)</span> &#123;<br>        <span class="hljs-built_in">this</span>.aProvider = aProvider;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomethingElse</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> aProvider.getIfAvailable();<br>        a.doSomething();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>构造器只注入了 <code>ObjectProvider&lt;B&gt;</code> 和 <code>ObjectProvider&lt;A&gt;</code>，它们是轻量级的封装对象。只有在使用 B 或 A 是在业务方法内部调用 getIfAvailable() 时才发生的。此时 Spring 已经完成了部分 Bean 的创建流程，可能已经可以安全地获取到目标 Bean。</p><p>ObjectProvider 与 Spring 解决循环依赖机制的区别：Spring 使用<strong>三级缓存 + 提前暴露工厂引用</strong>的方式处理字段Setter注入的循环依赖。而 ObjectProvider 则是从另一个角度——延迟加载和解耦——辅助减少构造器注入导致的循环依赖。</p><p>在遇到循环引用问题时应该优化遵循如下规范：</p><ul><li>优先使用字段&#x2F;Setter 注入：Spring 更容易管理其生命周期和依赖关系。</li><li>遇到构造器注入循环时考虑重构：<ul><li>提取公共接口或抽象类；</li><li>拆分职责；</li><li>引入事件驱动、观察者等模式。</li></ul></li><li>谨慎使用 ObjectProvider 来延迟加载 Bean：<ul><li>适用于可选依赖、策略模式、懒加载场景；</li><li>不推荐滥用为<code>绕开循环依赖的快捷方式</code></li></ul></li></ul><h3 id="ObjectProvider-与-Autowired-required-false-的区别"><a href="#ObjectProvider-与-Autowired-required-false-的区别" class="headerlink" title="ObjectProvider 与 @Autowired(required&#x3D;false) 的区别"></a>ObjectProvider 与 @Autowired(required&#x3D;false) 的区别</h3><p>虽然 <code>@Autowired(required=false)</code> 也能处理可选依赖，但 <code>ObjectProvider</code> 提供了更多优势：</p><ul><li>支持延迟查找，只在调用 <code>getObject()</code> 等方法时才实际查找 Bean</li><li>提供更丰富的 API（如 <code>getIfAvailable(Supplier)</code>,  <code>ifAvailable(Consumer)</code> 等）</li><li>能够获取集合类型的依赖并进行进一步处理</li><li>更适合在自动配置类和条件性逻辑中使用</li></ul><h2 id="ObjectProvider实现"><a href="#ObjectProvider实现" class="headerlink" title="ObjectProvider实现"></a>ObjectProvider实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ObjectProvider</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ObjectFactory</span>&lt;T&gt;, Iterable&lt;T&gt; &#123;<br><br>  <span class="hljs-comment">// 返回指定类型的bean, 如果容器中不存在, 抛出NoSuchBeanDefinitionException异常</span><br>  <span class="hljs-comment">// 如果容器中有多个此类型的bean, 抛出NoUniqueBeanDefinitionException异常</span><br>  T <span class="hljs-title function_">getObject</span><span class="hljs-params">(Object... args)</span> <span class="hljs-keyword">throws</span> BeansException;<br><br>  <span class="hljs-comment">// 如果指定类型的bean注册到容器中, 返回 bean 实例, 否则返回 null</span><br>  <span class="hljs-meta">@Nullable</span><br>  T <span class="hljs-title function_">getIfAvailable</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException;<br><br>  <span class="hljs-comment">// 如果返回对象不存在，则进行回调，回调对象由Supplier传入</span><br>  <span class="hljs-keyword">default</span> T <span class="hljs-title function_">getIfAvailable</span><span class="hljs-params">(Supplier&lt;T&gt; defaultSupplier)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>    <span class="hljs-type">T</span> <span class="hljs-variable">dependency</span> <span class="hljs-operator">=</span> getIfAvailable();<br>    <span class="hljs-keyword">return</span> (dependency != <span class="hljs-literal">null</span> ? dependency : defaultSupplier.get());<br>  &#125;<br><br>  <span class="hljs-comment">// 消费对象的一个实例（可能是共享的或独立的），如果存在通过Consumer回调消耗目标对象。</span><br>  <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ifAvailable</span><span class="hljs-params">(Consumer&lt;T&gt; dependencyConsumer)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>    <span class="hljs-type">T</span> <span class="hljs-variable">dependency</span> <span class="hljs-operator">=</span> getIfAvailable();<br>    <span class="hljs-keyword">if</span> (dependency != <span class="hljs-literal">null</span>) &#123;<br>      dependencyConsumer.accept(dependency);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 如果不可用或不唯一（没有指定primary）则返回null。否则，返回对象。</span><br>  <span class="hljs-meta">@Nullable</span><br>  T <span class="hljs-title function_">getIfUnique</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException;<br><br>  <span class="hljs-comment">// 如果存在唯一对象，则调用Supplier的回调函数</span><br>  <span class="hljs-keyword">default</span> T <span class="hljs-title function_">getIfUnique</span><span class="hljs-params">(Supplier&lt;T&gt; defaultSupplier)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>    <span class="hljs-type">T</span> <span class="hljs-variable">dependency</span> <span class="hljs-operator">=</span> getIfUnique();<br>    <span class="hljs-keyword">return</span> (dependency != <span class="hljs-literal">null</span> ? dependency : defaultSupplier.get());<br>  &#125;<br><br>  <span class="hljs-comment">// 如果存在唯一对象，则消耗掉该对象</span><br>  <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ifUnique</span><span class="hljs-params">(Consumer&lt;T&gt; dependencyConsumer)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>    <span class="hljs-type">T</span> <span class="hljs-variable">dependency</span> <span class="hljs-operator">=</span> getIfUnique();<br>    <span class="hljs-keyword">if</span> (dependency != <span class="hljs-literal">null</span>) &#123;<br>      dependencyConsumer.accept(dependency);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 返回符合条件的对象的Iterator，没有特殊顺序保证（一般为注册顺序）</span><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">default</span> Iterator&lt;T&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> stream().iterator();<br>  &#125;<br><br>  <span class="hljs-comment">// 返回符合条件对象的连续的Stream，没有特殊顺序保证（一般为注册顺序）</span><br>  <span class="hljs-keyword">default</span> Stream&lt;T&gt; <span class="hljs-title function_">stream</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>(<span class="hljs-string">&quot;Multi element access not supported&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 返回符合条件对象的连续的Stream。在标注Spring应用上下文中采用@Order注解或实现Order接口的顺序</span><br>  <span class="hljs-keyword">default</span> Stream&lt;T&gt; <span class="hljs-title function_">orderedStream</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>(<span class="hljs-string">&quot;Ordered element access not supported&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>spring</category>
      
      <category>spring-boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
      <tag>spring-boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring-boot自动装配</title>
    <link href="/2025/06/11/spring-boot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/"/>
    <url>/2025/06/11/spring-boot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>Spring Boot 的自动装配（Auto-Configuration）是其核心特性之一，它通过条件化配置和类路径扫描，快速实现应用的配置自动化装配。Spring 中 bean 有三种装配机制，分别是：</p><ul><li>在 xml 中显式配置；</li><li>在 java 中显式配置；</li><li>隐式的 bean 发现机制和自动装配。</li></ul><span id="more"></span><p><font color=red>Spring 的自动装配需要从两个角度来实现，或者说是两个操作：</font></p><ul><li>组件扫描（component scanning）：spring 会自动发现应用上下文中所创建的 bean；</li><li>自动装配（autowiring）：spring 自动满足 bean 之间的依赖，也就是我们说的 IoC&#x2F;DI；</li></ul><h2 id="自动装配原理"><a href="#自动装配原理" class="headerlink" title="自动装配原理"></a>自动装配原理</h2><p>Spring Boot 在启动时会扫描所有 jar 包中的 <code>META-INF/spring.factories/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code>文件， 加载文件中配置的类：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">com.ares.config.ratelimit.RateLimiterAutoConfiguration<br></code></pre></td></tr></table></figure><p>在Spring Boot 2.4之前的版本中META-INFO&#x2F;spring.factories文件:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\<br>com.ares.config.ratelimit.RateLimiterAutoConfiguration<br></code></pre></td></tr></table></figure><p>新版本中AutoConfiguration.imports替换spring.factories文件原因：</p><ul><li>提高可读性和维护性</li><li>增强的性能</li><li>增加条件化装配</li><li>向生态系统演进</li></ul><p>springboot自动装配核心功能的实现实际是通过 <code>AutoConfigurationImportSelector</code> 类来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@AutoConfigurationPackage</span><br><span class="hljs-meta">@Import(AutoConfigurationImportSelector.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableAutoConfiguration &#123;<br><br><span class="hljs-type">String</span> <span class="hljs-variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;spring.boot.enableautoconfiguration&quot;</span>;<br><br>Class&lt;?&gt;[] exclude() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>String[] excludeName() <span class="hljs-keyword">default</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>@AutoConfigurationPackage：将main包下的所有组件注册到容器中</li><li>@Import(AutoConfigurationImportSelector.class)：加载自动装配类 xxxAutoconfiguration</li></ul><h3 id="AutoConfigurationImportSelector"><a href="#AutoConfigurationImportSelector" class="headerlink" title="AutoConfigurationImportSelector"></a>AutoConfigurationImportSelector</h3><p><code>AutoConfigurationImportSelector</code> 实现了 <code>ImportSelector</code> 接口，它会：</p><ul><li>读取 <code>META-INF/spring.factories</code>(新版本<code>META-INF/spring.factories/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code>) 文件中的配置</li><li>筛选出 <code>EnableAutoConfiguration</code> 对应的配置类</li><li>过滤掉不符合条件的配置类</li><li>将符合条件的配置类返回给 Spring 容器进行加载</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AutoConfigurationImportSelector</span> <span class="hljs-keyword">implements</span> <br>  <span class="hljs-title class_">DeferredImportSelector</span>, BeanClassLoaderAware,<br>ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered &#123;<br>  <br>  <span class="hljs-keyword">private</span> ConfigurableListableBeanFactory beanFactory;<br><span class="hljs-keyword">private</span> Environment environment;<br><span class="hljs-keyword">private</span> ClassLoader beanClassLoader;<br><span class="hljs-keyword">private</span> ResourceLoader resourceLoader;<br><span class="hljs-keyword">private</span> ConfigurationClassFilter configurationClassFilter;<br>  <br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;<br><span class="hljs-keyword">if</span> (!isEnabled(annotationMetadata)) &#123;<br><span class="hljs-keyword">return</span> NO_IMPORTS;<br>&#125;<br>    <br><span class="hljs-type">AutoConfigurationEntry</span> <span class="hljs-variable">autoConfigurationEntry</span> <span class="hljs-operator">=</span> getAutoConfigurationEntry(annotationMetadata);<br><span class="hljs-keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());<br>&#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>AutoConfigurationImportSelector 类实现了 ImportSelector接口，也就实现了这个接口中的 selectImports方法，该方法主要用于获取所有符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> AutoConfigurationEntry <span class="hljs-title function_">getAutoConfigurationEntry</span><span class="hljs-params">(AnnotationMetadata annotationMetadata)</span> &#123;<br>  <span class="hljs-comment">// 1.</span><br>  <span class="hljs-keyword">if</span> (!isEnabled(annotationMetadata)) &#123;<br>    <span class="hljs-keyword">return</span> EMPTY_ENTRY;<br>  &#125;<br>  <span class="hljs-comment">// 2. </span><br>  <span class="hljs-type">AnnotationAttributes</span> <span class="hljs-variable">attributes</span> <span class="hljs-operator">=</span> getAttributes(annotationMetadata);<br>  <span class="hljs-comment">// 3. </span><br>  List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);<br>  configurations = removeDuplicates(configurations);<br>  Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);<br>  checkExcludedClasses(configurations, exclusions);<br>  configurations.removeAll(exclusions);<br>  configurations = getConfigurationClassFilter().filter(configurations);<br>  <span class="hljs-comment">// 4. </span><br>  fireAutoConfigurationImportEvents(configurations, exclusions);<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AutoConfigurationEntry</span>(configurations, exclusions);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>代码逻辑说明：</strong></p><ol><li>判断自动装配开关是否打开。默认spring.boot.enableautoconfiguration&#x3D;true，可在 application.properties 或 application.yml 中设置。</li><li>用于获取EnableAutoConfiguration注解中的 exclude 和 excludeName。</li><li>获取需要自动装配的所有配置类，读取<code>META-INF/spring.factories</code>或<code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code>。这一步不光是这个依赖下的META-INF&#x2F;spring.factories被读取到，所有 Spring Boot Starter 下的META-INF&#x2F;spring.factories都会被读取到。</li><li>这一步经历了<code>getConfigurationClassFilter().filter(configurations)</code>一遍筛选，@ConditionalOnXXX 中的所有条件都满足，该类才会生效。所以并不是把<code>spring.factories</code>中的配置都加载。</li></ol><h3 id="ConditionalOnxxx"><a href="#ConditionalOnxxx" class="headerlink" title="ConditionalOnxxx"></a>ConditionalOnxxx</h3><p>自动配置类通常使用条件注解来决定是否生效，常见的条件注解包括：</p><ul><li><code>@ConditionalOnClass</code>：当类路径下有指定的类时</li><li><code>@ConditionalOnMissingClass</code>：当类路径下没有指定的类时</li><li><code>@ConditionalOnBean</code>：当容器中有指定的Bean时</li><li><code>@ConditionalOnMissingBean</code>：当容器中没有指定的Bean时</li><li><code>@ConditionalOnProperty</code>：当配置文件中有指定的属性时</li><li><code>@ConditionalOnWebApplication</code>：当应用是Web应用时</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>自动装配的执行流程:</p><ol><li>Spring Boot 启动时，<code>@SpringBootApplication</code> 注解被解析</li><li><code>@EnableAutoConfiguration</code> 注解导入 <code>AutoConfigurationImportSelector</code></li><li><code>AutoConfigurationImportSelector</code> 读取 classpath 下所有 jar 包中的 <code>META-INF/spring.factories</code> 文件</li><li>找出所有标注了 <code>EnableAutoConfiguration</code> 的配置类</li><li>通过条件注解对配置类进行过滤</li><li>将符合条件的配置类加载到 Spring 容器中</li><li>配置类中定义的 Bean 被创建并注册到容器中</li></ol><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><ul><li>添加依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-autoconfigure-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>定义配置属性</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Setter</span><br><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;snd.webclient&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomWebClientProperties</span> &#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 服务地址，不填写则为 http://serviceName</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">private</span> String url;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 微服务名称，不填写就是 configs 这个 map 的 key</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">private</span> String serverName;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 连接超时时间</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">connectTimeout</span> <span class="hljs-operator">=</span> <span class="hljs-number">300</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 响应超时时间</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">readTimeout</span> <span class="hljs-operator">=</span> <span class="hljs-number">3000</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 是否启用日志</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">enableLogging</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>定义Factory</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomWebClientFactory</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WebClient.Builder webClientBuilder;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">CustomWebClientFactory</span><span class="hljs-params">(WebClient.Builder webClientBuilder)</span> &#123;<br>    <span class="hljs-built_in">this</span>.webClientBuilder = webClientBuilder;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> WebClient <span class="hljs-title function_">createWebClient</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> webClientBuilder.build();<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> WebClient <span class="hljs-title function_">createWebClient</span><span class="hljs-params">(String baseUrl)</span> &#123;<br>    <span class="hljs-keyword">return</span> webClientBuilder.baseUrl(baseUrl).build();<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> WebClient <span class="hljs-title function_">createWebClient</span><span class="hljs-params">(String baseUrl, String serverName)</span> &#123;<br>    <span class="hljs-keyword">return</span> webClientBuilder.baseUrl(baseUrl).defaultHeader(<span class="hljs-string">&quot;server-name&quot;</span>, serverName).build();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>定义WebClientFactoryAutoConfiguration</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ConditionalOnClass(WebClient.class)</span><br><span class="hljs-meta">@EnableConfigurationProperties(CustomWebClientProperties.class)</span><br><span class="hljs-meta">@AutoConfigureAfter(WebClient.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WebClientFactoryAutoConfiguration</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(WebClientFactoryAutoConfiguration.class);<br><br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-meta">@LoadBalanced</span> <span class="hljs-comment">// Add this annotation for service discovery</span><br>  <span class="hljs-keyword">public</span> WebClient.Builder <span class="hljs-title function_">loadBalancedWebClientBuilder</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> WebClient.builder();<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * WebClient的配置类</span><br><span class="hljs-comment">   * </span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> webClientBuilder WebClient.Builder</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> properties 配置属性</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> CustomWebClientFactory</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-meta">@LoadBalanced</span><br>  <span class="hljs-meta">@ConditionalOnMissingBean</span><br>  CustomWebClientFactory <span class="hljs-title function_">customWebClientFactory</span><span class="hljs-params">(WebClient.Builder webClientBuilder,</span><br><span class="hljs-params">      CustomWebClientProperties properties)</span> &#123;<br><br>    <span class="hljs-comment">// 使用属性配置</span><br>    <span class="hljs-keyword">if</span> (properties.getUrl() != <span class="hljs-literal">null</span>) &#123;<br>      webClientBuilder.baseUrl(properties.getUrl());<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (properties.getServerName() != <span class="hljs-literal">null</span>) &#123;<br>      webClientBuilder.baseUrl(String.format(<span class="hljs-string">&quot;lb://%s&quot;</span>, properties.getServerName()));<br>    &#125;<br><br>    <span class="hljs-comment">// 设置超时</span><br>    <span class="hljs-type">HttpClient</span> <span class="hljs-variable">httpClient</span> <span class="hljs-operator">=</span> HttpClient.create()<br>        .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, properties.getConnectTimeout())<br>        .responseTimeout(Duration.ofMillis(properties.getReadTimeout()));<br><br>    webClientBuilder.clientConnector(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ReactorClientHttpConnector</span>(httpClient));<br><br>    <span class="hljs-comment">// 设置日志</span><br>    <span class="hljs-keyword">if</span> (properties.isEnableLogging()) &#123;<br>      webClientBuilder.filter((request, next) -&gt; &#123;<br>        logger.info(<span class="hljs-string">&quot;Request: &#123;&#125; &#123;&#125;&quot;</span>, request.method(), request.url());<br>        <span class="hljs-keyword">return</span> next.exchange(request);<br>      &#125;);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomWebClientFactory</span>(webClientBuilder);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>META-INF&#x2F;spring<br>在文件<code>org.springframework.boot.autoconfigure.AutoConfiguration.imports</code>中添加：</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">com.ares.config.webclient.WebClientFactoryAutoConfiguration<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>spring</category>
      
      <category>spring-boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
      <tag>spring-boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring-boot启动过程</title>
    <link href="/2025/06/11/spring-boot%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"/>
    <url>/2025/06/11/spring-boot%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>Spring Boot实现了 <code>auto-configuration</code> 自动配置，降低了项目搭建的复杂度。它主要是为了解决使用Spring框架需要进行大量的配置太麻烦的问题。它集成了大量常用的第三方库配置(例如Jackson, JDBC, Mongo, Redis, Mail等等)，Spring Boot应用中这些第三方库几乎可以零配置的开箱即用。</p><span id="more"></span><h2 id="启动类注解"><a href="#启动类注解" class="headerlink" title="启动类注解"></a>启动类注解</h2><p><strong>整个启动的过程可以概括为：</strong></p><ul><li>读取所有依赖的META-INF&#x2F;spring&#x2F;%s%s.imports文件，该文件指明了哪些依赖可以被自动加载</li><li>根据importSelector类选择加载哪些依赖，使用conditionOn系列注解排除掉不需要的配置文件</li><li>将剩余的配置文件所代表的bean加载到IOC容器中</li></ul><p>在spring-boot包中 <code>spring.factories</code> 文件定义了加载哪些类：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs text"># PropertySource Loaders<br>org.springframework.boot.env.PropertySourceLoader=\<br>org.springframework.boot.env.PropertiesPropertySourceLoader,\<br>org.springframework.boot.env.YamlPropertySourceLoader<br><br># ConfigData Location Resolvers<br>org.springframework.boot.context.config.ConfigDataLocationResolver=\<br>org.springframework.boot.context.config.ConfigTreeConfigDataLocationResolver,\<br>org.springframework.boot.context.config.StandardConfigDataLocationResolver<br><br># ConfigData Loaders<br>org.springframework.boot.context.config.ConfigDataLoader=\<br>org.springframework.boot.context.config.ConfigTreeConfigDataLoader,\<br>org.springframework.boot.context.config.StandardConfigDataLoader<br><br># Application Context Factories<br>org.springframework.boot.ApplicationContextFactory=\<br>org.springframework.boot.web.reactive.context.ReactiveWebServerApplicationContextFactory,\<br>org.springframework.boot.web.servlet.context.ServletWebServerApplicationContextFactory<br><br># Run Listeners<br>org.springframework.boot.SpringApplicationRunListener=\<br>org.springframework.boot.context.event.EventPublishingRunListener<br></code></pre></td></tr></table></figure><p>这此内容会被解析为Map&lt;K, List<V>&gt;这种格式，键和值都是一个类的全限定名。整个SpringBoot的启动过程都是通过 <code>@SpringBootApplication</code> 注解和 <code>SpringApplication.run</code> 方法来实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span> <span class="hljs-comment">// 注解的适用范围，其中TYPE用于描述类、接口（包括包注解类型）或enum声明</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="hljs-comment">// 注解的生命周期，保留到class文件中（三个生命周期）</span><br><span class="hljs-meta">@Documented</span> <span class="hljs-comment">// 表明这个注解应该被javadoc记录</span><br><span class="hljs-meta">@Inherited</span> <span class="hljs-comment">// 子类可以继承该注解</span><br><span class="hljs-meta">@SpringBootConfiguration</span> <span class="hljs-comment">// 继承了Configuration，表示当前是注解类</span><br><span class="hljs-meta">@EnableAutoConfiguration</span> <span class="hljs-comment">// 开启springboot的注解功能，springboot的四大神器之一，其借助@import的帮助</span><br><span class="hljs-meta">@ComponentScan(excludeFilters = &#123; // 扫描路径设置</span><br><span class="hljs-meta">@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="hljs-meta">@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> SpringBootApplication &#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>几个重要注解说明：</p><ul><li>@SpringBootConfiguration：继承了Configuration，表示当前是注解类</li><li>@EnableAutoConfiguration：开启springboot的注解功能，springboot的四大神器之一，其借助@import的帮助收集和注册特定场景相关的Bean定义</li><li>@ComponentScan：扫描路径设置</li></ul><h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><p>功能：<font color=red>从classpath中搜寻所有的 <code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code> 配置文件，并将其中 <code>org.springframework.boot.autoconfigure.EnableAutoConfiguration</code> 对应的配置项通过反射（Java Refletion）实例化为对应的标注了@Configuration的JavaConfig形式的IoC容器配置类，然后汇总为一个并加载到IoC容器。</font></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings(&quot;deprecation&quot;)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@AutoConfigurationPackage</span> <br><span class="hljs-meta">@Import(AutoConfigurationImportSelector.class)</span> <br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableAutoConfiguration &#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>重要的注解与类：</p><ul><li>@AutoConfigurationPackage</li><li>AutoConfigurationImportSelector.class</li></ul><h4 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="AutoConfigurationPackage"></a>AutoConfigurationPackage</h4><p>注册当前启动类的根package注册 <code>org.springframework.boot.autoconfigure.AutoConfigurationPackages</code> 的BeanDefinition。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Import(AutoConfigurationPackages.Registrar.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AutoConfigurationPackage &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(BeanDefinitionRegistry registry, String... packageNames)</span> &#123;<br><span class="hljs-keyword">if</span> (registry.containsBeanDefinition(BEAN)) &#123;<br>addBasePackages(registry.getBeanDefinition(BEAN), packageNames);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">beanDefinition</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RootBeanDefinition</span>(BasePackages.class);<br>beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);<br>addBasePackages(beanDefinition, packageNames);<br>registry.registerBeanDefinition(BEAN, beanDefinition);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后通过 <code>@Import(AutoConfigurationPackages.Registrar.class)</code> 注册BeanDefinition到IOC窗口中:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Registrar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ImportBeanDefinitionRegistrar</span>, DeterminableImports &#123;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> &#123;<br>    register(registry, <span class="hljs-keyword">new</span> <span class="hljs-title class_">PackageImports</span>(metadata).getPackageNames().toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[<span class="hljs-number">0</span>]));<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> Set&lt;Object&gt; <span class="hljs-title function_">determineImports</span><span class="hljs-params">(AnnotationMetadata metadata)</span> &#123;<br>    <span class="hljs-keyword">return</span> Collections.singleton(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PackageImports</span>(metadata));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="AutoConfigurationImportSelector"><a href="#AutoConfigurationImportSelector" class="headerlink" title="AutoConfigurationImportSelector"></a>AutoConfigurationImportSelector</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AutoConfigurationImportSelector</span> <span class="hljs-keyword">implements</span> <br>  <span class="hljs-title class_">DeferredImportSelector</span>, <br>BeanClassLoaderAware,<br>ResourceLoaderAware, <br>BeanFactoryAware, <br>EnvironmentAware, <br>Ordered &#123;<br>    <br>  <span class="hljs-keyword">private</span> ConfigurableListableBeanFactory beanFactory;<br><span class="hljs-keyword">private</span> Environment environment;<br><span class="hljs-keyword">private</span> ClassLoader beanClassLoader;<br><span class="hljs-keyword">private</span> ResourceLoader resourceLoader;<br><span class="hljs-keyword">private</span> ConfigurationClassFilter configurationClassFilter;<br><br>  <span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;<br><span class="hljs-keyword">if</span> (!isEnabled(annotationMetadata)) &#123;<br><span class="hljs-keyword">return</span> NO_IMPORTS;<br>&#125;<br><span class="hljs-type">AutoConfigurationEntry</span> <span class="hljs-variable">autoConfigurationEntry</span> <span class="hljs-operator">=</span> getAutoConfigurationEntry(annotationMetadata);<br><span class="hljs-keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());<br>&#125;<br>    <br>  <span class="hljs-keyword">protected</span> AutoConfigurationEntry <span class="hljs-title function_">getAutoConfigurationEntry</span><span class="hljs-params">(AnnotationMetadata annotationMetadata)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!isEnabled(annotationMetadata)) &#123;<br>      <span class="hljs-keyword">return</span> EMPTY_ENTRY;<br>    &#125;<br>    <span class="hljs-type">AnnotationAttributes</span> <span class="hljs-variable">attributes</span> <span class="hljs-operator">=</span> getAttributes(annotationMetadata);<br>    <br>    <span class="hljs-comment">// 去加载各个组件jar下的 META-INF/spring.factories</span><br>    List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);<br>    <br>    configurations = removeDuplicates(configurations);<br>    Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);<br>    checkExcludedClasses(configurations, exclusions);<br>    configurations.removeAll(exclusions);<br>    configurations = getConfigurationClassFilter().filter(configurations);<br>    fireAutoConfigurationImportEvents(configurations, exclusions);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AutoConfigurationEntry</span>(configurations, exclusions);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>借助AutoConfigurationImportSelector，让SpringBoot应用将所有符合条件的bean定义都加载到当前SpringBoot创建并使用的IoC容器。<br><img src="/images/spring-boot%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B_springboot%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8BAutoConfigure%E6%B3%A8%E8%A7%A3.png"></p><h2 id="SpringApplication-run"><a href="#SpringApplication-run" class="headerlink" title="SpringApplication#run()"></a>SpringApplication#run()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ConfigurableApplicationContext <span class="hljs-title function_">run</span><span class="hljs-params">(Class&lt;?&gt;[] primarySources, String[] args)</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SpringApplication</span>(primarySources).run(args);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">SpringApplication</span><span class="hljs-params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> &#123;<br>  <span class="hljs-built_in">this</span>.resourceLoader = resourceLoader;<br>  Assert.notNull(primarySources, <span class="hljs-string">&quot;PrimarySources must not be null&quot;</span>);<br>  <span class="hljs-built_in">this</span>.primarySources = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;(Arrays.asList(primarySources));<br>  <span class="hljs-built_in">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();<br>  <span class="hljs-built_in">this</span>.bootstrapRegistryInitializers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<br>      getSpringFactoriesInstances(BootstrapRegistryInitializer.class));<br>  setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));<br>  setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));<br>  <span class="hljs-built_in">this</span>.mainApplicationClass = deduceMainApplicationClass();<br>&#125;<br></code></pre></td></tr></table></figure><p>SpringApplication#run方法，首先要创建一个SpringApplication对象实例，然后调用这个创建好的SpringApplication的实例方法。在SpringApplication实例初始化的时候，它会提前做几件事情：</p><ul><li>根据classpath里面是否存在某个特征类org.springframework.web.context. ConfigurableWebApplicationContext来决定是否应该创建一个为Web应用使用的ApplicationContext类型。</li><li>使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationContextInitializer。</li><li>使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationListener。</li><li>推断并设置main方法的定义类。</li></ul><p>SpringApplication实例初始化完成并且完成设置后，会开始执行run方法的逻辑。run方法中会初始化如下模块：</p><ul><li>SpringApplicationRunListeners：应用启动监听器模块</li><li>ConfigurableEnvironment：配置环境模块 </li><li>ConfigurableApplicationContext：应用上下文模块</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ConfigurableApplicationContext <span class="hljs-title function_">run</span><span class="hljs-params">(String... args)</span> &#123;<br>  <span class="hljs-type">Startup</span> <span class="hljs-variable">startup</span> <span class="hljs-operator">=</span> Startup.create();<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.registerShutdownHook) &#123;<br>    SpringApplication.shutdownHook.enableShutdownHookAddition();<br>  &#125;<br><br>  <span class="hljs-type">DefaultBootstrapContext</span> <span class="hljs-variable">bootstrapContext</span> <span class="hljs-operator">=</span> createBootstrapContext();<br>  <span class="hljs-type">ConfigurableApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>  configureHeadlessProperty();<br>  <span class="hljs-type">SpringApplicationRunListeners</span> <span class="hljs-variable">listeners</span> <span class="hljs-operator">=</span> getRunListeners(args);<br>  listeners.starting(bootstrapContext, <span class="hljs-built_in">this</span>.mainApplicationClass);<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">ApplicationArguments</span> <span class="hljs-variable">applicationArguments</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultApplicationArguments</span>(args);<br>    <span class="hljs-type">ConfigurableEnvironment</span> <span class="hljs-variable">environment</span> <span class="hljs-operator">=</span> prepareEnvironment(listeners, bootstrapContext, applicationArguments);<br>    <span class="hljs-type">Banner</span> <span class="hljs-variable">printedBanner</span> <span class="hljs-operator">=</span> printBanner(environment);<br>    context = createApplicationContext();<br>    context.setApplicationStartup(<span class="hljs-built_in">this</span>.applicationStartup);<br><br>    prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);<br>    refreshContext(context);<br>    afterRefresh(context, applicationArguments);<br>    startup.started();<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logStartupInfo) &#123;<br>      <span class="hljs-keyword">new</span> <span class="hljs-title class_">StartupInfoLogger</span>(<span class="hljs-built_in">this</span>.mainApplicationClass).logStarted(getApplicationLog(), startup);<br>    &#125;<br>    listeners.started(context, startup.timeTakenToStarted());<br>    callRunners(context, applicationArguments);<br>  &#125;<br>  <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>    <span class="hljs-keyword">throw</span> handleRunFailure(context, ex, listeners);<br>  &#125;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">if</span> (context.isRunning()) &#123;<br>      listeners.ready(context, startup.ready());<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>    <span class="hljs-keyword">throw</span> handleRunFailure(context, ex, <span class="hljs-literal">null</span>);<br>  &#125;<br>  <span class="hljs-keyword">return</span> context;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码有几个关键步骤：</p><ul><li><code>SpringApplicationRunListeners listeners = getRunListeners(args)</code>, 创建了应用的监听器SpringApplicationRunListeners并开始监听</li><li>加载SpringBoot配置环境(ConfigurableEnvironment)，如果是通过web容器发布，会加载StandardEnvironment，其最终也是继承了ConfigurableEnvironment</li><li><code>prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner)</code>配置环境(Environment)加入到监听器对象中(SpringApplicationRunListeners)</li><li><code>refreshContext(context)</code> 注册 <code>ConfigurableApplicationContext context</code> 到 spring ioc</li></ul>]]></content>
    
    
    <categories>
      
      <category>spring</category>
      
      <category>spring-boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
      <tag>spring-boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring-事务基础与原理</title>
    <link href="/2025/06/11/spring-%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%8E%9F%E7%90%86/"/>
    <url>/2025/06/11/spring-%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>Spring 事务的核心原理是通过AOP (面向切面编程) 在方法执行前后进行拦截，并在拦截器中实现事务的开启、提交或回滚。具体来说，Spring 事务基于 <code>PlatformTransactionManager</code> 接口和 <code>TransactionInterceptor</code> 类来管理事务。</p><span id="more"></span><h2 id="事务基本概念"><a href="#事务基本概念" class="headerlink" title="事务基本概念"></a>事务基本概念</h2><p>事务通常指的是数据库事务（Database Transaction），其具备 ACID 特性：</p><ul><li><strong>A（Atomicity）原子性</strong>：事务中的操作要么全部成功，要么全部失败。</li><li><strong>C（Consistency）一致性</strong>：事务执行前后，数据保持一致状态。</li><li><strong>I（Isolation）隔离性</strong>：多个事务并发执行时，彼此隔离。</li><li><strong>D（Durability）持久性</strong>：事务提交后，结果是永久性的。</li></ul><p>在一个事务执行过程中会获得的互斥锁，只有事务提交或失败之后才会释放，在此期间其他事务只能读，不能写。这是隔离性的关键，一般数据都定义了如下四种事务隔离级别：</p><ul><li><strong>串行化</strong>：指对同一行记录，读写操作都会加锁。当出现读写锁冲突的时候，后访问的事务必须等待前一个事务执行完成，才能继续执行</li><li><strong>可重复度读</strong>：一个事务执行过程中看到的数据，总是与这个事务在启动的时候看到的数据是一致的，在可重复读的隔离级别下，未提交变更对其它事务是不可见的</li><li><strong>读已提交</strong>：一个事务提交之后，它做的变更才会被其他事务看到</li><li><strong>读未提交</strong>：一个事务还没有提交，它做的变更就能被其他的事务看到</li></ul><h2 id="Spring事务特性"><a href="#Spring事务特性" class="headerlink" title="Spring事务特性"></a>Spring事务特性</h2><p>Spring为事务提供了完整的支持，在Spring事务实现中提供了两种事务管理方式：</p><ul><li>编程式事务管理：通过 TransactionTemplate 或直接使用底层的 PlatformTransactionManager 来控制事务。</li><li>声明式事务管理：通过注解（如 @Transactional）或 XML 配置来实现事务管理。</li></ul><h3 id="Spring-事务示例"><a href="#Spring-事务示例" class="headerlink" title="Spring 事务示例"></a>Spring 事务示例</h3><h4 id="声明式事务-Transactional"><a href="#声明式事务-Transactional" class="headerlink" title="声明式事务 - @Transactional"></a>声明式事务 - @Transactional</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransactionExample</span>&#123;<br>  <span class="hljs-meta">@Transactional</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">declarativeTransaction</span><span class="hljs-params">()</span>&#123;<br>  update1();<br>    update2();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>@Transactional 注解作用于方法之上，在底层实现上相当于使用 <code>BEGIN</code> 开启了事务，在执行完方法后，使用 <code>COMMIT</code> 提交事务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransactionExample</span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">declarativeTransaction</span><span class="hljs-params">()</span>&#123;<br>  update1();<br>    update2();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将 <code>@Transactional</code> 注解作用于类上，在当前类中所有的 <code>public</code> 方法都开启了事务。</p><h4 id="编程式事务-TransactionTemplate"><a href="#编程式事务-TransactionTemplate" class="headerlink" title="编程式事务 - TransactionTemplate"></a>编程式事务 - TransactionTemplate</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransactionExample</span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TransactionTemplate transactionTemplate;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">TransactionExample</span><span class="hljs-params">(TransactionTemplate transactionTemplate)</span>&#123;<br>    <span class="hljs-built_in">this</span>.transactionTemplate = transactionTemplate;<br>  &#125;<br>  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">programmaticTransaction</span><span class="hljs-params">()</span> &#123;<br>    transactionTemplate.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionCallbackWithoutResult</span>() &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doInTransactionWithoutResult</span><span class="hljs-params">(TransactionStatus status)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          update1();<br>          update2();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>          log.error(<span class="hljs-string">&quot;execute failed: &#123;&#125;&quot;</span>, e.getCause());<br>          status.setRollbackOnly();<br>        &#125;<br>      &#125;<br>    &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="两种事务管理方式对比"><a href="#两种事务管理方式对比" class="headerlink" title="两种事务管理方式对比"></a>两种事务管理方式对比</h4><table><thead><tr><th align="left"></th><th align="left">声明式事务</th><th align="left">编程式事务</th></tr></thead><tbody><tr><td align="left">使用方法</td><td align="left">@Transactional</td><td align="left">TransactionTemplate</td></tr><tr><td align="left">优点</td><td align="left">使用简单</td><td align="left">可以控制事务提交的开启和提交时机，能够更小粒度的控制事务的范围，也更加直观</td></tr><tr><td align="left">缺点</td><td align="left">使用不当事务可能失效；多个事务性操作可能导致事务无法正常提交，导致长事务</td><td align="left">需要硬编码来控制事务</td></tr><tr><td align="left">适用场景</td><td align="left">同一个方法中，事务操作比较多</td><td align="left">当事务操作的数量很少</td></tr></tbody></table><p>在合适的场景使用合适的事务管理方式非常重要，在一些场景下，当对事务操作非常频繁，特别是在递归、外部通讯等耗时的场景中使用事务，很有可能就会引发长事务，那么应该考虑将非事务的部分放在前面执行，最后在写入数据环节时再开启事务。</p><h3 id="Spring-事务隔离级别"><a href="#Spring-事务隔离级别" class="headerlink" title="Spring 事务隔离级别"></a>Spring 事务隔离级别</h3><p>TransactionDefinition 接口中定义了五个表示隔离级别的常量：</p><ul><li><code>TransactionDefinition.ISOLATION_DEFAULT</code>：这是默认值，表示使用底层数据库的默认隔离级别。对大部分数据库而言，通常这值就是TransactionDefinition. ISOLATION_READ_COMMITTED。</li><li><code>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</code>：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。该级别不能防止脏读，不可重复读和幻读，因此很少使用该隔离级别。比如PostgreSQL实际上并没有此级别。</li><li><code>TransactionDefinition.ISOLATION_READ_COMMITTED</code>：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。该级别可以防止脏读，这也是大多数情况下的推荐值。</li><li><code>TransactionDefinition.ISOLATION_REPEATABLE_READ</code>：该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询，并且每次返回的记录都相同。该级别可以防止脏读和不可重复读。</li><li><code>TransactionDefinition.ISOLATION_SERIALIZABLE</code>：所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li></ul><h3 id="Spring事务传播行为"><a href="#Spring事务传播行为" class="headerlink" title="Spring事务传播行为"></a>Spring事务传播行为</h3><p>Spring 事务的传播行为（Propagation Behavior）定义了当一个事务方法被另一个事务方法调用时，两者之间应该如何交互。Spring 提供了多种事务传播行为，每种都有其特定的应用场景和特性。Spring中规定了7种类型的事务传播特性：</p><table><thead><tr><th align="left">事务传播行为类型</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">Propagation.REQUIRED</td><td align="left">如果当前没有事务，就新建一个事务，如果已经存在一个事务中；就加入到这个事务中，这是事务传播行为的默认值</td></tr><tr><td align="left">Propagation.REQUIRES_NEW</td><td align="left">总是创建新的事务，新的事务回滚不会影响原来的事务</td></tr><tr><td align="left">Propagation.NESTED</td><td align="left">如果已经存在事务，则使用嵌套事务，如果当前没有事务，则新建事务</td></tr><tr><td align="left">Propagation.MANDATORY</td><td align="left">使用当前事务，如果当前没有事务，就抛出异常</td></tr><tr><td align="left">Propagation.NEVER</td><td align="left">以非事务方式执行操作，如果当前存在事务，则抛出异常</td></tr><tr><td align="left">Propagation.NOT_SUPPORTED</td><td align="left">以非事务方式执行操作，如果当前存在事务，就把当前事务挂起，执行结束之后再恢复事务</td></tr><tr><td align="left">Propagation.SUPPORTS</td><td align="left">如果当前存在事务则加入，如果当前没有事务，就以非事务方式执行</td></tr></tbody></table><h4 id="Propagation-REQUIRED"><a href="#Propagation-REQUIRED" class="headerlink" title="Propagation.REQUIRED"></a>Propagation.REQUIRED</h4><p><code>Propagation.REQUIRED</code> 是 <code>@Transactional</code> 的默认值，这是最常用的传播行为，适用于大多数需要事务管理的场合，尤其是希望多个操作能够在同一个事务中执行以确保数据的一致性时。它有如下特点：</p><ul><li>如果当前没有物理事务，那么Spring会创建一个新的事务</li><li>如果当前已经存在了一个物理事务，那么有<code>@Transactional(propagation = Propagation.REQUIRED)</code>注解的方法就会加入这个物理事务</li><li>每一个有<code>@Transactional(propagation = Propagation.REQUIRED)</code>注解的方法，都对应一个逻辑事务，这些逻辑事务会加入到同一个物理事务</li><li>每个逻辑事务都有自己的作用范围，但是在这种传播机制下，所有这些范围都会被映射到同一个物理事务中</li></ul><h4 id="Propagation-REQUIRES-NEW"><a href="#Propagation-REQUIRES-NEW" class="headerlink" title="Propagation.REQUIRES_NEW"></a>Propagation.REQUIRES_NEW</h4><p>总是创建新的事务，新的事务回滚不会影响原来的事务。当希望某个方法独立于外部事务进行提交或回滚时使用。即使外部事务回滚，这个新事务内的操作仍然可以成功提交，反之亦然。</p><p>在这种隔离级别下，每个物理事务都有自己的数据库连接，也就是说，当创建内部的物理事务的时候，会同步为这个事务绑定一个新的数据库连接。当内部的物理事务运行的时候，外部的物理事务的就会暂停执行（保持连接），当内部的物理事务提交之后，外部的时候恢复运行，继续执行提交或回滚操作。</p><p>另外，在这种传播级别下，即便内部的物理事务回滚，外部的物理事务也会正常提交，如果外部的物理事务在内部的物理事务提交之后回滚，内部的物理事务并不会受到任何影响。</p><h4 id="Propagation-NESTED"><a href="#Propagation-NESTED" class="headerlink" title="Propagation.NESTED"></a>Propagation.NESTED</h4><p>如果已经存在事务，则使用嵌套事务，如果当前没有事务，则新建事务。<code>Propagation.NESTED</code> 与PROPAGATION_REQUIRED比较类似，只是会使用保存点（savepoint），换句话说，内部逻辑事务可以部分回滚。savepoint是数据库事务中的<code>子事务</code>，事务可以回滚到savepoint而不影响savepoint创建前的变化，而不是回滚整个事务。支持嵌套事务的数据库较少，因此它的应用范围有限。主要用于需要部分回滚功能的场景。</p><h4 id="Propagation-MANDATORY"><a href="#Propagation-MANDATORY" class="headerlink" title="Propagation.MANDATORY"></a>Propagation.MANDATORY</h4><p>使用当前事务，如果当前没有事务，就抛出异常:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">org.springframework.transaction. IllegalTransactionStateException: No existing transaction found for transaction marked with propagation &#x27;mandatory&#x27;.<br></code></pre></td></tr></table></figure><p>因为外部已经存在了物理事务（通过Propagation. REQUIRED创建），那么内部事务将会加入这个事务，如果内部事务回滚了，外部事务也会回滚，这一点和 <code>Propagation.REQUIRED</code> 相同。用于强制必须在一个事务中执行的方法，确保这些方法总是在事务环境下被调用。这有助于避免意外地在无事务环境中执行重要操作。</p><h4 id="Propagation-NEVER"><a href="#Propagation-NEVER" class="headerlink" title="Propagation.NEVER"></a>Propagation.NEVER</h4><p>以非事务方式执行操作，如果当前存在事务，则抛出异常。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">org.springframework.transaction. IllegalTransactionStateException: Existing transaction found for transaction marked with propagation &#x27;never&#x27;<br></code></pre></td></tr></table></figure><p><font color=red>当调用有@Transactional(propagation &#x3D; Propagation.NEVER)注解的方法，一定要确保没有打开任何物理事务。</font></p><h4 id="Propagation-NOT-SUPPORTED"><a href="#Propagation-NOT-SUPPORTED" class="headerlink" title="Propagation.NOT_SUPPORTED"></a>Propagation.NOT_SUPPORTED</h4><p>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起，执行结束之后再恢复事务。用于那些不应该在事务中执行的操作，比如简单的查询操作，避免因为事务锁导致性能下降。</p><h4 id="Propagation-SUPPORTS"><a href="#Propagation-SUPPORTS" class="headerlink" title="Propagation.SUPPORTS"></a>Propagation.SUPPORTS</h4><p>如果当前存在事务则加入，如果当前没有事务，就以非事务方式执行。<font color=red>需要注意的是，即便当前的事务被挂起了，也应该避免执行运行时间很长的任务，这是因为被挂起的事务的数据库连接还是激活的状态，这意味着，数据库连接池无法重用这个连接。</font> 适合于那些不需要严格事务保证的操作，例如只读查询。这种设置允许在没有事务的情况下更高效地执行某些操作，同时也能在有事务的情况下共享事务资源。</p><h2 id="Spring事务实现原理"><a href="#Spring事务实现原理" class="headerlink" title="Spring事务实现原理"></a>Spring事务实现原理</h2><p>Spring 事务管理通过AOP、PlatformTransactionManager 接口和事务传播行为等机制，实现了对事务的自动化管理。</p><h3 id="spring事务核心接口"><a href="#spring事务核心接口" class="headerlink" title="spring事务核心接口"></a>spring事务核心接口</h3><p><strong>事务操作相关的API：</strong></p><ul><li>Spring事务@Enanle模块驱动：<code>@EnableTranSactionManagement</code></li><li>Spring事务注解：<code>@Transactional</code></li><li>Spring事务事件监听器：<code>@TransactionalEventListener</code></li></ul><p><strong>事务抽象相关的API</strong></p><ul><li>Spring平台事务管理器：<code>PlatformTransactionManager</code></li><li>Spring事务定义：<code>TransactionDefinition</code></li><li>Spring事务状态：<code>TransactionStatus</code></li><li>Spring事务代理配置：<code>ProxyTransactionManagementConfiguration</code></li></ul><p><strong>AOP相关的API：</strong></p><ul><li>Spring事务PointcutAdvisor实现：<code>BeanFactoryTransactionAttrubuteSourceAdvisor</code></li><li>Spring事务MethodInterceptor实现：<code>TransactionInterceptor</code></li><li>Spring事务属性源：<code>TransactionAttributeSource</code></li></ul><p>其中，PlatformTransactionManager、TransactionDefinition、TransactionStatus最为重要，他们之间的关系如下：<br><img src="/images/spring-%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%8E%9F%E7%90%86_Spring%E4%BA%8B%E5%8A%A1%E6%A0%B8%E5%BF%83%E6%8E%A5%E5%8F%A3.png"></p><h4 id="PlatformTransactionManager"><a href="#PlatformTransactionManager" class="headerlink" title="PlatformTransactionManager"></a>PlatformTransactionManager</h4><p>PlatformTransactionManager是Spring对于事务模型的抽象，它代表事务的整体执行过程。通常事务都应用在关系型数据库中，Spring对于事务的读写的模型做了更高层次的抽象，使得其可以应用在任何需要数据一致性的场景，比如JMX等，Spring将这些场景统一的抽象为commit和rollback两个核心方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">PlatformTransactionManager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TransactionManager</span> &#123;<br><br>  TransactionStatus <span class="hljs-title function_">getTransaction</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> TransactionDefinition definition)</span> <span class="hljs-keyword">throws</span> TransactionException;<br><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">commit</span><span class="hljs-params">(TransactionStatus status)</span> <span class="hljs-keyword">throws</span> TransactionException;<br><br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">rollback</span><span class="hljs-params">(TransactionStatus status)</span> <span class="hljs-keyword">throws</span> TransactionException;<br>&#125;<br></code></pre></td></tr></table></figure><font color=red>如果有@Transactional注解的方法，如果他们对应的传播行为不同，那么其对应的TransactionDefinition也是不同的，这也就是说getTransaction这个方法获取到的并不是物理事务，而是某个具体方法的逻辑事务，同理，commit和rollback也是对应的这个逻辑事务。</font><h4 id="TransactionDefinition"><a href="#TransactionDefinition" class="headerlink" title="TransactionDefinition"></a>TransactionDefinition</h4><p>TransactionDefinition是事务的元信息定义，类似于Spring IOC中BeanDefinition。实际上，Spring中事务的定义参考了EJB中对于事务的定义，TransactionDefinition的核心方法有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TransactionDefinition</span> &#123;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATION_REQUIRED</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATION_SUPPORTS</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATION_MANDATORY</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATION_REQUIRES_NEW</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATION_NOT_SUPPORTED</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATION_NEVER</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATION_NESTED</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">ISOLATION_DEFAULT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">ISOLATION_READ_UNCOMMITTED</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <br>  <span class="hljs-type">int</span> <span class="hljs-variable">ISOLATION_READ_COMMITTED</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">ISOLATION_REPEATABLE_READ</span> <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">ISOLATION_SERIALIZABLE</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">TIMEOUT_DEFAULT</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><br>  <span class="hljs-keyword">default</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getPropagationBehavior</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> PROPAGATION_REQUIRED;<br>&#125;<br><br>  <span class="hljs-keyword">default</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getIsolationLevel</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> ISOLATION_DEFAULT;<br>&#125;<br><br>  <span class="hljs-keyword">default</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getTimeout</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> TIMEOUT_DEFAULT;<br>&#125;<br><br>  <span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isReadOnly</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br>  <span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">default</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br>  <span class="hljs-keyword">static</span> TransactionDefinition <span class="hljs-title function_">withDefaults</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> StaticTransactionDefinition.INSTANCE;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="TransactionStatus"><a href="#TransactionStatus" class="headerlink" title="TransactionStatus"></a>TransactionStatus</h4><p>事务分为逻辑事务和物理事务，逻辑事务是指代码中事务的操作；物理事务是通过数据库连接来获取相关的物理的连接以及相关的数据库的事务。TransactionStatus是用来描述当前逻辑事务的执行情况，其核心方法及含义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TransactionStatus</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">TransactionExecution</span>, SavepointManager, Flushable &#123;<br><span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasSavepoint</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flush</span><span class="hljs-params">()</span> &#123;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从Spring5.2开始，对这个接口进行了拆分，将部分方法放置在了TransactionExecution中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TransactionExecution</span> &#123;<br><span class="hljs-keyword">default</span> String <span class="hljs-title function_">getTransactionName</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasTransaction</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isNewTransaction</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isNested</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isReadOnly</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRollbackOnly</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>(<span class="hljs-string">&quot;setRollbackOnly not supported&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isRollbackOnly</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCompleted</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Spring事务实现原理分析"><a href="#Spring事务实现原理分析" class="headerlink" title="Spring事务实现原理分析"></a>Spring事务实现原理分析</h3><p>Spring事务管理的核心在于其提供的抽象层，它通过PlatformTransactionManager接口统一了事务操作，让开发者可以方便地在不同的数据访问技术之间切换而无需修改业务逻辑代码。同时，通过AOP机制，Spring能够无缝地将事务管理集成到服务层方法调用中，简化了事务编程模型。下面是简单时序图：</p><p><img src="/images/spring-%E4%BA%8B%E5%8A%A1%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%8E%9F%E7%90%86_spring-%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E6%97%B6%E5%BA%8F%E5%9B%BE.png"></p><p><strong>简单逻辑：</strong></p><ul><li>代理创建：在Spring应用启动阶段，如果启用了事务管理（例如通过@EnableTransactionManagement），Spring会为带有@Transactional注解的Bean创建代理对象。这个过程通常涉及到AOP自动代理的创建。</li><li>事务开始：当调用被@Transactional标记的方法时，Spring的AOP代理会拦截该方法调用，并根据TransactionDefinition创建事务（通过调用PlatformTransactionManager.getTransaction()）。如果当前存在事务且传播行为允许，则加入现有事务；否则，创建新事务。</li><li>事务执行与状态维护：在事务执行期间，TransactionStatus对象会被用来跟踪事务的状态变化，比如设置回滚标志等。</li><li>事务提交&#x2F;回滚：方法正常返回后，Spring会尝试提交事务（调用PlatformTransactionManager.commit()）。如果方法抛出异常，且异常类型符合回滚条件（默认为unchecked异常），则会触发事务回滚（调用PlatformTransactionManager.rollback()）。</li></ul><h4 id="Transaction声明式事务实现分析"><a href="#Transaction声明式事务实现分析" class="headerlink" title="@Transaction声明式事务实现分析"></a>@Transaction声明式事务实现分析</h4><ul><li>@Transaction定义：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Inherited</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Reflective</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Transactional &#123;<br>  <span class="hljs-meta">@AliasFor(&quot;transactionManager&quot;)</span><br>String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-meta">@AliasFor(&quot;value&quot;)</span><br>String <span class="hljs-title function_">transactionManager</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>  String[] label() <span class="hljs-keyword">default</span> &#123;&#125;;<br>  Propagation <span class="hljs-title function_">propagation</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> Propagation.REQUIRED;<br>  Isolation <span class="hljs-title function_">isolation</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> Isolation.DEFAULT;<br>  <span class="hljs-type">int</span> <span class="hljs-title function_">timeout</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> TransactionDefinition.TIMEOUT_DEFAULT;<br>  String <span class="hljs-title function_">timeoutString</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">readOnly</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">false</span>;<br>  Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span>&gt;[] rollbackFor() <span class="hljs-keyword">default</span> &#123;&#125;;<br>  String[] rollbackForClassName() <span class="hljs-keyword">default</span> &#123;&#125;;<br>  Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span>&gt;[] noRollbackFor() <span class="hljs-keyword">default</span> &#123;&#125;;<br>  String[] noRollbackForClassName() <span class="hljs-keyword">default</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果需要在SpringBoot中要使用@Transactional，我们需要添加@EnableTransactionManagement注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-comment">// 自动装配类</span><br><span class="hljs-meta">@Import(TransactionManagementConfigurationSelector.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableTransactionManagement &#123;<br><span class="hljs-type">boolean</span> <span class="hljs-title function_">proxyTargetClass</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">false</span>;<br><br>AdviceMode <span class="hljs-title function_">mode</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> AdviceMode.PROXY;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">order</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> Ordered.LOWEST_PRECEDENCE;<br>&#125;<br></code></pre></td></tr></table></figure><p>@EnableTransactionManagement这个注解会通过@Import自动装配到TransactionManagementConfigurationSelector实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransactionManagementConfigurationSelector</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AdviceModeImportSelector</span>&lt;EnableTransactionManagement&gt; &#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> String[] selectImports(AdviceMode adviceMode) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span> (adviceMode) &#123;<br><span class="hljs-keyword">case</span> PROXY -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123;AutoProxyRegistrar.class.getName(),<br>ProxyTransactionManagementConfiguration.class.getName()&#125;;<br><span class="hljs-keyword">case</span> ASPECTJ -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123;determineTransactionAspectClass()&#125;;<br>&#125;;<br>&#125;<br><br><span class="hljs-keyword">private</span> String <span class="hljs-title function_">determineTransactionAspectClass</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> (ClassUtils.isPresent(<span class="hljs-string">&quot;jakarta.transaction.Transactional&quot;</span>, getClass().getClassLoader()) ?<br>TransactionManagementConfigUtils.JTA_TRANSACTION_ASPECT_CONFIGURATION_CLASS_NAME :<br>TransactionManagementConfigUtils.TRANSACTION_ASPECT_CONFIGURATION_CLASS_NAME);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>进入代理模式的配置类<code>ProxyTransactionManagementConfiguration</code> ，其是一个标准的SpringBoot的配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="hljs-meta">@ImportRuntimeHints(TransactionRuntimeHints.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyTransactionManagementConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractTransactionManagementConfiguration</span> &#123;<br><br><span class="hljs-meta">@Bean(name = TransactionManagementConfigUtils.TRANSACTION_ADVISOR_BEAN_NAME)</span><br><span class="hljs-meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="hljs-keyword">public</span> BeanFactoryTransactionAttributeSourceAdvisor <span class="hljs-title function_">transactionAdvisor</span><span class="hljs-params">(</span><br><span class="hljs-params">TransactionAttributeSource transactionAttributeSource, TransactionInterceptor transactionInterceptor)</span> &#123;<br><br><span class="hljs-type">BeanFactoryTransactionAttributeSourceAdvisor</span> <span class="hljs-variable">advisor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BeanFactoryTransactionAttributeSourceAdvisor</span>();<br>advisor.setTransactionAttributeSource(transactionAttributeSource);<br>advisor.setAdvice(transactionInterceptor);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.enableTx != <span class="hljs-literal">null</span>) &#123;<br>advisor.setOrder(<span class="hljs-built_in">this</span>.enableTx.&lt;Integer&gt;getNumber(<span class="hljs-string">&quot;order&quot;</span>));<br>&#125;<br><span class="hljs-keyword">return</span> advisor;<br>&#125;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="hljs-keyword">public</span> TransactionAttributeSource <span class="hljs-title function_">transactionAttributeSource</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// Accept protected @Transactional methods on CGLIB proxies, as of 6.0.</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationTransactionAttributeSource</span>(<span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@Role(BeanDefinition.ROLE_INFRASTRUCTURE)</span><br><span class="hljs-keyword">public</span> TransactionInterceptor <span class="hljs-title function_">transactionInterceptor</span><span class="hljs-params">(TransactionAttributeSource transactionAttributeSource)</span> &#123;<br><span class="hljs-type">TransactionInterceptor</span> <span class="hljs-variable">interceptor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TransactionInterceptor</span>();<br>interceptor.setTransactionAttributeSource(transactionAttributeSource);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.txManager != <span class="hljs-literal">null</span>) &#123;<br>interceptor.setTransactionManager(<span class="hljs-built_in">this</span>.txManager);<br>&#125;<br><span class="hljs-keyword">return</span> interceptor;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过配置项将注解解析添加到 <code>AnnotationTransactionAttributeSource</code>，转换为 BeanFactoryTransactionAttributeSourceAdvisor对象，最终生成事务代理对象。</p><h4 id="事务执行核心逻辑"><a href="#事务执行核心逻辑" class="headerlink" title="事务执行核心逻辑"></a>事务执行核心逻辑</h4><p>前面提到Spring事务是基于AOP实现的，通过配置加载最终会生成TransactionInterceptor，在事务执行过程中会AOP执行器链执行到 TransactionInterceptor#invoke():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(MethodInvocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>  <span class="hljs-comment">// Work out the target class: may be &#123;@code null&#125;.</span><br>  <span class="hljs-comment">// The TransactionAttributeSource should be passed the target class</span><br>  <span class="hljs-comment">// as well as the method, which may be from an interface.</span><br>  Class&lt;?&gt; targetClass = (invocation.getThis() != <span class="hljs-literal">null</span> ? AopUtils.getTargetClass(invocation.getThis()) : <span class="hljs-literal">null</span>);<br><br>  <span class="hljs-comment">// Adapt to TransactionAspectSupport&#x27;s invokeWithinTransaction...</span><br>  <span class="hljs-keyword">return</span> invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed);<br>&#125;<br></code></pre></td></tr></table></figure><p>进入 invokeWithinTransaction 方法内，可以看到事务的整体逻辑在这个方法内实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">invokeWithinTransaction</span><span class="hljs-params">(Method method, <span class="hljs-meta">@Nullable</span> Class&lt;?&gt; targetClass,</span><br><span class="hljs-params">    <span class="hljs-keyword">final</span> InvocationCallback invocation)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br><br>  <span class="hljs-comment">// If the transaction attribute is null, the method is non-transactional.</span><br>  <span class="hljs-type">TransactionAttributeSource</span> <span class="hljs-variable">tas</span> <span class="hljs-operator">=</span> getTransactionAttributeSource();<br>  <span class="hljs-keyword">final</span> <span class="hljs-type">TransactionAttribute</span> <span class="hljs-variable">txAttr</span> <span class="hljs-operator">=</span> (tas != <span class="hljs-literal">null</span> ? tas.getTransactionAttribute(method, targetClass) : <span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">final</span> <span class="hljs-type">TransactionManager</span> <span class="hljs-variable">tm</span> <span class="hljs-operator">=</span> determineTransactionManager(txAttr);<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.reactiveAdapterRegistry != <span class="hljs-literal">null</span> &amp;&amp; tm <span class="hljs-keyword">instanceof</span> ReactiveTransactionManager rtm) &#123;<br>    <span class="hljs-comment">// reactive 事务</span><br>  &#125;<br><br>  <span class="hljs-type">PlatformTransactionManager</span> <span class="hljs-variable">ptm</span> <span class="hljs-operator">=</span> asPlatformTransactionManager(tm);<br>  <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">joinpointIdentification</span> <span class="hljs-operator">=</span> methodIdentification(method, targetClass, txAttr);<br><br>  <span class="hljs-keyword">if</span> (txAttr == <span class="hljs-literal">null</span> || !(ptm <span class="hljs-keyword">instanceof</span> CallbackPreferringPlatformTransactionManager cpptm)) &#123;<br>    <span class="hljs-comment">// Standard transaction demarcation with getTransaction and commit/rollback calls.</span><br>    <span class="hljs-comment">// 获取事务隔离别</span><br>    <span class="hljs-type">TransactionInfo</span> <span class="hljs-variable">txInfo</span> <span class="hljs-operator">=</span> createTransactionIfNecessary(ptm, txAttr, joinpointIdentification);<br><br>    Object retVal;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// This is an around advice: Invoke the next interceptor in the chain.</span><br>      <span class="hljs-comment">// This will normally result in a target object being invoked.</span><br>      <span class="hljs-comment">// 环绕通知</span><br>      retVal = invocation.proceedWithInvocation();<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>      <span class="hljs-comment">// target invocation exception</span><br>      <span class="hljs-comment">// 发生异常</span><br>      completeTransactionAfterThrowing(txInfo, ex);<br>      <span class="hljs-keyword">throw</span> ex;<br>    &#125;<br>    <span class="hljs-keyword">finally</span> &#123;<br>      cleanupTransactionInfo(txInfo);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (retVal != <span class="hljs-literal">null</span> &amp;&amp; txAttr != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-type">TransactionStatus</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> txInfo.getTransactionStatus();<br>      <span class="hljs-keyword">if</span> (status != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (retVal <span class="hljs-keyword">instanceof</span> Future&lt;?&gt; future &amp;&amp; future.isDone()) &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>            future.get();<br>          &#125;<br>        &#125;<br>        ....<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 正常提交</span><br>    commitTransactionAfterReturning(txInfo);<br>    <span class="hljs-keyword">return</span> retVal;<br>  &#125;<br>  <span class="hljs-comment">// 异常回滚</span><br>  <span class="hljs-keyword">else</span> &#123;<br>    Object result;<br>    <br>    ......<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">protected</span> TransactionInfo <span class="hljs-title function_">createTransactionIfNecessary</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> PlatformTransactionManager tm,</span><br><span class="hljs-params"><span class="hljs-meta">@Nullable</span> TransactionAttribute txAttr, <span class="hljs-keyword">final</span> String joinpointIdentification)</span> &#123;<br><span class="hljs-keyword">if</span> (txAttr != <span class="hljs-literal">null</span> &amp;&amp; txAttr.getName() == <span class="hljs-literal">null</span>) &#123;<br>txAttr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelegatingTransactionAttribute</span>(txAttr) &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> joinpointIdentification;<br>&#125;<br>&#125;;<br>&#125;<br><br><span class="hljs-type">TransactionStatus</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">if</span> (txAttr != <span class="hljs-literal">null</span>) &#123;<br><span class="hljs-keyword">if</span> (tm != <span class="hljs-literal">null</span>) &#123;<br>status = tm.getTransaction(txAttr);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>上述代码的整体逻辑为：</strong></p><ul><li>获取事务管理器</li><li>视情况创建事务</li><li>执行业务方法</li><li>当捕捉到异常判断是否回滚处理</li><li>无异常时判断是否提交处理</li></ul><h5 id="commitTransactionAfterReturning-txInfo-事务提交"><a href="#commitTransactionAfterReturning-txInfo-事务提交" class="headerlink" title="commitTransactionAfterReturning(txInfo) 事务提交"></a>commitTransactionAfterReturning(txInfo) 事务提交</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commitTransactionAfterReturning</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> TransactionInfo txInfo)</span> &#123;<br>  <span class="hljs-keyword">if</span> (txInfo != <span class="hljs-literal">null</span> &amp;&amp; txInfo.getTransactionStatus() != <span class="hljs-literal">null</span>) &#123;<br>    txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>commit():</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">commit</span><span class="hljs-params">(TransactionStatus status)</span> <span class="hljs-keyword">throws</span> TransactionException &#123;<br>  processCommit(defStatus);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processCommit</span><span class="hljs-params">(DefaultTransactionStatus status)</span> <span class="hljs-keyword">throws</span> TransactionException &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">beforeCompletionInvoked</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">commitListenerInvoked</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-type">boolean</span> <span class="hljs-variable">unexpectedRollback</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>      prepareForCommit(status);<br>      triggerBeforeCommit(status);<br>      triggerBeforeCompletion(status);<br>      beforeCompletionInvoked = <span class="hljs-literal">true</span>;<br><br>      <span class="hljs-keyword">if</span> (status.hasSavepoint()) &#123;<br>        <br>        unexpectedRollback = status.isGlobalRollbackOnly();<br>        <span class="hljs-built_in">this</span>.transactionExecutionListeners.forEach(listener -&gt; listener.beforeCommit(status));<br>        commitListenerInvoked = <span class="hljs-literal">true</span>;<br>        status.releaseHeldSavepoint();<br>      &#125;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (status.isNewTransaction()) &#123;<br>        <br>        unexpectedRollback = status.isGlobalRollbackOnly();<br>        <span class="hljs-built_in">this</span>.transactionExecutionListeners.forEach(listener -&gt; listener.beforeCommit(status));<br>        commitListenerInvoked = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 最终提交事务，由具体的 ORM 框架实现 </span><br>        doCommit(status);<br>      &#125;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isFailEarlyOnGlobalRollbackOnly()) &#123;<br>        unexpectedRollback = status.isGlobalRollbackOnly();<br>      &#125;<br>    &#125;<br>    .....<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="事务失效问题分析"><a href="#事务失效问题分析" class="headerlink" title="事务失效问题分析"></a>事务失效问题分析</h3><ul><li>方法内部调用： <code>@Transactional</code> 是通过AOP来实现，如果在一个类内部调用则为 <code>this.xxxMethod()</code>，这里this并不是一个代理对象，因此会失效。</li><li>访问权限不正确：被 <code>@Transactional</code> 修饰的方法为 private， 刚事务会失效。在配置加载的时候只判断public方法：<code>if (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) </code></li><li>方法使用final修饰: 通过cglib是通过生成子类来方式生成代理类，事务方法被定义为final，则意味着该方法无法被重写，无法添加事务功能。</li><li>未被Spring管理</li><li>多线程调用：事务有一个很重要的特性，就是不能跨线程使用</li><li>存储引擎不支持事务</li><li>错误的传播特性</li><li>异常处理不正确：@Transactional默认捕获的异常是RuntimeException和Error，如果抛出的是其他类型异常，则会导致事务无法回滚。</li></ul><h3 id="实践经验"><a href="#实践经验" class="headerlink" title="实践经验"></a>实践经验</h3><p>在日常的开发中，也最好遵循一些业界探索出的实践经验，以确保事务的正确管理和数据的一致性：</p><ul><li><strong>明确标记事务边界</strong>：使用@Transactional注解明确标记需要进行事务管理的方法。将注解放在方法上，以确保在方法执行期间启用事务管理。</li><li><strong>设置适当的事务传播行为和隔离级别</strong>：根据业务需求，选择适当的事务传播行为和隔离级别。确保在不同的方法调用中正确管理事务的传播和隔离。</li><li><strong>限制事务作用范围</strong>：将事务的作用范围限制在需要进行事务管理的最小代码块上，而不是整个方法或类。这样可以减少锁定资源的时间和范围，提高并发性能。</li><li><strong>避免长时间事务</strong>：长时间事务会占用数据库资源并降低系统性能。尽量将事务的执行时间控制在合理的范围内，避免长时间的事务操作。</li><li><strong>捕获并处理异常</strong>：在事务方法中捕获并处理异常是必要的。根据业务需求，选择适当的处理方式，如回滚事务、记录日志或抛出自定义异常。</li><li><strong>尽量避免嵌套事务</strong>：嵌套事务会增加事务管理的复杂性，并可能导致死锁等并发问题。除非必要，尽量避免使用嵌套事务。</li><li><strong>注意事务的回滚规则</strong>：通过设置rollbackFor属性，明确指定哪些异常会触发事务的回滚。确保异常的正确处理和事务的正确回滚。</li><li><strong>定期进行性能调优和监控</strong>：对于事务频繁的应用程序，定期进行性能调优和监控是必要的。通过监控事务执行时间、数据库锁定情况等指标，优化事务管理和数据库设计。</li><li><strong>编写单元测试验证事务管理</strong>：编写单元测试来验证事务管理的正确性。使用Spring的测试框架和事务支持来模拟数据库操作和事务回滚，确保事务管理的正确性。</li></ul>]]></content>
    
    
    <categories>
      
      <category>spring</category>
      
      <category>事务</category>
      
      <category>spring-boot</category>
      
      <category>AOP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
      <tag>spring-boot</tag>
      
      <tag>AOP</tag>
      
      <tag>事务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring-AOP基础与原理</title>
    <link href="/2025/06/11/spring-aop%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%8E%9F%E7%90%86/"/>
    <url>/2025/06/11/spring-aop%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>Spring AOP（面向切面编程）是 Spring 框架中用于实现横切关注点分离的重要模块，它允许开发者将诸如日志记录、事务管理等通用功能从业务逻辑中分离出来。</p><p>Spring AOP 主要通过动态代理技术来实现。当一个 Bean 被标记为需要应用 AOP 切面时，Spring 会为其创建一个代理对象而不是直接使用目标对象。这个代理对象可以是 JDK 动态代理或 CGLIB 代理，取决于被代理的目标对象是否实现了接口。</p><span id="more"></span><ul><li>JDK 动态代理：如果目标类实现了至少一个接口，则 Spring 使用 JDK 提供的 java.lang.reflect.Proxy 来创建代理。代理对象会实现与目标对象相同的接口，并拦截对接口方法的调用。</li><li>CGLIB 代理：如果目标类没有实现任何接口，或者明确指定了使用 CGLIB，则 Spring 会利用 CGLIB 库生成目标类的一个子类作为代理。这种方式下，代理不仅能够拦截接口方法，也能拦截类中的非 final 方法。</li></ul><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul><li><strong>切面（Aspect）</strong>：横切关注点的模块化封装，包含通知（Advice）和切入点（Pointcut）。</li><li><strong>切入点（Pointcut）</strong>：定义哪些方法或代码块需要被拦截（通过表达式匹配，如 <code>execution(* com.ares.Controller..*(..))</code>）。</li><li>通知（Advice）：在切入点处执行的代码，包括五种类型：<ul><li><strong>前置通知（Before）</strong>：目标方法执行前触发。</li><li><strong>后置通知（After Returning&#x2F;@After）</strong>：目标方法正常执行后触发。</li><li><strong>异常通知（AfterThrowing&#x2F;@After）</strong>：目标方法抛出异常时触发。</li><li><strong>最终通知（After）</strong>：无论是否异常，目标方法执行后触发。</li><li><strong>环绕通知（Around）</strong>：包裹目标方法，在其前后均执行逻辑。</li></ul></li><li><strong>目标对象（Target Object）</strong>：被代理的对象，其方法会被增强。</li><li><strong>AOP代理（Proxy）</strong>：Spring生成的代理对象，负责拦截方法调用并执行通知逻辑。</li></ul><h2 id="应用-API请求日志"><a href="#应用-API请求日志" class="headerlink" title="应用 - API请求日志"></a>应用 - API请求日志</h2><ul><li>实现记录请求API日志：请求参数，RemoteIp，请求时间，traceID等</li><li>MDC</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RequestsLoggerAspect</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(<span class="hljs-string">&quot;api&quot;</span>);<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Gson gson;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">TRACE_ID</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;traceId&quot;</span>;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">RequestsLoggerAspect</span><span class="hljs-params">(Gson gson)</span> &#123;<br>    <span class="hljs-built_in">this</span>.gson = gson;<br>  &#125;<br><br><br>  <span class="hljs-meta">@Pointcut(&quot;execution(* com.*.controller.*.*(..))&quot;)</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">requestLogger</span><span class="hljs-params">()</span> &#123;&#125;<br><br>  <span class="hljs-meta">@Around(&quot;requestLogger()&quot;)</span><br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">log</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-type">ServletRequestAttributes</span> <span class="hljs-variable">requestAttributes</span> <span class="hljs-operator">=</span><br>        (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();<br>    <span class="hljs-keyword">if</span> (requestAttributes == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> joinPoint.proceed();<br>    &#125;<br><br>    <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> requestAttributes.getRequest();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">reqId</span> <span class="hljs-operator">=</span> request.getHeader(TRACE_ID);<br><br>    <span class="hljs-keyword">if</span> (!StringUtils.hasText(reqId) || Objects.equals(reqId, <span class="hljs-string">&quot;0&quot;</span>)) &#123;<br>      reqId = getTraceId();<br>    &#125;<br>    MDC.put(TRACE_ID, reqId);<br><br>    <span class="hljs-comment">// 通过请求获取url,ip</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> request.getRequestURL().toString();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">remoteIp</span> <span class="hljs-operator">=</span> getIpAddr(request);<br><br>    <span class="hljs-comment">// 获取请求头信息</span><br>    Map&lt;String, Object&gt; header = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    Enumeration&lt;String&gt; headerNames = request.getHeaderNames();<br>    <span class="hljs-keyword">while</span> (headerNames.hasMoreElements()) &#123;<br>      <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> headerNames.nextElement();<br>      <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> request.getHeader(key);<br>      header.put(key, value);<br>    &#125;<br><br>    <span class="hljs-comment">// 获取方法所在的类名</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> joinPoint.getTarget().getClass().getName();<br>    <span class="hljs-comment">// 获取方法名</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> joinPoint.getSignature().getName();<br>    <span class="hljs-comment">// 获取参数名</span><br>    String[] parameterNamesArgs =<br>        ((org.aspectj.lang.reflect.MethodSignature) joinPoint.getSignature()).getParameterNames();<br>    <span class="hljs-comment">// 获取参数值</span><br>    Object[] args = joinPoint.getArgs();<br><br>    joinPoint.getSignature().getDeclaringTypeName();<br><br>    Map&lt;String, Object&gt; params = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; parameterNamesArgs.length; i++) &#123;<br>      params.put(parameterNamesArgs[i], args[i]);<br>    &#125;<br><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      logger.info(<br>          <span class="hljs-string">&quot;start:&#123;&#125; | remote ip:&#123;&#125; | url:&#123;&#125; | class:&#123;&#125; | func :&#123;&#125; | params:&#123;&#125; | header:&#123;&#125;&quot;</span>,<br>          start, remoteIp, url, className, methodName, gson.toJson(params), gson.toJson(header));<br>      result = joinPoint.proceed();<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>      <span class="hljs-keyword">throw</span> e;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>      <span class="hljs-type">long</span> <span class="hljs-variable">cost</span> <span class="hljs-operator">=</span> end - start;<br>      logger.info(<span class="hljs-string">&quot;end:&#123;&#125; | cost :&#123;&#125;ms | result:&#123;&#125;&quot;</span>, end, cost, gson.toJson(result));<br>      MDC.remove(TRACE_ID);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getIpAddr</span><span class="hljs-params">(HttpServletRequest request)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">ipAddress</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;x-forwarded-for&quot;</span>);<br>    <span class="hljs-keyword">if</span> (!StringUtils.hasText(ipAddress) || <span class="hljs-string">&quot;unknown&quot;</span>.equalsIgnoreCase(ipAddress)) &#123;<br>      ipAddress = request.getHeader(<span class="hljs-string">&quot;Proxy-Client-IP&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!StringUtils.hasText(ipAddress) || <span class="hljs-string">&quot;unknown&quot;</span>.equalsIgnoreCase(ipAddress)) &#123;<br>      ipAddress = request.getHeader(<span class="hljs-string">&quot;WL-Proxy-Client-IP&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!StringUtils.hasText(ipAddress) || <span class="hljs-string">&quot;unknown&quot;</span>.equalsIgnoreCase(ipAddress)) &#123;<br>      ipAddress = request.getRemoteAddr();<br>    &#125;<br>    <span class="hljs-comment">// 对于通过多个代理的情况，第一个IP为客户端真实IP,多个IP按照&#x27;,&#x27;分割</span><br>    <span class="hljs-keyword">if</span> (!StringUtils.hasText(ipAddress) &amp;&amp; ipAddress.length() &gt; <span class="hljs-number">15</span>) &#123;<br>      <span class="hljs-keyword">if</span> (ipAddress.indexOf(<span class="hljs-string">&quot;,&quot;</span>) &gt; <span class="hljs-number">0</span>) &#123;<br>        ipAddress = ipAddress.substring(<span class="hljs-number">0</span>, ipAddress.indexOf(<span class="hljs-string">&quot;,&quot;</span>));<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 或者这样也行,对于通过多个代理的情况，第一个IP为客户端真实IP,多个IP按照&#x27;,&#x27;分割</span><br>    <span class="hljs-keyword">return</span> ipAddress;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> String <span class="hljs-title function_">getTraceId</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">UUID</span> <span class="hljs-variable">uuid</span> <span class="hljs-operator">=</span> UUID.randomUUID();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> uuid.getMostSignificantBits() &gt;&gt;&gt; <span class="hljs-number">26</span>; <span class="hljs-comment">// 取高24位</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> String.valueOf(l);<br><br>    <span class="hljs-keyword">if</span> (id.length() &gt; <span class="hljs-number">6</span>) &#123;<br>      id = id.substring(<span class="hljs-number">0</span>, <span class="hljs-number">6</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (id.length() &lt; <span class="hljs-number">6</span>) &#123;<br>      id = String.format(<span class="hljs-string">&quot;%0&quot;</span> + <span class="hljs-number">6</span> + <span class="hljs-string">&quot;d&quot;</span>, Long.parseLong(id));<br>    &#125;<br>    <span class="hljs-keyword">return</span> Instant.now().toEpochMilli() + id;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>Spring AOP 的实现原理是基于<strong>动态代理</strong>和<strong>字节码操作</strong>的。在编译时， Spring 会使用 <strong>AspectJ</strong> 编译器将切面代码编译成字节码文件。在运行时， Spring5.0后会使用 Java 动态代理或 Byte Buddy作为默认代理<strong>生成代理类</strong>，这些代理类会在目标对象方法执行前后插入切面代码，从而实现AOP的功能。Spring AOP 可以使用两种代理方式：JDK动态代理和 Byte Buddy 代理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span><br><span class="hljs-meta">@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IdGenApplication</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    SpringApplication.run(IdGenApplication.class, args);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>或 yaml配置文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring.aop.proxy-target-class:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h3 id="EnableAspectJAutoProxy"><a href="#EnableAspectJAutoProxy" class="headerlink" title="@EnableAspectJAutoProxy"></a>@EnableAspectJAutoProxy</h3><p>在spring-boot项目开发中引入spring-boot-starter-aop，通过@Enable模块驱动注解EnableAspectJAutoProxy用于开启AspectJ自动代理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Import(&#123;AspectJAutoProxyRegistrar.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableAspectJAutoProxy &#123;<br>  <span class="hljs-comment">// 为true时强制使用 cglib/Byte Buddy</span><br>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">proxyTargetClass</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">false</span>;<br><br>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">exposeProxy</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>@EnableAspectJAutoProxy通过@Import导入了AspectJAutoProxyRegistrarAspectJ自动代理注册器，在这个类中实现了 BeanDefinition 的注册，而后面的过程就是 Bean 的注册过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AspectJAutoProxyRegistrar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ImportBeanDefinitionRegistrar</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> &#123;<br>    <span class="hljs-comment">// 往IOC容器里注册了一个类型为AnnotationAwareAspectJAutoProxyCreator</span><br>    AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);<br><br>    <span class="hljs-type">AnnotationAttributes</span> <span class="hljs-variable">enableAspectJAutoProxy</span> <span class="hljs-operator">=</span> AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);<br>    <span class="hljs-keyword">if</span> (enableAspectJAutoProxy != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="hljs-string">&quot;proxyTargetClass&quot;</span>)) &#123;<br>        AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (enableAspectJAutoProxy.getBoolean(<span class="hljs-string">&quot;exposeProxy&quot;</span>)) &#123;<br>        AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><font color = red>@EnableAspectJAutoProxy模块驱动注解往IOC容器中注册了类型为AnnotationAwareAspectJAutoProxyCreator的Bean，Bean名称为org.springframework.aop.config.internalAutoProxyCreator。</font><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> BeanDefinition <span class="hljs-title function_">registerOrEscalateApcAsRequired</span><span class="hljs-params">(</span><br><span class="hljs-params">    Class&lt;?&gt; cls, BeanDefinitionRegistry registry, <span class="hljs-meta">@Nullable</span> Object source)</span> &#123;<br><br>  <span class="hljs-comment">// 判断是否存在 internalAutoProxyCreator</span><br>  <span class="hljs-keyword">if</span> (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) &#123;<br>    <span class="hljs-type">BeanDefinition</span> <span class="hljs-variable">apcDefinition</span> <span class="hljs-operator">=</span> registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);<br>    <span class="hljs-keyword">if</span> (!cls.getName().equals(apcDefinition.getBeanClassName())) &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">currentPriority</span> <span class="hljs-operator">=</span> findPriorityForClass(apcDefinition.getBeanClassName());<br>      <span class="hljs-type">int</span> <span class="hljs-variable">requiredPriority</span> <span class="hljs-operator">=</span> findPriorityForClass(cls);<br>      <span class="hljs-keyword">if</span> (currentPriority &lt; requiredPriority) &#123;<br>        apcDefinition.setBeanClassName(cls.getName());<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br><br>  <span class="hljs-comment">// 在引入spring-boot-starter-aop后，aop自动装配时容器中并没有这个类型的 Bean, 所以直接在 RootBeanDefinition 注册一个</span><br>  <span class="hljs-type">RootBeanDefinition</span> <span class="hljs-variable">beanDefinition</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RootBeanDefinition</span>(cls);<br>  beanDefinition.setSource(source);<br>  beanDefinition.getPropertyValues().add(<span class="hljs-string">&quot;order&quot;</span>, Ordered.HIGHEST_PRECEDENCE);<br>  beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);<br>  registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);<br>  <span class="hljs-keyword">return</span> beanDefinition;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的核心逻辑为通过RootBeanDefinition往IOC注册了名称为AUTO_PROXY_CREATOR_BEAN_NAME（常量，值为<code>org.springframework.aop.config.internalAutoProxyCreator</code> ），类型为AnnotationAwareAspectJAutoProxyCreator的Bean。</p><p><img src="/images/spring-aop%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%8E%9F%E7%90%86_AnnotationAwareAspectJAutoProxyCreater%E7%B1%BB%E5%9B%BE.png"></p><p>AnnotationAwareAspectJAutoProxyCreator的父类AbstractAutoProxyCreator实现了SmartInstantiationAwareBeanPostProcessor和BeanFactoryAware接口。实现BeanFactoryAware用于在Bean初始化时注入BeanFactory，而SmartInstantiationAwareBeanPostProcessor接口的父类为InstantiationAwareBeanPostProcessor接口，该接口继承自<code>BeanPostProcessor</code>接口。</p><p>在AbstractAutoProxyCreator类实现了InstantiationAwareBeanPostProcessor接口的<strong>postProcessBeforeInstantiation</strong>方法（自定义Bean实例化前操作逻辑），以及实现了BeanPostProcessor的postProcessAfterInitialization方法（自定义Bean初始化后操作逻辑）。</p><h3 id="创建代理过程"><a href="#创建代理过程" class="headerlink" title="创建代理过程"></a>创建代理过程</h3><p>Spring AOP是怎样增强我们定义的目标类TargetClass的？在AbstractAutoProxyCreator#postProcessBeforeInstantiation()实现了具体的代理逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">postProcessBeforeInstantiation</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> &#123;<br>  <span class="hljs-type">Object</span> <span class="hljs-variable">cacheKey</span> <span class="hljs-operator">=</span> getCacheKey(beanClass, beanName);<br><br>  <span class="hljs-keyword">if</span> (!StringUtils.hasLength(beanName) || !<span class="hljs-built_in">this</span>.targetSourcedBeans.contains(beanName)) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.advisedBeans.containsKey(cacheKey)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123;<br>      <span class="hljs-built_in">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// Create proxy here if we have a custom TargetSource.</span><br>  <span class="hljs-comment">// Suppresses unnecessary default instantiation of the target bean:</span><br>  <span class="hljs-comment">// The TargetSource will handle target instances in a custom fashion.</span><br>  <span class="hljs-type">TargetSource</span> <span class="hljs-variable">targetSource</span> <span class="hljs-operator">=</span> getCustomTargetSource(beanClass, beanName);<br>  <span class="hljs-keyword">if</span> (targetSource != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">if</span> (StringUtils.hasLength(beanName)) &#123;<br>      <span class="hljs-built_in">this</span>.targetSourcedBeans.add(beanName);<br>    &#125;<br>    Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> createProxy(beanClass, beanName, specificInterceptors, targetSource);<br>    <span class="hljs-built_in">this</span>.proxyTypes.put(cacheKey, proxy.getClass());<br>    <span class="hljs-keyword">return</span> proxy;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><ul><li><p>通过Bean名称和Bean类型获取该Bean的唯一缓存键名: getCacheKey(beanClass, beanName)</p></li><li><p>判断当前Bean是否包含在advisedBeans集合中</p></li><li><p>判断当前 Bean 是否是基础类，isInfrastructureClass(): 这一步主要逻辑：判断当前Bean（TargetClass）是否是Advice，Pointcut，Advisor，AopInfrastructureBean的子类或者是否为切面类（@Aspect注解标注）。</p></li><li><p>判断是否需要跳过：</p></li><li><p>通过Bean名称判断是否以AutowireCapableBeanFactory.ORIGINAL_INSTANCE_SUFFIX（.ORIGINAL）结尾，是的话返回true表示跳过代理。</p></li><li><p>如果我们自定义了TargetSource，则在此处创建Bean代理，以取代目标Bean的后续默认实例化方式。我们并没有自定义TargetSource，所以直接跳过。</p></li><li><p>getAdvicesAndAdvisorsForBean方法内部主要包含以下这些逻辑:</p><ul><li>获取所有的通知方法（切面里定义的各个方法）；</li><li>通过切点表达式判断这些通知方法是否可为当前Bean所用；</li><li>如果有符合的通知方法，则对它们进行排序。</li></ul></li><li><p>创建代理: createProxy(beanClass, beanName, specificInterceptors, targetSource)</p></li></ul><p>后续从IOC容器中获得的TargetClass就是被代理后的对象，执行代理对象的目标方法的时候，代理对象会执行相应的通知方法链。</p><h3 id="生成拦截器链MethodInterceptor"><a href="#生成拦截器链MethodInterceptor" class="headerlink" title="生成拦截器链MethodInterceptor"></a>生成拦截器链MethodInterceptor</h3><p><strong>拦截器链</strong> 就是在代理对象的某个方法被执行时，从通知方法集合中筛选出适用于该方法的通知，然后封装为拦截器对象集合（类型为MethodInteceptor）。</p><p>在上面示例中当执行到：target.targetMethod() 时，会进入到：CglibAopProxy的intercept 中, 也就是说我们的目标对象的目标方法被CglibAopProxy的intercept方法拦截了:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br><br>  <span class="hljs-type">Object</span> <span class="hljs-variable">oldProxy</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">setProxyContext</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>  <span class="hljs-type">Object</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>  <span class="hljs-type">TargetSource</span> <span class="hljs-variable">targetSource</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.advised.getTargetSource();<br>  <br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.advised.exposeProxy) &#123;<br>      <span class="hljs-comment">// Make invocation available if necessary.</span><br>      oldProxy = AopContext.setCurrentProxy(proxy);<br>      setProxyContext = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// Get as late as possible to minimize the time we &quot;own&quot; the target, in case it comes from a pool...</span><br>    target = targetSource.getTarget();<br>    Class&lt;?&gt; targetClass = (target != <span class="hljs-literal">null</span> ? target.getClass() : <span class="hljs-literal">null</span>);<br>    List&lt;Object&gt; chain = <span class="hljs-built_in">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);<br>    Object retVal; <span class="hljs-comment">// 获取目标对象目标方法的拦截器链</span><br>    <br>    <span class="hljs-comment">// Check whether we only have one InvokerInterceptor: that is,</span><br>    <span class="hljs-comment">// no real advice, but just reflective invocation of the target.</span><br>    <span class="hljs-keyword">if</span> (chain.isEmpty()) &#123;<br>      <span class="hljs-comment">// We can skip creating a MethodInvocation: just invoke the target directly.</span><br>      <span class="hljs-comment">// Note that the final invoker must be an InvokerInterceptor, so we know</span><br>      <span class="hljs-comment">// it does nothing but a reflective operation on the target, and no hot</span><br>      <span class="hljs-comment">// swapping or fancy proxying.</span><br>      <span class="hljs-comment">// 如果拦截器为空，则通过反射方式执行目标方法</span><br>      Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);<br>      retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);<br>    &#125;<br>    <br>    <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 如果拦截器不空则创建ReflectiveMethodInvocation对象，执行它的 proceed 方法</span><br>      <span class="hljs-comment">// We need to create a method invocation...</span><br>      retVal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReflectiveMethodInvocation</span>(proxy, target, method, args, targetClass, chain).proceed();<br>    &#125;<br>    <span class="hljs-keyword">return</span> processReturnType(proxy, target, method, args, retVal);<br>  &#125;<br>  <br>  <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">if</span> (target != <span class="hljs-literal">null</span> &amp;&amp; !targetSource.isStatic()) &#123;<br>      targetSource.releaseTarget(target);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (setProxyContext) &#123;<br>      <span class="hljs-comment">// Restore old proxy.</span><br>      AopContext.setCurrentProxy(oldProxy);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>getInterceptorsAndDynamicInterceptionAdvice方法中遍历代理对象的通知集合：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Determine a list of &#123;<span class="hljs-doctag">@link</span> org.aopalliance.intercept.MethodInterceptor&#125; objects</span><br><span class="hljs-comment"> * for the given method, based on this configuration.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> method the proxied method</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> targetClass the target class</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> a List of MethodInterceptors (may also include InterceptorAndDynamicMethodMatchers)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> List&lt;Object&gt; <span class="hljs-title function_">getInterceptorsAndDynamicInterceptionAdvice</span><span class="hljs-params">(Method method, <span class="hljs-meta">@Nullable</span> Class&lt;?&gt; targetClass)</span> &#123;<br><span class="hljs-comment">// 创建目标方法的缓存 key</span><br>  List&lt;Object&gt; cachedInterceptors;<br> <br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.methodCache != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// Method-specific cache for method-specific pointcuts</span><br>    <span class="hljs-type">MethodCacheKey</span> <span class="hljs-variable">cacheKey</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodCacheKey</span>(method);<br><br>    cachedInterceptors = <span class="hljs-built_in">this</span>.methodCache.get(cacheKey);<br>    <span class="hljs-comment">// 第一次，未缓存，创建缓存</span><br>    <span class="hljs-keyword">if</span> (cachedInterceptors == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">// </span><br>      cachedInterceptors = <span class="hljs-built_in">this</span>.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(<br>          <span class="hljs-built_in">this</span>, method, targetClass);<br>      <span class="hljs-built_in">this</span>.methodCache.put(cacheKey, cachedInterceptors);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// Shared cache since there are no method-specific advisors (see below).</span><br>    cachedInterceptors = <span class="hljs-built_in">this</span>.cachedInterceptors;<br>    <span class="hljs-keyword">if</span> (cachedInterceptors == <span class="hljs-literal">null</span>) &#123;<br>      cachedInterceptors = <span class="hljs-built_in">this</span>.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(<br>          <span class="hljs-built_in">this</span>, method, targetClass);<br>      <span class="hljs-built_in">this</span>.cachedInterceptors = cachedInterceptors;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> cachedInterceptors;<br>&#125;<br></code></pre></td></tr></table></figure><p>拦截器链第一个元素类型为ExposeInvocationInterceptor，是默认的拦截器，剩下四个依次为：MethodBeforeAdviceInterceptor、AspectJAfterAdvice、AfterReturningAdviceInterceptor和AspectJAfterThrowingAdvice，它们都是MethodInterceptor的实现类。</p><p>获取到了代理对象目标方法的拦截器链后，判断拦截器链不为空时，CglibAopProxy的intercept方法创建CglibMethodInvocation对象，并调用它的proceed方法, 完成拦截器链处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Nullable</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">proceed</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.proceed();<br>  &#125;<br>  <span class="hljs-keyword">catch</span> (RuntimeException ex) &#123;<br>    <span class="hljs-keyword">throw</span> ex;<br>  &#125;<br>  <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>  ......<br>  &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>动态代理</category>
      
      <category>spring</category>
      
      <category>spring-boot</category>
      
      <category>AOP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>动态代理</tag>
      
      <tag>spring</tag>
      
      <tag>spring-boot</tag>
      
      <tag>AOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring-IOC基础与原理</title>
    <link href="/2025/06/11/spring-ioc%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%8E%9F%E7%90%86/"/>
    <url>/2025/06/11/spring-ioc%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p><strong>Spring的IOC（Inversion of Control，控制反转）</strong> 通过工厂模式加上反射机制来实现，这种设计模式允许开发者定义对象间的依赖关系，并由Spring容器在运行时自动注入这些依赖，而不是在代码中硬编码创建对象的过程。</p><p><code>控制反转(IoC)</code> 就是把创建和管理 bean 的过程转移给了第三方，在Spring中就是 Spring IoC Container。对于 IoC 来说，最重要的就是容器，负责创建、配置和管理 bean，也就是它管理着 bean 的生命，控制着 bean 的依赖注入(DI)。IoC的核心思想是将对象的创建和管理交给容器，而不是由自己new出来，这样做的目的是为了降低耦合，提高代码的灵活性和可维护性。<code>IoC是一种设计思想，而DI是实现这种思想的一种方式</code> ，通过依赖注入，容器负责将所需的依赖自动注入到对象中，而不需要对象自己去找。</p><span id="more"></span><p>Spring IoC容器主要有 <code>BeanFactory和ApplicationContext</code> 两个接口:</p><ul><li>BeanFactory是基础容器，提供基本的依赖注入支持</li><li>ApplicationContext作为高级容器，扩展了更多功能，比如事件发布、国际化支持等。容器启动时，会读取配置文件（如XML）或注解，解析出Bean的定义，存储为BeanDefinition对象，然后通过反射机制实例化这些Bean，并管理它们的生命周期和依赖关系。</li></ul><p>DI依赖注入的方式有多种，比如构造器注入、setter方法注入，或者通过注解如@Autowired自动注入。使用XML配置时，通过标签定义Bean，并指定其依赖。而在注解驱动的方式中，使用@Component等注解标记类，容器会自动扫描并注册这些Bean，然后通过@Autowired注入所需依赖。</p><p><font color=red>总之：Spring IoC的核心在于通过容器管理对象的生命周期和依赖关系，实现控制反转，减少代码的耦合，提高可维护性和扩展性。</font></p><h2 id="IOC容器"><a href="#IOC容器" class="headerlink" title="IOC容器"></a>IOC容器</h2><p>Spring IoC容器核心接口主要有 <code>BeanFactory和 ApplicationContext</code>:</p><ul><li>BeanFactory：Spring 框架的基础设施，面向 Spring 本身，提供基本的依赖注入支持。</li><li>ApplicationContext：面向使用者，几乎所有的应用场合我们都直接使用 ApplicationContext 而非底层的 BeanFactory。</li></ul><h3 id="BeadFactory"><a href="#BeadFactory" class="headerlink" title="BeadFactory"></a>BeadFactory</h3><p>Spring Bean的创建过程是典型的工厂模式。IOC容器为开发者管理对象间的依赖关系提供了很多便利和基础服务，在Spring中有许多的IOC容器的实现供用户选择和使用，BeanFactory作为最顶层的一个接口类，它定义了IOC容器的基本功能规范。<br><img src="/images/spring-ioc%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%8E%9F%E7%90%86_BeanFactory%E7%B1%BB%E5%9B%BE.png"></p><p>BeanFactory 有三个子类：ListableBeanFactory、HierarchicalBeanFactory 和 AutowireCapableBeanFactory，最终的默认实现类是 DefaultListableBeanFactory，实现现了所有接口：</p><ul><li>ListableBeanFactory 接口：表示这些 Bean 是可列表的。</li><li>HierarchicalBeanFactory 接口：表示的是这些 Bean 是有继承关系的，也就是每个Bean 有可能有父 Bean。</li><li>AutowireCapableBeanFactory 接口：定义 Bean 的自动装配规则。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanFactory</span> &#123;<br><br>  <span class="hljs-comment">//对FactoryBean的转义定义，因为如果使用bean的名字检索FactoryBean得到的对象是工厂生成的对象，</span><br>  <span class="hljs-comment">//如果需要得到工厂本身，需要转义</span><br>  <span class="hljs-type">String</span> <span class="hljs-variable">FACTORY_BEAN_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&amp;&quot;</span>;<br><br>  <span class="hljs-comment">//根据bean的名字，获取在IOC容器中得到bean实例</span><br>  Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> BeansException;<br><br>  <span class="hljs-comment">//根据bean的名字和Class类型来得到bean实例，增加了类型安全验证机制。</span><br>  Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String name, Class requiredType)</span> <span class="hljs-keyword">throws</span> BeansException;<br><br>  <span class="hljs-comment">//提供对bean的检索，看看是否在IOC容器有这个名字的bean</span><br>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">containsBean</span><span class="hljs-params">(String name)</span>;<br><br>  <span class="hljs-comment">//根据bean名字得到bean实例，并同时判断这个bean是不是单例</span><br>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">isSingleton</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;<br><br>  <span class="hljs-comment">//得到bean实例的Class类型</span><br>  Class <span class="hljs-title function_">getType</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;<br><br>  <span class="hljs-comment">//得到bean的别名，如果根据别名检索，那么其原名也会被检索出来</span><br>  String[] getAliases(String name);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ApplicationContext</span> <span class="hljs-keyword">extends</span><br>    <span class="hljs-title class_">EnvironmentCapable</span>,<br>    ListableBeanFactory,<br>    HierarchicalBeanFactory,<br>    MessageSource,<br>    ApplicationEventPublisher,<br>    ResourcePatternResolver &#123;<br>  <span class="hljs-meta">@Nullable</span><br>  String <span class="hljs-title function_">getId</span><span class="hljs-params">()</span>;<br><br>  String <span class="hljs-title function_">getApplicationName</span><span class="hljs-params">()</span>;<br><br>  String <span class="hljs-title function_">getDisplayName</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-type">long</span> <span class="hljs-title function_">getStartupDate</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-meta">@Nullable</span><br>  ApplicationContext <span class="hljs-title function_">getParent</span><span class="hljs-params">()</span>;<br><br>  AutowireCapableBeanFactory <span class="hljs-title function_">getAutowireCapableBeanFactory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IllegalStateException;<br>&#125;<br></code></pre></td></tr></table></figure><p>ApplicationContext是Spring提供的一个高级IOC容器，它除了能够提供IOC容器的基本功能外，还为用户提供了以下的附加服务。从ApplicationContext接口的实现，我们看出其特点：</p><ul><li>支持信息源，可以实现国际化。（实现MessageSource接口）</li><li>访问资源。(实现ResourcePatternResolver接口，这个后面要讲)</li><li>支持应用事件。(实现ApplicationEventPublisher接口)</li></ul><p><img src="/images/spring-ioc%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%8E%9F%E7%90%86_ApplicationContex%E7%B1%BB%E5%9B%BE.png"></p><p>ApplicationContext定义的常用的实现类：</p><ul><li>AnnotationConfigApplicationContext</li><li>ClassPathXmlApplicationContext</li><li>FileSystemXmlApplicationContext</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">AnnotationConfigApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AnnotationConfigApplicationContext</span>();<br>context.scan(<span class="hljs-string">&quot;com.ares&quot;</span>);<br>context.register(IdGenApplication.class);<br>context.refresh();<br></code></pre></td></tr></table></figure><h2 id="Bean-生命周期"><a href="#Bean-生命周期" class="headerlink" title="Bean 生命周期"></a>Bean 生命周期</h2><ul><li><p>配置解析: 在 Spring 容器启动时，首先会加载配置信息。这些配置可以是：</p><ul><li>XML 配置文件</li><li>Java 注解（如 @Component, @Service 等）</li><li>Java Config（如使用 @Configuration 和 @Bean 的配置类）</li></ul><p>在这个阶段，Spring 会解析这些配置，提取出关于 Bean 的定义信息，如类名、作用域、依赖关系等。</p></li><li><p>Bean定义注册: 解析完成后，Spring 会将每个 Bean 的定义（BeanDefinition）注册到 BeanDefinitionRegistry 中。这个过程相当于将 Bean 的<code>蓝图</code>保存起来，供后续实例化使用。</p></li><li><p>Bean实例化: 当需要使用某个 Bean 时（比如通过 getBean() 调用，或被其他 Bean 依赖），Spring 会根据 BeanDefinition 实例化该 Bean。</p><ul><li>默认使用 无参构造函数 创建对象。</li><li>支持使用工厂方法、构造函数注入等方式实例化。</li></ul><p><font color=red>此时 Bean 只是一个空壳对象，属性尚未赋值。</font></p></li><li><p>属性注入：Spring 会根据配置自动为 Bean 的属性赋值或注入依赖对象，包括：</p><ul><li>普通类型（String、int 等）</li><li>其他 Bean（通过 @Autowired 或 XML 配置）</li><li>集合、Map 等复杂结构</li></ul></li><li><p>初始化前处理(BeanPostProcessor.postProcessBeforeInitialization): 在正式初始化之前，如果存在实现了 BeanPostProcessor 接口的处理器，Spring 会调用其 postProcessBeforeInitialization() 方法。可用于对 Bean 进行包装、增强（如 AOP 动态代理）<br>。<font color=red>此时 Bean 已经完成属性注入，但还未执行初始化逻辑。</font></p></li><li><p>初始化：这是 Bean 准备就绪的关键阶段，Spring 会按顺序执行以下操作：</p><ul><li>实现 InitializingBean 接口的 afterPropertiesSet() 方法</li><li>执行自定义的 init-method（XML 中配置或注解指定）</li></ul></li><li><p>初始化后处理： 初始化完成后，Spring 再次调用 BeanPostProcessor 的 postProcessAfterInitialization() 方法。</p><ul><li>可以再次修改 Bean 实例</li><li>常用于返回代理对象（AOP 就是基于此机制）</li></ul></li><li><p>销毁：当 Spring 容器关闭时（如调用 close() 或 shutdownHook 触发），Spring 会销毁所有单例 Bean。销毁流程如下：</p><ul><li>实现 DisposableBean 接口的 destroy() 方法</li><li>执行自定义的 destroy-method（XML 中配置或注解指定）</li></ul><p><font color = red >注意：只有单例作用域（Singleton） 的 Bean 才会被 Spring 主动管理生命周期。原型（Prototype）作用域的 Bean 不会被 Spring 管理销毁。</font></p></li></ul><h2 id="Bean实例化与初始化过程"><a href="#Bean实例化与初始化过程" class="headerlink" title="Bean实例化与初始化过程"></a>Bean实例化与初始化过程</h2><p>在Spring Bean 的整个生命周期中可以归纳为三个大的阶段：</p><ul><li>容器启动阶段 - 配置解析与注册。容器的启动阶段就是注册Bean到BeanDefinationRegistry中的一个个BeanDefination了，这就是Spring为Bean实例化所做的预热的工作。</li><li>Bean实例化阶段 - Bean实例化与初始化</li><li>Bean销毁阶段</li></ul><p>Bean的初始化有两种方式：</p><ul><li>懒加载：Spring只有在需要依赖对象的时候才开启相应对象的实例化阶段。</li><li>非懒加载：容器启动阶段完成之后，将立即启动Bean实例化阶段。</li></ul><h3 id="Bean实例化与初始化步骤"><a href="#Bean实例化与初始化步骤" class="headerlink" title="Bean实例化与初始化步骤"></a>Bean实例化与初始化步骤</h3><p>Spring在启动阶段会通过BeanDefinationReader将配置元信息加载到内存生成相应的BeanDefination，然后注册到BeanDefinationRegistry中，BeanDefinationRegistry就是一个存放BeanDefination的容器，是一种<strong>键值对</strong>的形式存在，通过特定的Bean定义的id，映射到相应的BeanDefination。</p><p>BeanDefinitionRegistry有且仅有一个实现，那就是<strong>DefaultListableBeanFactory</strong>。BeanDefinitionRegistry接口有很多子类，比如经常用到的 AnnotationConfigApplicationContext，在实现时最终托管给DefaultListableBeanFactory进行处理的，所以真正实现这个接口的类是DefaultListableBeanFactory。</p><ul><li><p>Bean实例化前操作<br>在完成容器初始化阶段后，Bean都被托管到了DefaultListableBeanFactory，这个类中有个非常重要的字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;BeanPostProcessor&gt; beanPostProcessors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyOnWriteArrayList</span>&lt;&gt;();<br></code></pre></td></tr></table></figure><p>beanPostProcessors 是一个BeanPostProcessor类型的集合。BeanPostProcessor是一个接口，其还有很多子接口，这些接口中提供了很多方法，对Spring Bean生命周期的不同阶段进行扩展，Bean生命周期中的所有扩展点都是依靠这个集合中的BeanPostProcessor来实现的。</p><p>在实现中会轮询 beanPostProcessors 列表，如果类型是<code>InstantiationAwareBeanPostProcessor</code>, 尝试调用<code>InstantiationAwareBeanPostProcessor#postProcessBeforeInstantiation</code>获取bean的实例对象，如果能够获取到，那么将返回值作为当前bean的实例，那么Spring自带的实例化bean的过程就被跳过了。</p></li><li><p>Bean实例化操作<br>这个过程会通过反射来调用bean的构造器来创建bean的实例。具体需要使用哪个构造器，Spring为开发者提供了一个接口，允许开发者自己来判断用哪个构造器。这里会调用<code>SmartInstantiationAwareBeanPostProcessor</code>接口的<code>determineCandidateConstructors</code>方法，这个方法会返回候选的构造器列表，也可以返回空。可以自定义实现SmartInstantiationAwareBeanPostProcessor类，重写<code>determineCandidateConstructors</code>方法，指定构造器列表返回。</p></li><li><p>合并后的BeanDefinition处理<br>这里会调用<code>MergedBeanDefinitionPostProcessor#postProcessMergedBeanDefinition()</code>方法。Spring会轮询BeanPostProcessor，依次调用MergedBeanDefinitionPostProcessor#postProcessMergedBeanDefinition。第一个参数为beanDefinition，表示合并之后的RootBeanDefinition，可以在这个方法内部对合并之后的BeanDefinition进行再次处理。</p></li></ul><p>MergedBeanDefinitionPostProcessor有2个实现类：</p><ul><li><p>AutowiredAnnotationBeanPostProcessor：在 postProcessMergedBeanDefinition 方法中对 @Autowired、@Value 标注的方法、字段进行缓存。</p></li><li><p>CommonAnnotationBeanPostProcessor：在 postProcessMergedBeanDefinition 方法中对 @Resource 标注的字段、@Resource 标注的方法、 @PostConstruct 标注的字段、 @PreDestroy标注的方法进行缓存。</p></li><li><p>实例化后阶段<br>这里会调用InstantiationAwareBeanPostProcessor接口的postProcessAfterInstantiation这个方法，调用逻辑如下：<br>postProcessAfterInstantiation方法返回false的时候，后续的Bean属性赋值前处理、Bean属性赋值都会被跳过了。</p></li><li><p>属性赋值前阶段<br>这个阶段会调用 InstantiationAwareBeanPostProcessor 接口的 postProcessProperties 方法。如果InstantiationAwareBeanPostProcessor中的postProcessProperties和postProcessPropertyValues都返回空的时候，表示这个bean不需要设置属性，直接返回了，直接进入下一个阶段。PropertyValues中保存了bean实例对象中所有属性值的设置，所以可以在这个这个方法中对PropertyValues值进行修改。<br>这个方法有2个比较重要的实现类：</p><ul><li>AutowiredAnnotationBeanPostProcessor 在这个方法中对@Autowired、@Value标注的字段、方法注入值。</li><li>CommonAnnotationBeanPostProcessor 在这个方法中对@Resource标注的字段和方法注入值。</li></ul></li><li><p>Bean属性赋值阶段<br>循环处理PropertyValues中的属性值信息，通过反射调用set方法将属性的值设置到bean实例中。PropertyValues中的值是通过bean xml中property元素配置的，或者调用MutablePropertyValues中add方法设置的值。</p></li><li><p>Aware接口回调<br>如果bean实例实现了BeanNameAware、BeanClassLoaderAware、BeanFactoryAware等的接口，会按照下面的顺序依次进行调用：会依次调用这些接口。</p></li><li><p>Bean初始化前操作<br>这里会调用BeanPostProcessor的postProcessBeforeInitialization方法，若返回null，当前方法将结束。通常称postProcessBeforeInitialization这个方法为：bean初始化前操作。这个接口有2个实现类，比较重要：<strong>ApplicationContextAwareProcessor 和 CommonAnnotationBeanPostProcessor。</strong> 如果bean实现了下面的接口，在  <code>ApplicationContextAwareProcessor#postProcessBeforeInitialization</code>中会依次调用下面接口中的方法，将Aware前缀对应的对象注入到bean实例中:</p><ul><li>EnvironmentAware：注入Environment对象</li><li>EmbeddedValueResolverAware：注入EmbeddedValueResolver对象</li><li>ResourceLoaderAware：注入ResourceLoader对象</li><li>ApplicationEventPublisherAware：注入ApplicationEventPublisher对象</li><li>MessageSourceAware：注入MessageSource对象</li><li>ApplicationContextAware：注入ApplicationContext对象</li><li>CommonAnnotationBeanPostProcessor#postProcessBeforeInitialization中会调用bean中所有标注@PostConstruct注解的方法。</li></ul></li><li><p>Bean初始化处理</p><ul><li>调用InitializingBean接口的afterPropertiesSet方法</li><li>调用定义bean的时候指定的初始化方法。当bean实现了InitializingBean这个接口的时候，会在这个阶段调用afterPropertiesSet方法。<br>调用顺序：InitializingBean中的afterPropertiesSet、然后再调用自定义的初始化方法。</li></ul></li><li><p>Bean初始化后处理<br>这里会调用BeanPostProcessor接口的postProcessAfterInitialization方法，返回null的时候，会中断上面的操作。通常称postProcessAfterInitialization这个方法为：bean初始化后置操作。</p></li></ul><h3 id="Bean-完整生命周期小结"><a href="#Bean-完整生命周期小结" class="headerlink" title="Bean 完整生命周期小结"></a>Bean 完整生命周期小结</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs text">容器启动<br>│<br>├─ 加载配置 → 生成 BeanDefinition → 注册到 BeanDefinitionRegistry<br>│<br>└─ Bean实例化（触发时机：非懒加载或首次请求）<br>   │<br>   ├─ 实例化前处理（自定义对象创建）<br>   ├─ 选择策略（构造方法/工厂方法/Supplier）<br>   ├─ 创建对象（反射/CGLIB）<br>   ├─ 处理循环依赖（三级缓存）<br>   ├─ 合并 BeanDefinition（缓存注入点）<br>   ├─ 属性填充（依赖注入）<br>   ├─ 初始化前处理（Aware 接口、@PostConstruct）<br>   ├─ Bean初始化处理(afterPropertiesSet)<br>   └─ 初始化后处理(postProcessAfterInitialization) <br>│<br>├─ 销毁阶段<br>  │<br>  ├─ 销毁前处理(@PreDestroy、 DisposableBean.destroy)<br>  └─ 销毁<br></code></pre></td></tr></table></figure><h2 id="生命周期扩展点"><a href="#生命周期扩展点" class="headerlink" title="生命周期扩展点"></a>生命周期扩展点</h2><table><thead><tr><th>阶段</th><th>可扩展点</th><th>接口&#x2F;注解</th><th>描述</th></tr></thead><tbody><tr><td>实例化前</td><td><code>postProcessBeforeInstantiation</code></td><td><code>InstantiationAwareBeanPostProcessor</code></td><td>控制是否使用默认实例化流程</td></tr><tr><td>属性注入前</td><td><code>postProcessAfterInstantiation</code></td><td><code>InstantiationAwareBeanPostProcessor</code></td><td>控制是否继续注入属性</td></tr><tr><td>属性注入时</td><td><code>postProcessProperties</code></td><td><code>InstantiationAwareBeanPostProcessor</code></td><td>修改属性值</td></tr><tr><td>初始化前</td><td><code>postProcessBeforeInitialization</code></td><td><code>BeanPostProcessor</code></td><td>初始化前处理（如代理、日志）</td></tr><tr><td>初始化</td><td><code>@PostConstruct</code>, <code>afterPropertiesSet</code>, <code>init-method</code></td><td>多种方式</td><td>自定义初始化逻辑</td></tr><tr><td>初始化后</td><td><code>postProcessAfterInitialization</code></td><td><code>BeanPostProcessor</code></td><td>返回代理对象（如 AOP）</td></tr><tr><td>销毁</td><td><code>@PreDestroy</code>, <code>destroy</code>, <code>destroy-method</code></td><td>多种方式</td><td>清理资源</td></tr></tbody></table><h3 id="核心接口说明"><a href="#核心接口说明" class="headerlink" title="核心接口说明"></a>核心接口说明</h3><ul><li>BeanPostProcessor：是最核心的扩展接口之一，允许在 Bean 初始化前后插入自定义逻辑，常用于 AOP、日志、监控等功能。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanPostProcessor</span> &#123;<br>    <span class="hljs-keyword">default</span> Object <span class="hljs-title function_">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br><br>    <span class="hljs-keyword">default</span> Object <span class="hljs-title function_">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>InstantiationAwareBeanPostProcessor: 继承自 BeanPostProcessor，提供更细粒度的控制。可以在实例化前后、属性注入前后进行干预。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">InstantiationAwareBeanPostProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BeanPostProcessor</span> &#123;<br>    <span class="hljs-keyword">default</span> Object <span class="hljs-title function_">postProcessBeforeInstantiation</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">postProcessAfterInstantiation</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">default</span> PropertyValues <span class="hljs-title function_">postProcessProperties</span><span class="hljs-params">(PropertyValues pvs, Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>BeanFactoryPostProcessor: 不作用于 Bean 实例本身，而是作用于 ConfigurableListableBeanFactory。可以修改 BeanDefinition，比如动态添加、修改 Bean 的定义信息。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanFactoryPostProcessor</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>ApplicationListener &#x2F; ApplicationEventPublisher: Spring 事件机制的核心接口。可监听容器启动、刷新、关闭等关键事件。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 监听上下文刷新事件</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyContextRefreshedListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationListener</span>&lt;ContextRefreshedEvent&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onApplicationEvent</span><span class="hljs-params">(ContextRefreshedEvent event)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;上下文已刷新&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>spring</category>
      
      <category>spring-boot</category>
      
      <category>IOC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
      <tag>spring-boot</tag>
      
      <tag>IOC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring-data-jpa拦截器</title>
    <link href="/2025/06/11/spring-data-jpa%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <url>/2025/06/11/spring-data-jpa%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>在Spring Data JPA中，拦截器机制通常用于在执行某些数据库操作之前或之后进行一些处理。对于实体级别的拦截可以通过使用JPA的生命周期回调方法或者通过AOP来实现，常见的是使用Spring Data提供的Repository监听器或通过自定义的EntityListener来实现类似拦截器的功能。对于Session级别的拦截可以实现</p><span id="more"></span><h2 id="实体生命周期"><a href="#实体生命周期" class="headerlink" title="实体生命周期"></a>实体生命周期</h2><p>JPA（Java Persistence API）中的实体生命周期是指实体从创建到最终被移除的整个过程。在这个过程中，实体会经历不同的状态转换。以下是JPA中实体的四种生命周期状态：</p><ul><li>新建（New）：当使用new关键字创建一个实体对象时，它处于新建状态。此时，该实体对象尚未与持久化上下文（Persistence Context）关联，也没有持久化标识（ID），即数据库中没有对应的记录。</li><li>托管（Managed）：当一个实体通过EntityManager的persist()方法被持久化或从数据库加载后，它进入了托管状态。<br>在这个状态下，实体与持久化上下文建立了关联，并且它的任何更改都会在事务提交时自动同步到数据库中。</li><li>游离（Detached）：当一个托管实体脱离了持久化上下文（例如，事务结束、调用了clear()方法或者关闭了EntityManager），它变成了游离状态。游离状态下的实体虽然有持久化标识（ID），但是不再与持久化上下文关联，因此其变化不会自动同步到数据库。</li><li>删除（Removed）：当调用EntityManager的remove()方法并传入一个托管实体时，该实体进入删除状态。在这种状态下，实体仍然存在于持久化上下文中，但计划在事务提交时从数据库中删除。</li></ul><p><img src="/images/spring-data-jpa%E6%8B%A6%E6%88%AA%E5%99%A8_%E5%AE%9E%E7%8E%B0%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%BD%AC%E7%A7%BB.png"></p><h3 id="生命周期事件"><a href="#生命周期事件" class="headerlink" title="生命周期事件"></a>生命周期事件</h3><p>除了上述四种状态外，JPA还定义了一些生命周期事件，这些事件可以在实体的状态发生变化时触发回调方法。这些事件包括但不限于：</p><ul><li>@PrePersist 和 @PostPersist：在实体被持久化之前和之后触发。</li><li>@PreRemove 和 @PostRemove：在实体被删除之前和之后触发。</li><li>@PreUpdate 和 @PostUpdate：在实体更新操作之前和之后触发。</li><li>@PostLoad：当实体从数据库加载完成后触发。</li></ul><h2 id="实体级别拦截实现"><a href="#实体级别拦截实现" class="headerlink" title="实体级别拦截实现"></a>实体级别拦截实现</h2><ul><li>实体监听器（Entity Listeners）</li><li>监听Spring Data Repository事件</li></ul><h3 id="实体监听器（Entity-Listeners）"><a href="#实体监听器（Entity-Listeners）" class="headerlink" title="实体监听器（Entity Listeners）"></a>实体监听器（Entity Listeners）</h3><p>可以使用实体监听器来拦截实体的生命周期事件, Lifecycle 定义了如下事件操作：</p><ul><li>onSave</li><li>onUpdate</li><li>onDelete</li><li>onLoad</li></ul><p>对应上面的事件，jakarta(以前的javax)实现了操作(注解实现)：</p><ul><li><p>PrePersist, </p></li><li><p>PreRemove, </p></li><li><p>PreUpdate, </p></li><li><p>PostLoad, </p></li><li><p>PostPersist, </p></li><li><p>PostRemove, </p></li><li><p>PostUpdate<br>使用上面的注解我们可以针对具体的实体做一些操作。下面是一个具体的示例：</p></li><li><p>定义一个实体监听器</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserEntityListener</span> &#123;<br><br>    <span class="hljs-meta">@PrePersist</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">prePersist</span><span class="hljs-params">(Object object)</span> &#123;<br>        <span class="hljs-comment">// 在持久化之前调用</span><br>    &#125;<br><br>    <span class="hljs-meta">@PreUpdate</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preUpdate</span><span class="hljs-params">(Object object)</span> &#123;<br>        <span class="hljs-comment">// 在更新之前调用</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>作用在实体上</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Entity</span><br><span class="hljs-meta">@EntityListeners(UserEntityListener.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;<br>    <span class="hljs-comment">// 实体属性和方法</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="监听Spring-Data-Repository事件"><a href="#监听Spring-Data-Repository事件" class="headerlink" title="监听Spring Data Repository事件"></a>监听Spring Data Repository事件</h3><p>Spring Data 提供了一种监听Repository事件（如AfterCreate, BeforeSave等）的机制，可以通过继承AbstractRepositoryEventListener 创建监听器类来监听这些事件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomRepositoryEventListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractRepositoryEventListener</span>&lt;Object&gt; &#123;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onBeforeCreate</span><span class="hljs-params">(Object entity)</span> &#123;<br>    <span class="hljs-comment">// 在创建新实体之前调用</span><br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onBeforeSave</span><span class="hljs-params">(Object entity)</span> &#123;<br>    <span class="hljs-comment">// 在保存实体之前调用</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>AbstractRepositoryEventListener定义的方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onBeforeCreate</span><span class="hljs-params">(T entity)</span> &#123;<br>  &#125;<br><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onAfterCreate</span><span class="hljs-params">(T entity)</span> &#123;<br>  &#125;<br><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onBeforeSave</span><span class="hljs-params">(T entity)</span> &#123;<br>  &#125;<br><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onAfterSave</span><span class="hljs-params">(T entity)</span> &#123;<br>  &#125;<br><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onBeforeLinkSave</span><span class="hljs-params">(T parent, Object linked)</span> &#123;<br>  &#125;<br><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onAfterLinkSave</span><span class="hljs-params">(T parent, Object linked)</span> &#123;<br>  &#125;<br><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onBeforeLinkDelete</span><span class="hljs-params">(T parent, Object linked)</span> &#123;<br>  &#125;<br><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onAfterLinkDelete</span><span class="hljs-params">(T parent, Object linked)</span> &#123;<br>  &#125;<br><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onBeforeDelete</span><span class="hljs-params">(T entity)</span> &#123;<br>  &#125;<br><br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onAfterDelete</span><span class="hljs-params">(T entity)</span> &#123;<br>  &#125;<br></code></pre></td></tr></table></figure><h3 id="EntityListener使用限制"><a href="#EntityListener使用限制" class="headerlink" title="EntityListener使用限制"></a>EntityListener使用限制</h3><p>EntityListener是JPA提供的一种机制，用于在实体生命周期的不同阶段执行特定的逻辑。尽管它是一个强大的工具，但在使用Spring Data JPA时，还是存在一些限制和注意事项：</p><ul><li><strong>依赖注入限制</strong>：默认情况下，JPA的EntityListener不支持Spring的依赖注入（DI）。这是因为实体监听器不是由Spring容器管理的。如果需要在监听器中使用Spring管理的bean，可能需要手动获取应用上下文或使用其他方法来实现依赖注入。</li><li><strong>事务处理</strong>：虽然可以在实体监听器的方法中进行数据库操作，但需要注意的是这些操作不会自动参与到当前实体正在参与的事务中。这意味着你需要特别小心地处理事务边界，以避免数据一致性问题。</li><li><strong>异步执行</strong>：实体监听器中的方法默认是同步执行的。如果希望在监听器中执行的操作（例如发送邮件或者进行复杂的计算）不影响主事务的性能，那么需要自行实现异步调用的机制。</li><li><strong>跨实体监听</strong>：一个实体监听器只能直接应用于声明它的实体。如果想在一个实体上触发另一个实体的操作，则需要通过手动方式或其他设计模式来实现。</li><li><strong>生命周期事件的顺序</strong>：虽然JPA定义了实体生命周期事件的顺序，但是在复杂的场景下，理解并确保正确的执行顺序可能会变得复杂。例如，在嵌套事务或传播行为不同的事务中，监听器的执行顺序可能会导致意外的行为。</li><li><strong>移植性考虑</strong>：由于某些高级特性可能是特定于供应商的，因此使用过于复杂的EntityListener逻辑可能会影响应用程序的可移植性。尽量保持监听器逻辑简单，并遵循JPA规范，以提高代码的可移植性。</li></ul><h2 id="对于Session级别的拦截"><a href="#对于Session级别的拦截" class="headerlink" title="对于Session级别的拦截"></a>对于Session级别的拦截</h2><ul><li>Interceptor(hibernate) </li><li>StatementInspector(hibernate)</li><li>AOP实现</li></ul><h3 id="Interceptor"><a href="#Interceptor" class="headerlink" title="Interceptor"></a>Interceptor</h3><p>Hibernate Interceptor 可以用来在持久化生命周期的各个阶段（如保存、更新、删除等）执行自定义逻辑，可以实现访问到实体对象，并根据需要修改这些对象。Interceptor 接口定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Interceptor</span> &#123;<br>  <span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onLoad</span><span class="hljs-params">(Object entity, Object id, Object[] state, String[] propertyNames, Type[] types)</span><br><span class="hljs-keyword">throws</span> CallbackException &#123;<br><span class="hljs-keyword">if</span> (id==<span class="hljs-literal">null</span> || id <span class="hljs-keyword">instanceof</span> Serializable) &#123;<br><span class="hljs-keyword">return</span> onLoad(entity, (Serializable) id, state, propertyNames, types);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>  <span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onSave</span><span class="hljs-params">(Object entity, Object id, Object[] state, String[] propertyNames, Type[] types)</span><br><span class="hljs-keyword">throws</span> CallbackException &#123;<br><span class="hljs-keyword">if</span> (id==<span class="hljs-literal">null</span> || id <span class="hljs-keyword">instanceof</span> Serializable) &#123;<br><span class="hljs-keyword">return</span> onSave(entity, (Serializable) id, state, propertyNames, types);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br>  <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDelete</span><span class="hljs-params">(Object entity, Object id, Object[] state, String[] propertyNames, Type[] types)</span><br><span class="hljs-keyword">throws</span> CallbackException &#123;<br><span class="hljs-keyword">if</span> (id==<span class="hljs-literal">null</span> || id <span class="hljs-keyword">instanceof</span> Serializable) &#123;<br>onDelete(entity, (Serializable) id, state, propertyNames, types);<br>&#125;<br>&#125;<br><br>  <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preFlush</span><span class="hljs-params">(Iterator&lt;Object&gt; entities)</span> <span class="hljs-keyword">throws</span> CallbackException &#123;&#125;<br><br>  <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">postFlush</span><span class="hljs-params">(Iterator&lt;Object&gt; entities)</span> <span class="hljs-keyword">throws</span> CallbackException &#123;&#125;<br><br>  <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterTransactionBegin</span><span class="hljs-params">(Transaction tx)</span> &#123;&#125;<br><br>  <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeTransactionCompletion</span><span class="hljs-params">(Transaction tx)</span> &#123;&#125;<br><br>  <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterTransactionCompletion</span><span class="hljs-params">(Transaction tx)</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在实际使用中通常通过实现 <code>org.hibernate.EmptyInterceptor</code> 或扩展它，可以覆盖其中的方法来拦截特定事件。可以在 onSave() 方法中添加自定义逻辑，在实体被保存之前进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuditInterceptor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">EmptyInterceptor</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onFlushDirty</span><span class="hljs-params">(Object entity, Serializable id, Object[] currentState, Object[] previousState, String[] propertyNames, Type[] types)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Entity has been updated: &quot;</span> + entity.getClass().getSimpleName());<br>        <span class="hljs-comment">// 可以在这里添加审计日志或其他操作</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.onFlushDirty(entity, id, currentState, previousState, propertyNames, types);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">onSave</span><span class="hljs-params">(Object entity, Serializable id, Object[] state, String[] propertyNames, Type[] types)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Entity is being saved: &quot;</span> + entity.getClass().getSimpleName());<br>        <span class="hljs-comment">// 可以在这里添加审计日志或其他操作</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.onSave(entity, id, state, propertyNames, types);<br>    &#125;<br><br>    <span class="hljs-comment">// 可以根据需要覆盖其他方法，如 onDelete, onLoad 等</span><br>&#125;<br></code></pre></td></tr></table></figure><p>配置：在Spring Boot 应用中通过设置 SessionFactory 来应用拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HibernateConfig</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> SessionFactory <span class="hljs-title function_">sessionFactory</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Configuration</span> <span class="hljs-variable">configuration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>();<br>        configuration.setInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AuditInterceptor</span>());<br>        <span class="hljs-comment">// 添加映射等配置</span><br>        <span class="hljs-keyword">return</span> configuration.buildSessionFactory();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="StatementInspector"><a href="#StatementInspector" class="headerlink" title="StatementInspector"></a>StatementInspector</h3><p>StatementInspector 是一个接口，通过实现StatementInspector可以检查甚至替换生成的 SQL 语句，它主要用于分析或修改 Hibernate 生成的 SQL。通过实现 <code>org.hibernate.resource.jdbc.spi.StatementInspector</code> 接口并将其配置给 SessionFactory来对SQL做一些特殊处理。下面代码实现了SQL的拦截，实现了对select, update, delete等SQL的限制：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SqlStatementInspector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">StatementInspector</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(<span class="hljs-string">&quot;sql&quot;</span>);<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Pattern</span> <span class="hljs-variable">IGNORE_PATTERN</span> <span class="hljs-operator">=</span> Pattern.compile(<br>      <span class="hljs-string">&quot;.*(from|FROM)\\s+(hibernate_sequence|schema_version|flyway_schema_history).*&quot;</span>,<br>      Pattern.CASE_INSENSITIVE);<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">inspect</span><span class="hljs-params">(String sql)</span> &#123;<br>    logger.info(<span class="hljs-string">&quot;sql:&#123;&#125;&quot;</span>, sql);<br>    <span class="hljs-keyword">if</span> (sql == <span class="hljs-literal">null</span> || sql.trim().isEmpty() || IGNORE_PATTERN.matcher(sql).matches()) &#123;<br>      <span class="hljs-keyword">return</span> sql;<br>    &#125;<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">sqlUpperCase</span> <span class="hljs-operator">=</span> sql.toUpperCase().trim();<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// 禁止TRUNCATE、DROP、ALTER、CREATE操作</span><br>      <span class="hljs-keyword">if</span> (sqlUpperCase.startsWith(<span class="hljs-string">&quot;TRUNCATE&quot;</span>) ||<br>          sqlUpperCase.startsWith(<span class="hljs-string">&quot;DROP&quot;</span>) ||<br>          sqlUpperCase.startsWith(<span class="hljs-string">&quot;ALTER&quot;</span>) ||<br>          sqlUpperCase.startsWith(<span class="hljs-string">&quot;CREATE&quot;</span>)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlCheckException</span>(<span class="hljs-string">&quot;禁止执行TRUNCATE、DROP、ALTER、CREATE操作: &quot;</span> + sql);<br>      &#125;<br><br>      <span class="hljs-comment">// UPDATE必须带WHERE条件</span><br>      <span class="hljs-keyword">if</span> (sqlUpperCase.startsWith(<span class="hljs-string">&quot;UPDATE&quot;</span>) &amp;&amp; !sqlUpperCase.contains(<span class="hljs-string">&quot; WHERE &quot;</span>)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlCheckException</span>(<span class="hljs-string">&quot;UPDATE操作必须包含WHERE条件: &quot;</span> + sql);<br>      &#125;<br><br>      <span class="hljs-comment">// DELETE必须带WHERE条件</span><br>      <span class="hljs-keyword">if</span> (sqlUpperCase.startsWith(<span class="hljs-string">&quot;DELETE&quot;</span>) &amp;&amp; !sqlUpperCase.contains(<span class="hljs-string">&quot; WHERE &quot;</span>)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlCheckException</span>(<span class="hljs-string">&quot;DELETE操作必须包含WHERE条件: &quot;</span> + sql);<br>      &#125;<br><br>      <span class="hljs-comment">// SELECT必须带LIMIT</span><br>      <span class="hljs-keyword">if</span> (sqlUpperCase.startsWith(<span class="hljs-string">&quot;SELECT&quot;</span>) &amp;&amp;<br>          !sqlUpperCase.contains(<span class="hljs-string">&quot; LIMIT &quot;</span>) &amp;&amp;<br>          !isCountOrExistsQuery(sqlUpperCase) &amp;&amp;<br>          !isDistinctQuery(sqlUpperCase)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlCheckException</span>(<span class="hljs-string">&quot;SELECT操作必须包含LIMIT条件: &quot;</span> + sql);<br>      &#125;<br><br>      <span class="hljs-comment">// INSERT必须带VALUES</span><br>      <span class="hljs-keyword">if</span> (sqlUpperCase.startsWith(<span class="hljs-string">&quot;INSERT&quot;</span>) &amp;&amp; !sqlUpperCase.contains(<span class="hljs-string">&quot;VALUES&quot;</span>)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SqlCheckException</span>(<span class="hljs-string">&quot;INSERT操作必须包含VALUES: &quot;</span> + sql);<br>      &#125;<br><br>      logger.debug(<span class="hljs-string">&quot;SQL验证通过: &#123;&#125;&quot;</span>, sql);<br>      <span class="hljs-keyword">return</span> sql;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>      logger.error(<span class="hljs-string">&quot;SQL验证失败: &#123;&#125;&quot;</span>, e.getMessage());<br>      <span class="hljs-keyword">throw</span> e;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 判断是否为COUNT查询或EXISTS查询，这类查询可以不需要LIMIT</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCountOrExistsQuery</span><span class="hljs-params">(String sql)</span> &#123;<br>    <span class="hljs-keyword">return</span> sql.contains(<span class="hljs-string">&quot;COUNT(&quot;</span>) || sql.contains(<span class="hljs-string">&quot;EXISTS(&quot;</span>) || sql.contains(<span class="hljs-string">&quot;SELECT 1&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDistinctQuery</span><span class="hljs-params">(String sql)</span> &#123;<br>    <span class="hljs-keyword">return</span> sql.contains(<span class="hljs-string">&quot;DISTINCT&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>yaml配置：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">jpa:</span><br><br>    <span class="hljs-attr">properties:</span><br>      <span class="hljs-attr">hibernate:</span><br>        <span class="hljs-attr">session_factory:</span><br>          <span class="hljs-attr">statement_inspector:</span> <span class="hljs-string">com.ares.domain.component.SqlStatementInspector</span><br><br></code></pre></td></tr></table></figure><p>StatementInspector 适用于需要对生成的 SQL 进行分析或修改的场景，比如性能调优、动态SQL修改等。</p><h3 id="AOP拦截"><a href="#AOP拦截" class="headerlink" title="AOP拦截"></a>AOP拦截</h3><p>使用Spring AOP来创建拦截器逻辑更为灵活，可以针对特定的repository方法进行拦截，实现对数据访问层进行增强处理，比如日志记录、性能监控等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JpaRepoAspect</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(JpaRepoAspect.class);<br><br>  <span class="hljs-comment">// 拦截所有的Repository方法调用</span><br>  <span class="hljs-meta">@Around(&quot;execution(* com.ares.domain.repository.*.*(..))&quot;)</span><br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">logExecutionTime</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>      <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br><br>      <span class="hljs-type">Object</span> <span class="hljs-variable">proceed</span> <span class="hljs-operator">=</span> joinPoint.proceed();<br><br>      <span class="hljs-type">long</span> <span class="hljs-variable">executionTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis() - start;<br><br>      logger.info(joinPoint.getSignature() + <span class="hljs-string">&quot; executed in &quot;</span> + executionTime + <span class="hljs-string">&quot;ms&quot;</span>);<br>      <span class="hljs-keyword">return</span> proceed;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>作用范围：Hibernate Interceptor 和 StatementInspector 主要针对的是 Hibernate 内部的操作，而 AOP 拦截器可以应用于更广泛的应用层面，不仅限于数据库操作。</li><li>灵活性：AOP 提供了更高的灵活性，可以很容易地应用于任何 Spring 管理的 Bean 上；Hibernate Interceptor 更专注于持久化相关的拦截；StatementInspector 则特别针对 SQL 语句的检查和修改。</li><li>使用复杂度：StatementInspector 相对简单，主要集中在 SQL 层面的修改；Hibernate Interceptor 需要理解 Hibernate 的生命周期和事件模型；AOP 拦截器则需要对 Spring AOP 或 AspectJ 有一定的了解。</li></ul>]]></content>
    
    
    <categories>
      
      <category>spring</category>
      
      <category>spring-boot</category>
      
      <category>工具</category>
      
      <category>spring-data</category>
      
      <category>JPA</category>
      
      <category>ORM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
      <tag>spring-boot</tag>
      
      <tag>spring-data</tag>
      
      <tag>JPA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring-data-jpa动态条件查询简化</title>
    <link href="/2025/06/11/spring-data-jpa%E5%8A%A8%E6%80%81%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2%E7%AE%80%E5%8C%96/"/>
    <url>/2025/06/11/spring-data-jpa%E5%8A%A8%E6%80%81%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2%E7%AE%80%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>动态查询是一个非常常见的需求，Spring Data JPA 提供了一套强大的工具集，包括 Specification、CriteriaBuilder 和 Predicate，可以帮助我们构建复杂的动态查询。</p><ul><li>Specification：Specification 是 Spring Data JPA 提供的一个接口，用于构建 JPA Criteria 查询。它通常与 CriteriaBuilder 和 Predicate 一起使用。</li><li>CriteriaBuilder：CriteriaBuilder 是 JPA 提供的一个接口，用于构建查询的各个部分，如条件（Predicate）、排序（Order）等。</li><li>Predicate：Predicate 是 JPA Criteria 查询中的一个条件表达式，用于构建复杂的查询条件。</li></ul><span id="more"></span><p>使用JPA原生的实现构建动态条件比较复杂，因此也有一些开源的框架实现，如：</p><ul><li><a href="http://querydsl.com/static/querydsl/5.0.0/reference/html_single/#preface">Querydsl</a></li><li><a href="https://persistence.blazebit.com/documentation/1.6/core/manual/en_US/index.html">Blaze Persistence - Criteria API for JPA</a></li><li><a href="https://github.com/JSQLParser/JSqlParser/wiki">JSqlParser</a></li></ul><p>使用原生语法构建动态条件查询示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;SaleOrderEntity&gt; <span class="hljs-title function_">getOrderList</span><span class="hljs-params">(SaleOrderRequest request)</span>&#123;<br>  Specification&lt;SaleOrderEntity&gt; specif = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Specification</span>&lt;SaleOrderEntity&gt;() &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> Predicate <span class="hljs-title function_">toPredicate</span><span class="hljs-params">(Root&lt;SaleOrderEntity&gt; root, CriteriaQuery&lt;?&gt; query,</span><br><span class="hljs-params">          CriteriaBuilder criteriaBuilder)</span> &#123;<br>        List&lt;Predicate&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Predicate&gt;();<br>        <span class="hljs-keyword">if</span> (request.getOrderId() != <span class="hljs-literal">null</span>) &#123;<br>          list.add(criteriaBuilder.equal(root.get(<span class="hljs-string">&quot;orderId&quot;</span>).as(String.class), request.getOrderId()));<br>        &#125;<br>        <span class="hljs-keyword">if</span> (request.getUserId() != <span class="hljs-literal">null</span>) &#123;<br>          list.add(criteriaBuilder.equal(root.get(<span class="hljs-string">&quot;userId&quot;</span>).as(String.class), request.getUserId()));<br>        &#125;<br>        <span class="hljs-keyword">return</span> criteriaBuilder.and(list.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Predicate</span>[list.size()]));<br>      &#125;<br>    &#125;;<br>    <span class="hljs-keyword">return</span> saleOrderRepository.findAll(specif);<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的代码可以看到使用Specification会有大量的条件判断与相似代码，因此可以进行简化。</p><h2 id="简化实现"><a href="#简化实现" class="headerlink" title="简化实现"></a>简化实现</h2><h3 id="PredicateBuilder"><a href="#PredicateBuilder" class="headerlink" title="PredicateBuilder&lt;T&gt;"></a><code>PredicateBuilder&lt;T&gt;</code></h3><p>PredicateBuilder类用于构建查询的条件，如：</p><ul><li>equals：创建一个等于条件</li><li>notEquals：创建一个不等于条件</li><li>greaterThan：创建一个大于</li><li>greaterThanOrEquals：创建一个大于等于条件</li><li>lessThan：创建一个小于条件</li><li>lessThanOrEquals：创建一个小于等于条件</li><li>like：创建一个Like条件</li><li>contains：创建一个包含条件（like %value%）</li><li>startsWith：创建一个开始于条件（like value%）</li><li>endsWith：创建一个结束于条件（like %value）</li><li>in：创建一个In条件</li><li>between：创建一个Between条件</li><li>isNull：创建一个IsNull条件</li><li>isNotNull：创建一个IsNotNull条件</li><li>and：创建一个And条件</li><li>or：创建一个Or条件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PredicateBuilder</span>&lt;T&gt; &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Root&lt;T&gt; root;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CriteriaQuery&lt;?&gt; query;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CriteriaBuilder criteriaBuilder;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">PredicateBuilder</span><span class="hljs-params">(Root&lt;T&gt; root, CriteriaQuery&lt;?&gt; query,</span><br><span class="hljs-params">      CriteriaBuilder criteriaBuilder)</span> &#123;<br>    <span class="hljs-built_in">this</span>.root = root;<br>    <span class="hljs-built_in">this</span>.query = query;<br>    <span class="hljs-built_in">this</span>.criteriaBuilder = criteriaBuilder;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 创建一个等于条件</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> attribute 属性名</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> value     值</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> Predicate</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> Predicate <span class="hljs-title function_">equals</span><span class="hljs-params">(String attribute, Object value)</span> &#123;<br>    <span class="hljs-keyword">return</span> criteriaBuilder.equal(root.get(attribute), value);<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 创建一个不等于条件</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> attribute 属性名</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> value     值</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> Predicate</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> Predicate <span class="hljs-title function_">notEquals</span><span class="hljs-params">(String attribute, Object value)</span> &#123;<br>    <span class="hljs-keyword">return</span> criteriaBuilder.notEqual(root.get(attribute), value);<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 创建一个大于条件</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> attribute 属性名</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> value     值</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &lt;Y&gt;       比较值类型</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> Predicate</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> &lt;Y <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;? <span class="hljs-built_in">super</span> Y&gt;&gt; Predicate <span class="hljs-title function_">greaterThan</span><span class="hljs-params">(String attribute, Y value)</span> &#123;<br>    <span class="hljs-keyword">return</span> criteriaBuilder.greaterThan(root.get(attribute), value);<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 创建一个大于等于条件</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> attribute 属性名</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> value     值</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &lt;Y&gt;       比较值类型</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> Predicate</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> &lt;Y <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;? <span class="hljs-built_in">super</span> Y&gt;&gt; Predicate <span class="hljs-title function_">greaterThanOrEquals</span><span class="hljs-params">(String attribute,</span><br><span class="hljs-params">      Y value)</span> &#123;<br>    <span class="hljs-keyword">return</span> criteriaBuilder.greaterThanOrEqualTo(root.get(attribute), value);<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 创建一个小于条件</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> attribute 属性名</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> value     值</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &lt;Y&gt;       比较值类型</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> Predicate</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> &lt;Y <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;? <span class="hljs-built_in">super</span> Y&gt;&gt; Predicate <span class="hljs-title function_">lessThan</span><span class="hljs-params">(String attribute, Y value)</span> &#123;<br>    <span class="hljs-keyword">return</span> criteriaBuilder.lessThan(root.get(attribute), value);<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 创建一个小于等于条件</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> attribute 属性名</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> value     值</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &lt;Y&gt;       比较值类型</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> Predicate</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> &lt;Y <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;? <span class="hljs-built_in">super</span> Y&gt;&gt; Predicate <span class="hljs-title function_">lessThanOrEquals</span><span class="hljs-params">(String attribute, Y value)</span> &#123;<br>    <span class="hljs-keyword">return</span> criteriaBuilder.lessThanOrEqualTo(root.get(attribute), value);<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 创建一个Like条件</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> attribute 属性名</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> value     值</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> Predicate</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> Predicate <span class="hljs-title function_">like</span><span class="hljs-params">(String attribute, String value)</span> &#123;<br>    <span class="hljs-keyword">return</span> criteriaBuilder.like(root.get(attribute), value);<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 创建一个包含条件（like %value%）</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> attribute 属性名</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> value     值</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> Predicate</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> Predicate <span class="hljs-title function_">contains</span><span class="hljs-params">(String attribute, String value)</span> &#123;<br>    <span class="hljs-keyword">return</span> criteriaBuilder.like(root.get(attribute), <span class="hljs-string">&quot;%&quot;</span> + value + <span class="hljs-string">&quot;%&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 创建一个开始于条件（like value%）</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> attribute 属性名</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> value     值</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> Predicate</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> Predicate <span class="hljs-title function_">startsWith</span><span class="hljs-params">(String attribute, String value)</span> &#123;<br>    <span class="hljs-keyword">return</span> criteriaBuilder.like(root.get(attribute), value + <span class="hljs-string">&quot;%&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 创建一个结束于条件（like %value）</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> attribute 属性名</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> value     值</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> Predicate</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> Predicate <span class="hljs-title function_">endsWith</span><span class="hljs-params">(String attribute, String value)</span> &#123;<br>    <span class="hljs-keyword">return</span> criteriaBuilder.like(root.get(attribute), <span class="hljs-string">&quot;%&quot;</span> + value);<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 创建一个In条件</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> attribute 属性名</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> values    值集合</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> Predicate</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> Predicate <span class="hljs-title function_">in</span><span class="hljs-params">(String attribute, Collection&lt;?&gt; values)</span> &#123;<br>    CriteriaBuilder.In&lt;Object&gt; inClause = criteriaBuilder.in(root.get(attribute));<br>    <span class="hljs-keyword">for</span> (Object value : values) &#123;<br>      inClause.value(value);<br>    &#125;<br>    <span class="hljs-keyword">return</span> inClause;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 创建一个Between条件</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> attribute 属性名</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> start     起始值</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> end       结束值</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &lt;Y&gt;       比较值类型</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> Predicate</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> &lt;Y <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;? <span class="hljs-built_in">super</span> Y&gt;&gt; Predicate <span class="hljs-title function_">between</span><span class="hljs-params">(String attribute, Y start, Y end)</span> &#123;<br>    <span class="hljs-keyword">return</span> criteriaBuilder.between(root.get(attribute), start, end);<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 创建一个IsNull条件</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> attribute 属性名</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> Predicate</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> Predicate <span class="hljs-title function_">isNull</span><span class="hljs-params">(String attribute)</span> &#123;<br>    <span class="hljs-keyword">return</span> criteriaBuilder.isNull(root.get(attribute));<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 创建一个IsNotNull条件</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> attribute 属性名</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> Predicate</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> Predicate <span class="hljs-title function_">isNotNull</span><span class="hljs-params">(String attribute)</span> &#123;<br>    <span class="hljs-keyword">return</span> criteriaBuilder.isNotNull(root.get(attribute));<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 创建一个And条件</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> predicates Predicate列表</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> Predicate</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> Predicate <span class="hljs-title function_">and</span><span class="hljs-params">(Predicate... predicates)</span> &#123;<br>    <span class="hljs-keyword">return</span> criteriaBuilder.and(predicates);<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 创建一个Or条件</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> predicates Predicate列表</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> Predicate</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> Predicate <span class="hljs-title function_">or</span><span class="hljs-params">(Predicate... predicates)</span> &#123;<br>    <span class="hljs-keyword">return</span> criteriaBuilder.or(predicates);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="JpaQueryHelper-实现"><a href="#JpaQueryHelper-实现" class="headerlink" title="JpaQueryHelper 实现"></a>JpaQueryHelper 实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JpaQueryHelper</span> &#123;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 创建空的Specification</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &lt;T&gt; 实体类型</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> 空的Specification</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Specification&lt;T&gt; <span class="hljs-title function_">none</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> (root, query, criteria) -&gt; <span class="hljs-literal">null</span>;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 创建一个Specification</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> func predicate构建函数</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &lt;T&gt;  实体类型</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> Specification</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Specification&lt;T&gt; <span class="hljs-title function_">specPredicate</span><span class="hljs-params">(</span><br><span class="hljs-params">      Function&lt;FilterPredicateBuilder&lt;T&gt;, Predicate&gt; func)</span> &#123;<br>    <span class="hljs-keyword">return</span> (root, query, criteria) -&gt; &#123;<br>      FilterPredicateBuilder&lt;T&gt; builder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FilterPredicateBuilder</span>&lt;&gt;(root, query, criteria);<br>      <span class="hljs-keyword">return</span> func.apply(builder);<br>    &#125;;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 创建一个可选的Specification，仅当条件成立时才应用</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> condition 条件</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> spec      当条件成立时应用的Specification</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &lt;T&gt;       实体类型</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> Specification</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; Specification&lt;T&gt; <span class="hljs-title function_">optional</span><span class="hljs-params">(<span class="hljs-type">boolean</span> condition, Specification&lt;T&gt; spec)</span> &#123;<br>    <span class="hljs-keyword">return</span> condition ? spec : none();<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 组合多个Specification，使用AND连接</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> specs Specification列表</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &lt;T&gt;   实体类型</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> 组合后的Specification</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-meta">@SafeVarargs</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Specification&lt;T&gt; <span class="hljs-title function_">and</span><span class="hljs-params">(Specification&lt;T&gt;... specs)</span> &#123;<br>    <span class="hljs-keyword">return</span> (root, query, criteria) -&gt; &#123;<br>      List&lt;Predicate&gt; predicates = Arrays.stream(specs)<br>          .filter(Objects::nonNull)<br>          .map(spec -&gt; spec.toPredicate(root, query, criteria))<br>          .filter(Objects::nonNull)<br>          .toList();<br>      <span class="hljs-keyword">return</span> predicates.isEmpty() ? <span class="hljs-literal">null</span> : criteria.and(predicates.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Predicate</span>[<span class="hljs-number">0</span>]));<br>    &#125;;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 组合多个Specification，使用OR连接¬</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> specs Specification列表</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &lt;T&gt;   实体类型</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> 组合后的Specification</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-meta">@SafeVarargs</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Specification&lt;T&gt; <span class="hljs-title function_">or</span><span class="hljs-params">(Specification&lt;T&gt;... specs)</span> &#123;<br>    <span class="hljs-keyword">return</span> (root, query, criteria) -&gt; &#123;<br>      List&lt;Predicate&gt; predicates = Arrays.stream(specs)<br>          .filter(Objects::nonNull)<br>          .map(spec -&gt; spec.toPredicate(root, query, criteria))<br>          .filter(Objects::nonNull)<br>          .toList();<br>      <span class="hljs-keyword">return</span> predicates.isEmpty() ? <span class="hljs-literal">null</span> : criteria.or(predicates.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Predicate</span>[<span class="hljs-number">0</span>]));<br>    &#125;;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 创建一个等于条件的Specification</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> attribute 属性名</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> value     值</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &lt;T&gt;       实体类型</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> Specification</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Specification&lt;T&gt; <span class="hljs-title function_">equals</span><span class="hljs-params">(String attribute, Object value)</span> &#123;<br>    <span class="hljs-keyword">return</span> optional(value != <span class="hljs-literal">null</span>, specPredicate(builder -&gt; builder.equals(attribute, value)));<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 创建一个不等于条件的Specification</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> attribute 属性名</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> value     值</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &lt;T&gt;       实体类型</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> Specification</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Specification&lt;T&gt; <span class="hljs-title function_">notEquals</span><span class="hljs-params">(String attribute, Object value)</span> &#123;<br>    <span class="hljs-keyword">return</span> optional(value != <span class="hljs-literal">null</span>, specPredicate(builder -&gt; builder.notEquals(attribute, value)));<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 创建一个大于条件的Specification</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> attribute 属性名</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> value     值</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &lt;T&gt;       实体类型</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &lt;Y&gt;       比较值类型</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> Specification</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T, Y <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;? <span class="hljs-built_in">super</span> Y&gt;&gt; Specification&lt;T&gt; <span class="hljs-title function_">greaterThan</span><span class="hljs-params">(String attribute,</span><br><span class="hljs-params">      Y value)</span> &#123;<br>    <span class="hljs-keyword">return</span> optional(value != <span class="hljs-literal">null</span>, specPredicate(builder -&gt; builder.greaterThan(attribute, value)));<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 创建一个大于等于条件的Specification</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> attribute 属性名</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> value     值</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &lt;T&gt;       实体类型</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &lt;Y&gt;       比较值类型</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> Specification</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T, Y <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;? <span class="hljs-built_in">super</span> Y&gt;&gt; Specification&lt;T&gt; <span class="hljs-title function_">greaterThanOrEquals</span><span class="hljs-params">(</span><br><span class="hljs-params">      String attribute, Y value)</span> &#123;<br>    <span class="hljs-keyword">return</span> optional(value != <span class="hljs-literal">null</span>,<br>        specPredicate(builder -&gt; builder.greaterThanOrEquals(attribute, value)));<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 创建一个小于条件的Specification</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> attribute 属性名</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> value     值</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &lt;T&gt;       实体类型</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &lt;Y&gt;       比较值类型</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> Specification</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T, Y <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;? <span class="hljs-built_in">super</span> Y&gt;&gt; Specification&lt;T&gt; <span class="hljs-title function_">lessThan</span><span class="hljs-params">(String attribute,</span><br><span class="hljs-params">      Y value)</span> &#123;<br>    <span class="hljs-keyword">return</span> optional(value != <span class="hljs-literal">null</span>, specPredicate(builder -&gt; builder.lessThan(attribute, value)));<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 创建一个小于等于条件的Specification</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> attribute 属性名</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> value     值</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &lt;T&gt;       实体类型</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &lt;Y&gt;       比较值类型</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> Specification</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T, Y <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;? <span class="hljs-built_in">super</span> Y&gt;&gt; Specification&lt;T&gt; <span class="hljs-title function_">lessThanOrEquals</span><span class="hljs-params">(</span><br><span class="hljs-params">      String attribute, Y value)</span> &#123;<br>    <span class="hljs-keyword">return</span> optional(value != <span class="hljs-literal">null</span>,<br>        specPredicate(builder -&gt; builder.lessThanOrEquals(attribute, value)));<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 创建一个Like条件的Specification</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> attribute 属性名</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> value     值</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &lt;T&gt;       实体类型</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> Specification</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Specification&lt;T&gt; <span class="hljs-title function_">like</span><span class="hljs-params">(String attribute, String value)</span> &#123;<br>    <span class="hljs-keyword">return</span> optional(value != <span class="hljs-literal">null</span> &amp;&amp; !value.isEmpty(),<br>        specPredicate(builder -&gt; builder.like(attribute, value)));<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 创建一个包含条件的Specification（like %value%）</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> attribute 属性名</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> value     值</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &lt;T&gt;       实体类型</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> Specification</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Specification&lt;T&gt; <span class="hljs-title function_">contains</span><span class="hljs-params">(String attribute, String value)</span> &#123;<br>    <span class="hljs-keyword">return</span> optional(value != <span class="hljs-literal">null</span> &amp;&amp; !value.isEmpty(),<br>        specPredicate(builder -&gt; builder.contains(attribute, value)));<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 创建一个开始于条件的Specification（like value%）</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> attribute 属性名</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> value     值</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &lt;T&gt;       实体类型</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> Specification</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Specification&lt;T&gt; <span class="hljs-title function_">startsWith</span><span class="hljs-params">(String attribute, String value)</span> &#123;<br>    <span class="hljs-keyword">return</span> optional(value != <span class="hljs-literal">null</span> &amp;&amp; !value.isEmpty(),<br>        specPredicate(builder -&gt; builder.startsWith(attribute, value)));<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 创建一个结束于条件的Specification（like %value）</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> attribute 属性名</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> value     值</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &lt;T&gt;       实体类型</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> Specification</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Specification&lt;T&gt; <span class="hljs-title function_">endsWith</span><span class="hljs-params">(String attribute, String value)</span> &#123;<br>    <span class="hljs-keyword">return</span> optional(value != <span class="hljs-literal">null</span> &amp;&amp; !value.isEmpty(),<br>        specPredicate(builder -&gt; builder.endsWith(attribute, value)));<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 创建一个In条件的Specification</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> attribute 属性名</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> values    值集合</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &lt;T&gt;       实体类型</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> Specification</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Specification&lt;T&gt; <span class="hljs-title function_">in</span><span class="hljs-params">(String attribute, Collection&lt;?&gt; values)</span> &#123;<br>    <span class="hljs-keyword">return</span> optional(values != <span class="hljs-literal">null</span> &amp;&amp; !values.isEmpty(),<br>        specPredicate(builder -&gt; builder.in(attribute, Objects.requireNonNull(values))));<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 创建一个Between条件的Specification</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> attribute 属性名</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> start     起始值</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> end       结束值</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &lt;T&gt;       实体类型</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &lt;Y&gt;       比较值类型</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> Specification</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T, Y <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;? <span class="hljs-built_in">super</span> Y&gt;&gt; Specification&lt;T&gt; <span class="hljs-title function_">between</span><span class="hljs-params">(String attribute,</span><br><span class="hljs-params">      Y start, Y end)</span> &#123;<br>    <span class="hljs-keyword">if</span> (start != <span class="hljs-literal">null</span> &amp;&amp; end != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> specPredicate(builder -&gt; builder.between(attribute, start, end));<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (start != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> specPredicate(builder -&gt; builder.greaterThanOrEquals(attribute, start));<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (end != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> specPredicate(builder -&gt; builder.lessThanOrEquals(attribute, end));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> none();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 创建一个IsNull条件的Specification</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> attribute 属性名</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &lt;T&gt;       实体类型</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> Specification</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Specification&lt;T&gt; <span class="hljs-title function_">isNull</span><span class="hljs-params">(String attribute)</span> &#123;<br>    <span class="hljs-keyword">return</span> specPredicate(builder -&gt; builder.isNull(attribute));<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 创建一个IsNotNull条件的Specification</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> attribute 属性名</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> &lt;T&gt;       实体类型</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> Specification</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Specification&lt;T&gt; <span class="hljs-title function_">isNotNull</span><span class="hljs-params">(String attribute)</span> &#123;<br>    <span class="hljs-keyword">return</span> specPredicate(builder -&gt; builder.isNotNull(attribute));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;SaleOrderEntity&gt; <span class="hljs-title function_">getOrderList</span><span class="hljs-params">(SaleOrderRequest request)</span>&#123;<br>  Specification&lt;SaleOrderEntity&gt; spec= JpaQueryHelper.and(<br>        JpaQueryHelper.equals(<span class="hljs-string">&quot;orderId&quot;</span>, request.getOrderId()),<br>        JpaQueryHelper.equals(<span class="hljs-string">&quot;userId&quot;</span>, request.getUserId())<br>  );<br>  <span class="hljs-keyword">return</span> saleOrderRepository.findAll(spec);<br>&#125;<br></code></pre></td></tr></table></figure><p>相比于之前的的代码少了很多if条件判断，但这里使用硬编码的写入属性名并不优雅，下面使用进一步简化。</p><h3 id="FieldReference-实现"><a href="#FieldReference-实现" class="headerlink" title="FieldReference 实现"></a>FieldReference 实现</h3><ul><li>SerializableFunction</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">SerializableFunction</span>&lt;T, R&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Function</span>&lt;T, R&gt;, Serializable &#123;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>FieldReferenceFunction</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">FieldReferenceFunction</span>&lt;T, R&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SerializableFunction</span>&lt;T, R&gt; &#123;<br>  String <span class="hljs-title function_">name</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>FieldReference</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FieldReference</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ConcurrentMap&lt;String, String&gt; FIELD_NAME_CACHE = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T, R&gt; FieldReferenceFunction&lt;T, R&gt; <span class="hljs-title function_">of</span><span class="hljs-params">(SerializableFunction&lt;T, R&gt; function)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FieldReferenceFunction</span>&lt;&gt;() &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> R <span class="hljs-title function_">apply</span><span class="hljs-params">(T t)</span> &#123;<br>        <span class="hljs-keyword">return</span> function.apply(t);<br>      &#125;<br><br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">public</span> String <span class="hljs-title function_">name</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> extractFieldName(function);<br>      &#125;<br>    &#125;;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">extractFieldName</span><span class="hljs-params">(SerializableFunction&lt;?, ?&gt; function)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> function.getClass().getName();<br>    <span class="hljs-keyword">return</span> FIELD_NAME_CACHE.computeIfAbsent(key, k -&gt; &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">writeReplace</span> <span class="hljs-operator">=</span> function.getClass().getDeclaredMethod(<span class="hljs-string">&quot;writeReplace&quot;</span>);<br>        writeReplace.setAccessible(<span class="hljs-literal">true</span>);<br>        <span class="hljs-type">SerializedLambda</span> <span class="hljs-variable">lambda</span> <span class="hljs-operator">=</span> (SerializedLambda) writeReplace.invoke(function);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> lambda.getImplMethodName();<br><br>        <span class="hljs-keyword">if</span> (methodName.startsWith(<span class="hljs-string">&quot;get&quot;</span>) &amp;&amp; methodName.length() &gt; <span class="hljs-number">3</span>) &#123;<br>          <span class="hljs-keyword">return</span> Character.toLowerCase(methodName.charAt(<span class="hljs-number">3</span>)) + methodName.substring(<span class="hljs-number">4</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (methodName.startsWith(<span class="hljs-string">&quot;is&quot;</span>) &amp;&amp; methodName.length() &gt; <span class="hljs-number">2</span>) &#123;<br>          <span class="hljs-keyword">return</span> Character.toLowerCase(methodName.charAt(<span class="hljs-number">2</span>)) + methodName.substring(<span class="hljs-number">3</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">return</span> methodName;<br>        &#125;<br><br>      &#125; <span class="hljs-keyword">catch</span> (ReflectiveOperationException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<br>            <span class="hljs-string">&quot;Failed to extract field name from method reference. Make sure you&#x27;re using a method reference (::)&quot;</span>,<br>            e);<br>      &#125;<br>    &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="最终示例"><a href="#最终示例" class="headerlink" title="最终示例"></a>最终示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;SaleOrderEntity&gt; <span class="hljs-title function_">getOrderList</span><span class="hljs-params">(SaleOrderRequest request)</span>&#123;<br>  Specification&lt;SaleOrderEntity&gt; spec = JpaQueryHelper.and(<br>    JpaQueryHelper.equals(FieldReference.of(SaleOrderEntity::getOrderId).name(), request.getOrderId()),<br>    JpaQueryHelper.equals(FieldReference.of(SaleOrderEntity::getUserId).name(), request.getUserId())<br>  );<br>  <span class="hljs-keyword">return</span> saleOrderRepository.findAll(spec);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面的实现方式不仅提高了代码的灵活性和可维护性，还增强了系统的扩展性。Specification、CriteriaBuilder 和 Predicate 是 JPA 提供的强大工具，熟练掌握它们的使用可以极大地提升我们的开发效率。</p>]]></content>
    
    
    <categories>
      
      <category>spring</category>
      
      <category>spring-boot</category>
      
      <category>工具</category>
      
      <category>spring-data</category>
      
      <category>JPA</category>
      
      <category>ORM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
      <tag>spring-boot</tag>
      
      <tag>spring-data</tag>
      
      <tag>JPA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java日志基础</title>
    <link href="/2025/06/11/java-log%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <url>/2025/06/11/java-log%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<p>参考：</p><ol><li><a href="https://www.slf4j.org/manual.html">SLF4J user manual</a></li><li><a href="https://logback.qos.ch/manual/index.html">The logback manual</a></li><li><a href="https://logging.apache.org/log4j/2.12.x/manual/">Log4j2 manual</a></li></ol><hr><p>日志在我们项目生命中非常重要的，不管是开发过程中还是线上问题排查都能够提供有效的信息，进而提高解决问题的效率。java生态中有许多的日志框架实现，主流的实现思想：<strong>日志门面 + 具体实现</strong>，基于此思想能够降低我们切换实现框架的成本。在日常开发中，主流的日志打印实践：<code>SLF4J + LOG4J/LOG4J2 或 SLF4J + LOGBACK</code>。<strong>SLF4J（Simple Logging Facade for Java）</strong> 是Ceki Gülcü开发的一个日志门面接口，它为Java应用程序提供了统一的日志抽象，使开发人员可以使用一致的API进行日志记录，而不需要直接依赖于特定的日志实现。</p><span id="more"></span><p><img src="/images/java-log_slf4j%E6%97%A5%E5%BF%97%E9%97%A8%E9%9D%A2.png"></p><p>日志门面主要是为了给Java日志访问提供一套标准、规范的API框架，其主要意义在于提供接口，具体的实现可以交由具体的日志实现框架。</p><table><thead><tr><th align="left">日志门面</th><th align="left">日志实现</th></tr></thead><tbody><tr><td align="left">JCL(Jakarta Commons Logging)</td><td align="left">JUL(java.util.logging)</td></tr><tr><td align="left">SLF4j(Simple Logging Facade for Java)</td><td align="left">log4j、log4j2、logback</td></tr></tbody></table><p>slf4j所提供的核心API是一些接口以及一个LoggerFactory的工厂类。在使用slf4j的时候，不需要在代码中或配置文件中指定你打算使用那个具体的日志系统，只需要依赖slf4j和日志实现框架以及中间桥接的jar包。在SLF4J定义了如下日志级别：</p><ul><li>TRACE<br>是最低级别的日志记录，用于输出最详细的调试信息，通常用于开发调试目的。在生产环境中，应该关闭 TRACE 级别的日志记录，以避免输出过多无用信息。</li><li>DEBUG<br>是用于输出程序中的一些调试信息，通常用于开发过程中。像 TRACE 一样，在生产环境中应该关闭 DEBUG 级别的日志记录。</li><li>INFO<br>用于输出程序正常运行时的一些关键信息，比如程序的启动、运行日志等。通常在生产环境中开启 INFO 级别的日志记录。</li><li>WARN<br>是用于输出一些警告信息，提示程序可能会出现一些异常或者错误。在应用程序中，WARN 级别的日志记录通常用于记录一些非致命性异常信息，以便能够及时发现并处理这些问题。</li><li>ERROR<br>是用于输出程序运行时的一些错误信息，通常表示程序出现了一些不可预料的错误。在应用程序中，ERROR 级别的日志记录通常用于记录一些致命性的异常信息，以便能够及时发现并处理这些问题。</li></ul><h2 id="logback"><a href="#logback" class="headerlink" title="logback"></a>logback</h2><p>Logback分为三个模块，logback-core、logback-classic 和 logback-access。logback-core模块为其他两个模块奠定了基础，logback-classic模块扩展了core模块，相当于log4j的一个显著改进版本。logback-classic原生实现了slf4j API，可以和其他日志系统随意地来回切换。</p><ul><li>Logger（消息类型和级别来记录消息）</li><li>Appender（输出目的）</li><li>Layout（输出格式）</li></ul><p>Logger 类作为 logback-classic 模块的一部分。Appender 与 Layouts 接口作为 logback-core 的一部分。作为一个通用的模块，logback-core 没有 logger 的概念。</p><h3 id="Logger"><a href="#Logger" class="headerlink" title="Logger"></a>Logger</h3><p>在日志实现中通过定义一个日志空间，这个空间包含所有可能的日志语句，这些日志语句根据具体配置的标准来进行分类。在 logback-classic 中，分类是 logger 的一部分，每一个 logger 都依附在 LoggerContext 上，它负责产生 logger，并且通过一个树状的层级结构来进行管理。Logback 的 logger 层级是继承的，logger 的层级是树状结构，从最顶层的 root logger 开始，然后是它的子 logger，子 logger 的子 logger，以此类推。</p><h3 id="Appender"><a href="#Appender" class="headerlink" title="Appender"></a>Appender</h3><p>logback 允许日志以不同的方式进行输出。logback 输出目的地叫做 appender，appender 包括 console、file、remote socket server、MySQL、PostgreSQL、Oracle 或者其它的数据库、JMS、remote UNIX Syslog daemons 中，一个 logger 可以有多个 appender。</p><p>logger 通过 addAppender 方法来新增一个 appender。对于给定的 logger，每一个允许输出的日志都会被转发到该 logger 的所有 appender 中去，即 appender 从 logger 的层级结构中去继承叠加性。例如：如果 root logger 添加了一个 console appender，所有允许输出的日志至少会在控制台打印出来。定义一个 api 的 logger 添加了一个 file appender，那么 api 以及 api 的子级 logger 都可以在文件和控制台打印日志，可以通过设置 <code>additivity = false</code> 来改写默认的设置，这样 appender 将不再具有叠加性。</p><h3 id="Layout"><a href="#Layout" class="headerlink" title="Layout"></a>Layout</h3><p>layout 的作用是将日志格式化，而 appender 的作用是将格式化后的日志输出到指定的目的地，PatternLayout 能够根据用户指定的格式来格式化日志。如： </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;LOG_FORMAT&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;[%X&#123;traceId&#125;] %d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p><strong>Pattern Layout参数：</strong></p><ul><li><code>c{length}/lo{length}/logger{length}</code>: 输出 logger 的名字作为日志事件的来源。转换字符接收一个作为它的第一个也是为一个参数。</li><li><code>C{length}/class{length}</code>: 输出发出日志请求的类的全限定名称。跟 %logger% 转换符一样，它也可以接收一个整型的可选参数去缩短类名。0 表示特殊含义，在打印类名时将不会输出包的前缀名。默认表示打印类的全限定名。生成调用者类的信息并不是特别快。</li><li><code>contextName/cn</code>: 输出日志事件附加到的 logger 上下文的名字。</li><li><code>d{pattern}/date{pattern}/d{pattern, timezone}/date{pattern, timezone}</code>: 用于输出日志事件的日期。</li><li><code>F / file</code>: 输出日志事件的文件名。</li><li><code>L / line</code>：输出日志事件的行号。生成行号不是特别快。因此，不建议使用，除非生成速度不是问题。</li><li><code>m / msg / message</code>： 输出与日志事件相关联的，由应用程序提供的日志信息。</li><li><code>M / method</code>：输出发出日志请求的方法名。生成方法名不是特别快，因此，应该避免使用，除非生成速度不是问题。</li><li><code>n / nop</code>：输出一个空行。</li><li><code>p / le / level</code>：输出日志事件的优先级。</li><li><code>r / relative</code>：输出自应用启动后，以毫秒为单位的相对时间。</li><li><code>t / thread</code>：输出发出日志事件的线程名。</li><li><code>T / caller</code>：输出发出日志事件的类名、方法名、行号等信息。</li><li><code>u / user</code>：输出发出日志事件的用户名。</li><li><code>x / xx</code>：输出与当前日志事件相关的MDC（Mapped Diagnostic Context）数据。</li><li><code>X / XX</code>：输出与当前日志事件相关的MDC（Mapped Diagnostic Context）数据。</li><li><code>ex / exception / throwable</code>：输出异常信息。输出日志事件相关的堆栈信息，默认情况下会输出全部的堆栈信息。</li><li><code>xex / xException / xThrowable</code>: 跟 %throwable 类似，只不过多了类的包信息。在每个堆栈信息的末尾，多了包含 jar 文件的字符串，后面再加上具体的实现版本。</li></ul><h3 id="logback-配置示例"><a href="#logback-配置示例" class="headerlink" title="logback 配置示例"></a>logback 配置示例</h3><ul><li>maven 依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>logback xml 配置：classPath&#x2F;resource<ul><li>java 项目：logback.xml </li><li>spring-boot项目：logback-spring.xml</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span> <span class="hljs-attr">scan</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">scanPeriod</span>=<span class="hljs-string">&quot;10 seconds&quot;</span>&gt;</span><br><br>  <span class="hljs-comment"><!-- java项目/spring-boot项目：定义项目名称 --></span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;PROJECT_NAME&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;java-project&quot;</span>/&gt;</span><br>  <span class="hljs-comment"><!-- spring-boot项目：定义项目名称 --></span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">springProperty</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;PROJECT_NAME&quot;</span> <span class="hljs-attr">scop</span>=<span class="hljs-string">&quot;context&quot;</span> <span class="hljs-attr">source</span>=<span class="hljs-string">&quot;spring.application.name&quot;</span>/&gt;</span><br><br>  <span class="hljs-comment"><!-- 定义日志文件大小和历史记录 --></span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;LOG_FILE_MAX_SIZE&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;100MB&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;LOG_FILE_MAX_HISTORY&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;30&quot;</span>/&gt;</span><br><br>  <span class="hljs-comment"><!-- 定义日志文件路径 --></span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;LOG_PATH&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/var/logs/java/$&#123;PROJECT_NAME&#125;&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;DEBUG_LOG&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;PROJECT_NAME&#125;-debug&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;API_LOG&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;PROJECT_NAME&#125;-api&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;INFO_LOG&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;PROJECT_NAME&#125;-info&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;ERROR_LOG&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;PROJECT_NAME&#125;-error&quot;</span>/&gt;</span><br><br>  <span class="hljs-comment"><!-- 定义日志格式--></span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;LOG_PATTERN&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; $&#123;PROJECT_NAME&#125; $&#123;hostname&#125; %X&#123;traceId&#125; %thread %-5level %logger&#123;36&#125;:%msg%n&quot;</span>/&gt;</span><br><br>  <span class="hljs-comment"><!-- 控制台输出 --></span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;LOG_PATTERN&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br>  <span class="hljs-comment"><!-- debug日志文件输出 --></span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;DEBUG&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>$&#123;LOG_PATH&#125;/$&#123;DEBUG_LOG&#125;.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;DEBUG&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;LOG_PATTERN&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>$&#123;LOG_PATH&#125;/$&#123;DEBUG_LOG&#125;.%d&#123;yyyy-MM-dd&#125;.%i.log.gz<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">maxFileSize</span>&gt;</span>$&#123;LOG_FILE_MAX_SIZE&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">maxFileSize</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">maxHistory</span>&gt;</span>$&#123;LOG_FILE_MAX_HISTORY&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">maxHistory</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br>  <span class="hljs-comment"><!-- info日志文件输出 --></span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;API&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>$&#123;LOG_PATH&#125;/$&#123;API_LOG&#125;.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;LOG_PATTERN&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>$&#123;LOG_PATH&#125;/$&#123;API_LOG&#125;.%d&#123;yyyy-MM-dd&#125;.%i.log.gz<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">maxFileSize</span>&gt;</span>$&#123;LOG_FILE_MAX_SIZE&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">maxFileSize</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">maxHistory</span>&gt;</span>$&#123;LOG_FILE_MAX_HISTORY&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">maxHistory</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br>  <span class="hljs-comment"><!-- info日志文件输出 --></span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;INFO&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>$&#123;LOG_PATH&#125;/$&#123;INFO_LOG&#125;.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;LOG_PATTERN&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>$&#123;LOG_PATH&#125;/$&#123;INFO_LOG&#125;.%d&#123;yyyy-MM-dd&#125;.%i.log.gz<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">maxFileSize</span>&gt;</span>$&#123;LOG_FILE_MAX_SIZE&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">maxFileSize</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">maxHistory</span>&gt;</span>$&#123;LOG_FILE_MAX_HISTORY&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">maxHistory</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br>  <span class="hljs-comment"><!-- error日志文件输出 --></span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;ERROR&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>$&#123;LOG_PATH&#125;/$&#123;ERROR_LOG&#125;.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;ERROR&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>$&#123;LOG_PATTERN&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>$&#123;LOG_PATH&#125;/$&#123;ERROR_LOG&#125;.%d&#123;yyyy-MM-dd&#125;.%i.log.gz<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">maxFileSize</span>&gt;</span>$&#123;LOG_FILE_MAX_SIZE&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">maxFileSize</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">maxHistory</span>&gt;</span>$&#123;LOG_FILE_MAX_HISTORY&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">maxHistory</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br>  <span class="hljs-comment"><!-- 日志输出级别 --></span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.ares&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span> <span class="hljs-attr">additivity</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;DEBUG&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;INFO&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">logger</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;api&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span> <span class="hljs-attr">additivity</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;API&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">logger</span>&gt;</span><br><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;INFO&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;INFO&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;API&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;ERROR&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;ERROR&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="基于logback日志脱敏示例"><a href="#基于logback日志脱敏示例" class="headerlink" title="基于logback日志脱敏示例"></a>基于logback日志脱敏示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogMaskingConverter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MessageConverter</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">PHONE_PATTERN</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;(\&quot;phone\&quot;\\s*:\\s*\&quot;)(\\d&#123;11&#125;)(\&quot;*)&quot;</span>;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> String <span class="hljs-title function_">convert</span><span class="hljs-params">(ILoggingEvent event)</span> &#123;<br>    <span class="hljs-keyword">if</span> (event == <span class="hljs-literal">null</span> || event.getFormattedMessage() == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> event.getFormattedMessage();<br>    message = message.replaceAll(PHONE_PATTERN, <span class="hljs-string">&quot;$1****$3&quot;</span>);<br>    <span class="hljs-keyword">return</span> message;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>xml配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">conversionRule</span> <span class="hljs-attr">conversionWord</span>=<span class="hljs-string">&quot;mask&quot;</span> <span class="hljs-attr">converterClass</span>=<span class="hljs-string">&quot;com.ares.helper.LogMaskingConverter&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;LOG_PATTERN&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; $&#123;PROJECT_NAME&#125; $&#123;hostname&#125; %X&#123;traceId&#125; %thread %-5level %logger&#123;36&#125;: %mask%n&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>注意： 在 LOG_PATTERN 引入 <code>mask</code></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>log</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>log</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MDC-线程池透传traceId</title>
    <link href="/2025/06/10/java-log-MDC-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%80%8F%E4%BC%A0traceId/"/>
    <url>/2025/06/10/java-log-MDC-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%80%8F%E4%BC%A0traceId/</url>
    
    <content type="html"><![CDATA[<p>Java开发中都是使用日志门面+日志实现的方式打印日志。日志门面主要是为了给Java日志访问提供一套标准、规范的API框架，其主要意义在于提供接口，具体的实现可以交由具体的日志实现框架。使用logback在多线程环境下MDC会丢失父线程的上下文。</p><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogbackMDCAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MDCAdapter</span>  &#123;<br>  <span class="hljs-keyword">final</span> ThreadLocal&lt;Map&lt;String, String&gt;&gt; readWriteThreadLocalMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;Map&lt;String, String&gt;&gt;();<br>  <span class="hljs-keyword">final</span> ThreadLocal&lt;Map&lt;String, String&gt;&gt; readOnlyThreadLocalMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;Map&lt;String, String&gt;&gt;();<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ThreadLocalMapOfStacks</span> <span class="hljs-variable">threadLocalMapOfDeques</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMapOfStacks</span>();<br><br>  ....<br>&#125;<br></code></pre></td></tr></table></figure><p>这在 logback 使用的是 <code>ThreadLocal</code> ，并没有使用 <code>InheritableThreadLocal</code> ，这是因为使用 <code>InheritableThreadLocal</code> 可能导致内存泄漏: <font color=red>ThreadLocal 的工作原理是为每个线程维护一个独立的变量副本，当使用 InheritableThreadLocal时，子线程会继承父线程的 ThreadLocal 变量，如果线程一直不结束，或者线程池中的线程一直被复用，而没有正确清理 ThreadLocal 的值，就会导致内存泄漏。</font></p><h2 id="MDC"><a href="#MDC" class="headerlink" title="MDC"></a>MDC</h2><p><strong>MDC(Mapped Diagnostic Context)</strong>: 诊断上下文映射。用户可以通过将关心的上下文信息写入到MDC中，在日志输出时自动输出，而不需要手动的设置。MDC核心代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MDC</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(String key, String val)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException &#123;<br>      <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;key parameter cannot be null&quot;</span>);<br>      &#125;<br>      <span class="hljs-keyword">if</span> (getMDCAdapter() == <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(MDC_APAPTER_CANNOT_BE_NULL_MESSAGE);<br>      &#125;<br>      getMDCAdapter().put(key, val);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clear</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">if</span> (getMDCAdapter() == <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(MDC_APAPTER_CANNOT_BE_NULL_MESSAGE);<br>      &#125;<br>      getMDCAdapter().clear();<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Map&lt;String, String&gt; <span class="hljs-title function_">getCopyOfContextMap</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-keyword">if</span> (getMDCAdapter() == <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(MDC_APAPTER_CANNOT_BE_NULL_MESSAGE);<br>      &#125;<br>      <span class="hljs-keyword">return</span> getMDCAdapter().getCopyOfContextMap();<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(String key)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException &#123;<br>      <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;key parameter cannot be null&quot;</span>);<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (getMDCAdapter() == <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(MDC_APAPTER_CANNOT_BE_NULL_MESSAGE);<br>      &#125;<br>      getMDCAdapter().remove(key);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setContextMap</span><span class="hljs-params">(Map&lt;String, String&gt; contextMap)</span> &#123;<br>      <span class="hljs-keyword">if</span> (getMDCAdapter() == <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(MDC_APAPTER_CANNOT_BE_NULL_MESSAGE);<br>      &#125;<br>      getMDCAdapter().setContextMap(contextMap);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>slf4j中 MDCAdapter 实现，logback并没有使用slf4j的BasicMDCAdapter而是自己实现了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BasicMDCAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MDCAdapter</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ThreadLocalMapOfStacks</span> <span class="hljs-variable">threadLocalMapOfDeques</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocalMapOfStacks</span>();<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> InheritableThreadLocal&lt;Map&lt;String, String&gt;&gt; inheritableThreadLocalMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InheritableThreadLocal</span>&lt;Map&lt;String, String&gt;&gt;() &#123;<br>      <span class="hljs-meta">@Override</span><br>      <span class="hljs-keyword">protected</span> Map&lt;String, String&gt; <span class="hljs-title function_">childValue</span><span class="hljs-params">(Map&lt;String, String&gt; parentValue)</span> &#123;<br>          <span class="hljs-keyword">if</span> (parentValue == <span class="hljs-literal">null</span>) &#123;<br>              <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>          &#125;<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(parentValue);<br>      &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="多线程中使用MDC"><a href="#多线程中使用MDC" class="headerlink" title="多线程中使用MDC"></a>多线程中使用MDC</h2><h3 id="工具类封装"><a href="#工具类封装" class="headerlink" title="工具类封装"></a>工具类封装</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadWrapper</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Runnable <span class="hljs-title function_">runnable</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Runnable runnable)</span> &#123;<br>    <span class="hljs-keyword">final</span> Map&lt;String, String&gt; context = MDC.getCopyOfContextMap();<br>    <span class="hljs-keyword">return</span> () -&gt; &#123;<br>      Map&lt;String, String&gt; previousMdcContext = MDC.getCopyOfContextMap();<br>      <span class="hljs-keyword">if</span> (context == <span class="hljs-literal">null</span> || context.isEmpty()) &#123;<br>        MDC.clear();<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        MDC.setContextMap(context);<br>      &#125;<br>      <span class="hljs-keyword">try</span> &#123;<br>        runnable.run();<br>      &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (previousMdcContext != <span class="hljs-literal">null</span>) &#123;<br>          <span class="hljs-comment">// 恢复之前的MDC上下文</span><br>          MDC.setContextMap(previousMdcContext);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 清除子线程的MDC，避免内存溢出</span><br>          MDC.clear();<br>        &#125;<br>      &#125;<br>    &#125;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实现ThreadFactory"><a href="#实现ThreadFactory" class="headerlink" title="实现ThreadFactory"></a>实现ThreadFactory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultThreadFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ThreadFactory</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">poolId</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String prefix;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> daemon;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> priority;<br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> ThreadGroup group;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">DefaultThreadFactory</span><span class="hljs-params">(String name)</span> &#123;<br>    <span class="hljs-built_in">this</span>(name, <span class="hljs-literal">false</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">DefaultThreadFactory</span><span class="hljs-params">(String name, <span class="hljs-type">boolean</span> daemon)</span> &#123;<br>    <span class="hljs-built_in">this</span>(name, daemon, Thread.NORM_PRIORITY, <span class="hljs-literal">null</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">DefaultThreadFactory</span><span class="hljs-params">(String name, <span class="hljs-type">boolean</span> daemon, ThreadGroup group)</span> &#123;<br>    <span class="hljs-built_in">this</span>(name, daemon, Thread.NORM_PRIORITY, group);<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">DefaultThreadFactory</span><span class="hljs-params">(String name, <span class="hljs-type">boolean</span> daemon, <span class="hljs-type">int</span> priority, ThreadGroup group)</span> &#123;<br>    <span class="hljs-built_in">this</span>.prefix = name + <span class="hljs-string">&quot;-&quot;</span> + poolId.incrementAndGet() + <span class="hljs-string">&quot;-thread-&quot;</span>;<br>    <span class="hljs-built_in">this</span>.daemon = daemon;<br>    <span class="hljs-built_in">this</span>.priority = priority;<br>    <span class="hljs-built_in">this</span>.group = group;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(<span class="hljs-meta">@Nonnull</span> Runnable runnable)</span> &#123;<br>    <span class="hljs-comment">// 这里特殊处理，ThreadWrapper.runnable()将父线程context传给子线程</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(group, ThreadWrapper.runnable(runnable),<br>        prefix + threadId.incrementAndGet(), <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (thread.isDaemon() != daemon) &#123;<br>      thread.setDaemon(daemon);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (thread.getPriority() != priority) &#123;<br>      thread.setPriority(priority);<br>    &#125;<br>    <span class="hljs-keyword">return</span> thread;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>核心： <code>Thread thread = new Thread(group, ThreadWrapper.runnable(runnable), prefix + threadId.incrementAndGet(), 0)</code></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultExecutorPoolExample</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(DefaultExecutorPoolExample.class);<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br><br>    MDC.put(<span class="hljs-string">&quot;traceId&quot;</span>, String.valueOf(Instant.now().toEpochMilli()));<br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">3</span>, TimeUnit.SECONDS,<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">65535</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultThreadFactory</span>(<span class="hljs-string">&quot;test&quot;</span>));<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>      executorService.submit(() -&gt; &#123;<br>        logger.info(<span class="hljs-string">&quot;sub task, thread name: &#123;&#125;&quot;</span>, Thread.currentThread().getName());<br>      &#125;);<br>    &#125;<br>    executorService.shutdown();<br><br>    <span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">scheduleService</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span>(<span class="hljs-number">1</span>,<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultThreadFactory</span>(<span class="hljs-string">&quot;test&quot;</span>));<br><br>    scheduleService.scheduleAtFixedRate(<br>        () -&gt; log.info(<span class="hljs-string">&quot;sub task scheduleService, Thread Nmae: &#123;&#125;..........................&quot;</span>,<br>            Thread.currentThread().getName()), <span class="hljs-number">0</span>,<br>        <span class="hljs-number">3</span>, TimeUnit.SECONDS);<br>    <br>    MDC.remove(<span class="hljs-string">&quot;traceId&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>并发</category>
      
      <category>log</category>
      
      <category>线程池</category>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>并发</tag>
      
      <tag>线程池</tag>
      
      <tag>log</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RateLimiter算法与使用</title>
    <link href="/2025/06/10/%E6%9E%B6%E6%9E%84-RateLimiter%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/06/10/%E6%9E%B6%E6%9E%84-RateLimiter%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p><font color = blue>服务降级是服务自我保护的一种方式，或者保护下游服务的一种方式，用于确保服务不会受请求突增影响变得不可用，至少确保服务不会奔溃。常见的服务降级实现方式有：<strong>开关降级、限流降级、熔断降级</strong>。</font></p><h2 id="基础限流算法"><a href="#基础限流算法" class="headerlink" title="基础限流算法"></a>基础限流算法</h2><ul><li>令牌桶算法（Token Bucket）</li><li>漏桶算法（Leaky Bucket）</li><li>滑动窗口算法（Sliding Window）</li><li>计数器算法（Fixed Window Counter）</li></ul><span id="more"></span><h3 id="令牌桶算法（Token-Bucket）"><a href="#令牌桶算法（Token-Bucket）" class="headerlink" title="令牌桶算法（Token Bucket）"></a>令牌桶算法（Token Bucket）</h3><p>系统以固定速率向桶中放入令牌，请求需要先获取令牌才能被处理：</p><ul><li>可以应对突发流量</li><li>具有缓冲能力</li><li>实现相对简单</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TokenBucketLimiter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> capacity;           <span class="hljs-comment">// 桶的容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> refillTokensPerSecond;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> availableTokens;        <span class="hljs-comment">// 当前令牌数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> lastRefillTimestamp;      <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TokenBucketLimiter</span><span class="hljs-params">(<span class="hljs-type">long</span> capacity, <span class="hljs-type">double</span> refillTokensPerSecond)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>        <span class="hljs-built_in">this</span>.refillTokensPerSecond = refillTokensPerSecond;<br>        <span class="hljs-built_in">this</span>.availableTokens = capacity;<br>        <span class="hljs-built_in">this</span>.lastRefillTimestamp = System.nanoTime();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">()</span> &#123;<br>        refill();<br>        <span class="hljs-keyword">if</span> (availableTokens &gt;= <span class="hljs-number">1</span>) &#123;<br>            availableTokens -= <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">refill</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> System.nanoTime();<br>        <span class="hljs-type">double</span> <span class="hljs-variable">tokensToAdd</span> <span class="hljs-operator">=</span> (now - lastRefillTimestamp) * refillTokensPerSecond / <span class="hljs-number">1e9</span>;<br>        availableTokens = Math.min(capacity, availableTokens + tokensToAdd);<br>        lastRefillTimestamp = now;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="漏桶算法（Leaky-Bucket）"><a href="#漏桶算法（Leaky-Bucket）" class="headerlink" title="漏桶算法（Leaky Bucket）"></a>漏桶算法（Leaky Bucket）</h3><p>请求先进入到漏桶，漏桶以固定的速率处理请求。</p><ul><li>控制流量的平滑性好</li><li>无法应对突发流量</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LeakyBucketLimiter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> capacity;           <span class="hljs-comment">// 桶的容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> leakRatePerSecond;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> currentVolume;          <span class="hljs-comment">// 当前水量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> lastLeakTimestamp;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LeakyBucketLimiter</span><span class="hljs-params">(<span class="hljs-type">long</span> capacity, <span class="hljs-type">double</span> leakRatePerSecond)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>        <span class="hljs-built_in">this</span>.leakRatePerSecond = leakRatePerSecond;<br>        <span class="hljs-built_in">this</span>.currentVolume = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.lastLeakTimestamp = System.nanoTime();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">()</span> &#123;<br>        leak();<br>        <span class="hljs-keyword">if</span> (currentVolume &lt; capacity) &#123;<br>            currentVolume++;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">leak</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> System.nanoTime();<br>        <span class="hljs-type">double</span> <span class="hljs-variable">timeElapsed</span> <span class="hljs-operator">=</span> (now - lastLeakTimestamp) / <span class="hljs-number">1e9</span>;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">leakedVolume</span> <span class="hljs-operator">=</span> timeElapsed * leakRatePerSecond;<br>        currentVolume = Math.max(<span class="hljs-number">0</span>, currentVolume - leakedVolume);<br>        lastLeakTimestamp = now;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="滑动窗口算法（Sliding-Window）"><a href="#滑动窗口算法（Sliding-Window）" class="headerlink" title="滑动窗口算法（Sliding Window）"></a>滑动窗口算法（Sliding Window）</h3><p>将时间划分为多个小窗口，统计每个窗口内的请求数。</p><ul><li>相比固定窗口更平滑</li><li>能够避免临界问题</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SlidingWindowLimiter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> windowSizeInSeconds;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> maxRequestsPerWindow;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Queue&lt;Long&gt; requestTimestamps;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SlidingWindowLimiter</span><span class="hljs-params">(<span class="hljs-type">int</span> windowSizeInSeconds, <span class="hljs-type">int</span> maxRequestsPerWindow)</span> &#123;<br>        <span class="hljs-built_in">this</span>.windowSizeInSeconds = windowSizeInSeconds;<br>        <span class="hljs-built_in">this</span>.maxRequestsPerWindow = maxRequestsPerWindow;<br>        <span class="hljs-built_in">this</span>.requestTimestamps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">currentTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">windowStart</span> <span class="hljs-operator">=</span> currentTime - (windowSizeInSeconds * <span class="hljs-number">1000</span>);<br>        <br>        <span class="hljs-comment">// 移除窗口外的请求记录</span><br>        <span class="hljs-keyword">while</span> (!requestTimestamps.isEmpty() &amp;&amp; requestTimestamps.peek() &lt;= windowStart) &#123;<br>            requestTimestamps.poll();<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (requestTimestamps.size() &lt; maxRequestsPerWindow) &#123;<br>            requestTimestamps.offer(currentTime);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="计数器算法（Fixed-Window-Counter）"><a href="#计数器算法（Fixed-Window-Counter）" class="headerlink" title="计数器算法（Fixed Window Counter）"></a>计数器算法（Fixed Window Counter）</h3><p>在固定时间窗口内统计请求数量。</p><ul><li>实现最简单</li><li>可能存在临界问题</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FixedWindowLimiter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> maxRequestsPerWindow;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> windowSizeInMillis;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> windowStart;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> currentCount;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FixedWindowLimiter</span><span class="hljs-params">(<span class="hljs-type">int</span> maxRequestsPerWindow, <span class="hljs-type">long</span> windowSizeInMillis)</span> &#123;<br>        <span class="hljs-built_in">this</span>.maxRequestsPerWindow = maxRequestsPerWindow;<br>        <span class="hljs-built_in">this</span>.windowSizeInMillis = windowSizeInMillis;<br>        <span class="hljs-built_in">this</span>.windowStart = System.currentTimeMillis();<br>        <span class="hljs-built_in">this</span>.currentCount = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">currentTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-keyword">if</span> (currentTime - windowStart &gt;= windowSizeInMillis) &#123;<br>            <span class="hljs-comment">// 新窗口开始</span><br>            currentCount = <span class="hljs-number">0</span>;<br>            windowStart = currentTime;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (currentCount &lt; maxRequestsPerWindow) &#123;<br>            currentCount++;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="算法对比"><a href="#算法对比" class="headerlink" title="算法对比"></a>算法对比</h3><table><thead><tr><th>算法</th><th>核心优势</th><th>缺陷</th><th>适用场景</th></tr></thead><tbody><tr><td>计数器</td><td>实现简单</td><td>临界值问题</td><td>低频验证码</td></tr><tr><td>滑动窗口</td><td>精度高</td><td>计算复杂度高</td><td>API接口QPS限制</td></tr><tr><td>令牌桶</td><td>支持突发流量</td><td>需要维护令牌池</td><td>秒杀、直播等高并发</td></tr><tr><td>漏桶</td><td>强制平滑输出</td><td>无法应对突发流量</td><td>API网关流量整形</td></tr></tbody></table><h2 id="SpringBoot集成"><a href="#SpringBoot集成" class="headerlink" title="SpringBoot集成"></a>SpringBoot集成</h2><ul><li>GuavaRateLimiter</li><li>Resilience4j</li><li>RedisRateLimiter</li><li>SlidingWindowRateLimiter</li></ul><h3 id="定义配置项与类型"><a href="#定义配置项与类型" class="headerlink" title="定义配置项与类型"></a>定义配置项与类型</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java">- RateLimiterProperties<br><span class="hljs-meta">@Setter</span><br><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;rate-limiter&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RateLimiterProperties</span> &#123;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 是否启用限流功能</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">enabled</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 默认限流类型: GUAVA, REDIS, RESILIENCE4J, SLIDING_WINDOW</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">defaultType</span> <span class="hljs-operator">=</span> RateLimiterType.GUAVA.name();<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 默认每个时间窗口允许的请求数</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">defaultPermits</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 默认时间窗口大小（秒）</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">defaultTimeWindowSeconds</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 限流触发时的默认响应消息</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">defaultMessage</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;请求过于频繁，请稍后再试&quot;</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 自定义接口限流配置</span><br><span class="hljs-comment">   * Key 是 API 路径或方法名，Value 是限流配置</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">private</span> Map&lt;String, ApiRateLimit&gt; apis = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>  <span class="hljs-meta">@Setter</span><br>  <span class="hljs-meta">@Getter</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ApiRateLimit</span> &#123;<br>    <span class="hljs-keyword">private</span> String type;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> timeWindowSeconds;<br>    <span class="hljs-keyword">private</span> String message;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>RateLimiterType</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">RateLimiterType</span> &#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 基于Guava的RateLimiter</span><br><span class="hljs-comment">   */</span><br>  GUAVA,<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 基于Redis的分布式限流器</span><br><span class="hljs-comment">   */</span><br>  REDIS,<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 基于Resilience4j的限流器</span><br><span class="hljs-comment">   */</span><br>  RESILIENCE4J,<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 自定义滑动窗口限流器</span><br><span class="hljs-comment">   */</span><br>  SLIDING_WINDOW<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="AutoConfiguration"><a href="#AutoConfiguration" class="headerlink" title="AutoConfiguration"></a>AutoConfiguration</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoConfiguration</span><br><span class="hljs-meta">@ConditionalOnClass(CustomerRateLimiter.class)</span><br><span class="hljs-meta">@ConditionalOnProperty(prefix = &quot;rate-limiter&quot;, name = &quot;enabled&quot;, havingValue = &quot;true&quot;,</span><br><span class="hljs-meta">        matchIfMissing = true)</span><br><span class="hljs-meta">@EnableConfigurationProperties(RateLimiterProperties.class)</span><br><span class="hljs-meta">@Import(&#123;RateLimiterRedisConfiguration.class, RateLimiterResilience4jConfiguration.class&#125;)</span><br><span class="hljs-meta">@ComponentScan(&quot;com.ares.factory.ratelimt&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RateLimiterAutoConfiguration</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConditionalOnMissingBean</span><br>    <span class="hljs-keyword">public</span> RateLimiterFactory <span class="hljs-title function_">rateLimiterFactory</span><span class="hljs-params">(RateLimiterProperties properties,</span><br><span class="hljs-params">            StringRedisTemplate redisTemplate)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RateLimiterFactory</span>(properties, redisTemplate);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConditionalOnMissingBean</span><br>    <span class="hljs-keyword">public</span> RateLimitAspect <span class="hljs-title function_">rateLimitAspect</span><span class="hljs-params">(RateLimiterFactory rateLimiterFactory)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RateLimitAspect</span>(rateLimiterFactory);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ConditionalOnClass(RateLimiterRegistry.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RateLimiterResilience4jConfiguration</span> &#123;<br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-meta">@ConditionalOnMissingBean</span><br>  <span class="hljs-keyword">public</span> RateLimiterRegistry <span class="hljs-title function_">rateLimiterRegistry</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> RateLimiterRegistry.ofDefaults();<br>  &#125;<br>&#125;<br><br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ConditionalOnClass(StringRedisTemplate.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RateLimiterRedisConfiguration</span> &#123;<br><br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-meta">@ConditionalOnMissingBean</span><br>  <span class="hljs-meta">@ConditionalOnBean(RedisConnectionFactory.class)</span><br>  <span class="hljs-keyword">public</span> StringRedisTemplate <span class="hljs-title function_">stringRedisTemplate</span><span class="hljs-params">(RedisConnectionFactory connectionFactory)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisTemplate</span>(connectionFactory);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="RateLimiterFactory"><a href="#RateLimiterFactory" class="headerlink" title="RateLimiterFactory"></a>RateLimiterFactory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RateLimiterFactory</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, CustomRateLimiter&gt; rateLimiterCache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RateLimiterProperties properties;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StringRedisTemplate stringRedisTemplate;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">RateLimiterFactory</span><span class="hljs-params">(RateLimiterProperties properties,</span><br><span class="hljs-params">      StringRedisTemplate stringRedisTemplate)</span> &#123;<br>    <span class="hljs-built_in">this</span>.properties = properties;<br>    <span class="hljs-built_in">this</span>.stringRedisTemplate = stringRedisTemplate;<br>  &#125;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 根据限流注解创建相应的限流器</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">public</span> CustomRateLimiter <span class="hljs-title function_">createRateLimiter</span><span class="hljs-params">(RateLimiter rateLimit, String fallbackKey)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> rateLimit.key().isEmpty() ? fallbackKey : rateLimit.key();<br><br>    <span class="hljs-keyword">return</span> rateLimiterCache.computeIfAbsent(key, v -&gt; &#123;<br>      <span class="hljs-type">RateLimiterType</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> rateLimit.type();<br><br>      <span class="hljs-comment">// 如果配置了该key的特定配置，则应用配置</span><br>      <span class="hljs-keyword">if</span> (properties.getApis().containsKey(key)) &#123;<br><br>        RateLimiterProperties.<span class="hljs-type">ApiRateLimit</span> <span class="hljs-variable">apiConfig</span> <span class="hljs-operator">=</span> properties.getApis().get(key);<br><br>        <span class="hljs-keyword">if</span> (apiConfig.getType() != <span class="hljs-literal">null</span>) &#123;<br>          type = RateLimiterType.valueOf(apiConfig.getType());<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">permits</span> <span class="hljs-operator">=</span> apiConfig.getPermits() &gt; <span class="hljs-number">0</span> ? apiConfig.getPermits() : rateLimit.<span class="hljs-keyword">permits</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">timeWindow</span> <span class="hljs-operator">=</span> apiConfig.getTimeWindowSeconds() &gt; <span class="hljs-number">0</span> ? apiConfig.getTimeWindowSeconds()<br>            : (<span class="hljs-type">int</span>) rateLimit.timeUnit().toSeconds(rateLimit.timeWindow());<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span> (type) &#123;<br>          <span class="hljs-keyword">case</span> REDIS -&gt; createRedisRateLimiter(<span class="hljs-keyword">permits</span>, timeWindow);<br>          <span class="hljs-keyword">case</span> RESILIENCE4J -&gt; createResilience4jRateLimiter(<span class="hljs-keyword">permits</span>, timeWindow);<br>          <span class="hljs-keyword">case</span> SLIDING_WINDOW -&gt; createSlidingWindowRateLimiter(<span class="hljs-keyword">permits</span>, timeWindow);<br>          <span class="hljs-keyword">default</span> -&gt; createGuavaRateLimiter(<span class="hljs-keyword">permits</span>, timeWindow);<br>        &#125;;<br>      &#125;<br><br>      <span class="hljs-comment">// 否则使用注解上的配置</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span> (type) &#123;<br>        <span class="hljs-keyword">case</span> REDIS -&gt; createRedisRateLimiter(rateLimit);<br>        <span class="hljs-keyword">case</span> RESILIENCE4J -&gt; createResilience4jRateLimiter(rateLimit);<br>        <span class="hljs-keyword">case</span> SLIDING_WINDOW -&gt; createSlidingWindowRateLimiter(rateLimit);<br>        <span class="hljs-keyword">default</span> -&gt; createGuavaRateLimiter(rateLimit);<br>      &#125;;<br>    &#125;);<br>  &#125;<br><br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 从配置中创建限流器</span><br><span class="hljs-comment">   */</span><br><br>  <span class="hljs-keyword">public</span> CustomRateLimiter <span class="hljs-title function_">createRateLimiterFromProperties</span><span class="hljs-params">(String key)</span> &#123;<br><br>    <span class="hljs-type">RateLimiterType</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> RateLimiterType.valueOf(properties.getDefaultType());<br>    <span class="hljs-type">int</span> <span class="hljs-variable">permits</span> <span class="hljs-operator">=</span> properties.getDefaultPermits();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">timeWindow</span> <span class="hljs-operator">=</span> properties.getDefaultTimeWindowSeconds();<br><br>    <span class="hljs-keyword">if</span> (properties.getApis().containsKey(key)) &#123;<br>      RateLimiterProperties.<span class="hljs-type">ApiRateLimit</span> <span class="hljs-variable">apiConfig</span> <span class="hljs-operator">=</span> properties.getApis().get(key);<br>      <span class="hljs-keyword">if</span> (apiConfig.getType() != <span class="hljs-literal">null</span>) &#123;<br>        type = RateLimiterType.valueOf(apiConfig.getType());<br>      &#125;<br>      <span class="hljs-keyword">if</span> (apiConfig.getPermits() &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">permits</span> = apiConfig.getPermits();<br>      &#125;<br>      <span class="hljs-keyword">if</span> (apiConfig.getTimeWindowSeconds() &gt; <span class="hljs-number">0</span>) &#123;<br>        timeWindow = apiConfig.getTimeWindowSeconds();<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">switch</span> (type) &#123;<br>      <span class="hljs-keyword">case</span> REDIS -&gt; createRedisRateLimiter(<span class="hljs-keyword">permits</span>, timeWindow);<br>      <span class="hljs-keyword">case</span> RESILIENCE4J -&gt; createResilience4jRateLimiter(<span class="hljs-keyword">permits</span>, timeWindow);<br>      <span class="hljs-keyword">case</span> SLIDING_WINDOW -&gt; createSlidingWindowRateLimiter(<span class="hljs-keyword">permits</span>, timeWindow);<br>      <span class="hljs-keyword">default</span> -&gt; createGuavaRateLimiter(<span class="hljs-keyword">permits</span>, timeWindow);<br>    &#125;;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> CustomRateLimiter <span class="hljs-title function_">createGuavaRateLimiter</span><span class="hljs-params">(RateLimiter rateLimiter)</span> &#123;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">permitsPerSecond</span> <span class="hljs-operator">=</span> calculatePermitsPerSecond(rateLimiter);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GuavaRateLimiter</span>(permitsPerSecond);<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> CustomRateLimiter <span class="hljs-title function_">createGuavaRateLimiter</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>, <span class="hljs-type">int</span> timeWindowSeconds)</span> &#123;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">permitsPerSecond</span> <span class="hljs-operator">=</span> (<span class="hljs-type">double</span>) <span class="hljs-keyword">permits</span> / timeWindowSeconds;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GuavaRateLimiter</span>(permitsPerSecond);<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> CustomRateLimiter <span class="hljs-title function_">createRedisRateLimiter</span><span class="hljs-params">(RateLimiter rateLimit)</span> &#123;<br>    <span class="hljs-keyword">if</span> (stringRedisTemplate == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Redis template is not available for Redis rate limiter&quot;</span>);<br>    &#125;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">windowSeconds</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) rateLimit.timeUnit().toSeconds(rateLimit.timeWindow());<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisRateLimiter</span>(stringRedisTemplate, rateLimit.<span class="hljs-keyword">permits</span>(), windowSeconds);<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> CustomRateLimiter <span class="hljs-title function_">createRedisRateLimiter</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>, <span class="hljs-type">int</span> timeWindowSeconds)</span> &#123;<br>    <span class="hljs-keyword">if</span> (stringRedisTemplate == <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Redis template is not available for Redis rate limiter&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisRateLimiter</span>(stringRedisTemplate, <span class="hljs-keyword">permits</span>, timeWindowSeconds);<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> CustomRateLimiter <span class="hljs-title function_">createResilience4jRateLimiter</span><span class="hljs-params">(RateLimiter rateLimit)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Resilience4jRateLimiter</span>(<br>        rateLimit.<span class="hljs-keyword">permits</span>(),<br>        rateLimit.timeWindow(),<br>        rateLimit.timeUnit());<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> CustomRateLimiter <span class="hljs-title function_">createResilience4jRateLimiter</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>, <span class="hljs-type">int</span> timeWindowSeconds)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Resilience4jRateLimiter</span>(<br>        <span class="hljs-keyword">permits</span>,<br>        timeWindowSeconds,<br>        TimeUnit.SECONDS);<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> CustomRateLimiter <span class="hljs-title function_">createSlidingWindowRateLimiter</span><span class="hljs-params">(RateLimiter rateLimit)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SlidingWindowRateLimiter</span>(<br>        rateLimit.<span class="hljs-keyword">permits</span>(),<br>        rateLimit.timeWindow(),<br>        rateLimit.timeUnit());<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> CustomRateLimiter <span class="hljs-title function_">createSlidingWindowRateLimiter</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>, <span class="hljs-type">int</span> timeWindowSeconds)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SlidingWindowRateLimiter</span>(<br>        <span class="hljs-keyword">permits</span>,<br>        timeWindowSeconds,<br>        TimeUnit.SECONDS);<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">double</span> <span class="hljs-title function_">calculatePermitsPerSecond</span><span class="hljs-params">(RateLimiter rateLimit)</span> &#123;<br>    <span class="hljs-comment">// 将配置的时间窗口和许可数转换为每秒许可数</span><br>    <span class="hljs-type">double</span> <span class="hljs-variable">timeWindowInSeconds</span> <span class="hljs-operator">=</span> rateLimit.timeUnit().toSeconds(rateLimit.timeWindow());<br>    <span class="hljs-keyword">if</span> (timeWindowInSeconds == <span class="hljs-number">0</span>) &#123;<br>      timeWindowInSeconds = <span class="hljs-number">1</span>; <span class="hljs-comment">// 防止除零</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">double</span>) rateLimit.<span class="hljs-keyword">permits</span>() / timeWindowInSeconds;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="CustomRateLimiter-接口与实现"><a href="#CustomRateLimiter-接口与实现" class="headerlink" title="CustomRateLimiter 接口与实现"></a>CustomRateLimiter 接口与实现</h3><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">CustomRateLimiter</span> &#123;<br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 尝试获取许可</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> key 限流标识</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@return</span> 是否获取成功</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(String key)</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 释放许可（如需要）</span><br><span class="hljs-comment">   *</span><br><span class="hljs-comment">   * <span class="hljs-doctag">@param</span> key 限流标识</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">(String key)</span> &#123;<br>    <span class="hljs-comment">// 默认空实现</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><ul><li>SlidingWindowRateLimiter实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SlidingWindowRateLimiter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CustomRateLimiter</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Queue&lt;Long&gt;&gt; windowMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> maxPermits;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> windowMillis;<br><br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">SlidingWindowRateLimiter</span><span class="hljs-params">(<span class="hljs-type">int</span> maxPermits, <span class="hljs-type">int</span> timeWindow, TimeUnit timeUnit)</span> &#123;<br>    <span class="hljs-built_in">this</span>.maxPermits = maxPermits;<br>    <span class="hljs-built_in">this</span>.windowMillis = timeUnit.toMillis(timeWindow);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(String key)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">currentTime</span> <span class="hljs-operator">=</span> Instant.now().toEpochMilli();<br>    Queue&lt;Long&gt; window = windowMap.computeIfAbsent(key, k -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentLinkedQueue</span>&lt;&gt;());<br>    <span class="hljs-comment">// 清理过期的时间戳</span><br>    <span class="hljs-keyword">while</span> (!window.isEmpty() &amp;&amp; currentTime - window.peek() &gt; windowMillis) &#123;<br>      window.poll();<br>    &#125; <span class="hljs-comment">// 判断是否超过限制</span><br>    <span class="hljs-keyword">if</span> (window.size() &lt; maxPermits) &#123;<br>      window.offer(currentTime);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>Resilience4jRateLimiter</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Resilience4jRateLimiter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CustomRateLimiter</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, RateLimiter&gt; limiters = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> limitForPeriod;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> timeWindow;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TimeUnit timeUnit;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">Resilience4jRateLimiter</span><span class="hljs-params">(<span class="hljs-type">int</span> limitForPeriod, <span class="hljs-type">int</span> timeWindow, TimeUnit timeUnit)</span> &#123;<br>    <span class="hljs-built_in">this</span>.timeUnit = timeUnit;<br>    <span class="hljs-built_in">this</span>.timeWindow = timeWindow;<br>    <span class="hljs-built_in">this</span>.limitForPeriod = limitForPeriod;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(String key)</span> &#123;<br>    <span class="hljs-type">RateLimiter</span> <span class="hljs-variable">rateLimiter</span> <span class="hljs-operator">=</span> limiters.computeIfAbsent(key, v -&gt; &#123;<br>      <span class="hljs-type">RateLimiterConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> RateLimiterConfig.custom()<br>          .limitForPeriod(limitForPeriod)<br>          .limitRefreshPeriod(Duration.ofMillis(timeUnit.toMillis(timeWindow)))<br>          .timeoutDuration(Duration.ofMillis(<span class="hljs-number">0</span>)) <span class="hljs-comment">// 非阻塞</span><br>          .build();<br>      <span class="hljs-keyword">return</span> RateLimiterRegistry.of(config).rateLimiter(key);<br>    &#125;);<br>    <span class="hljs-keyword">return</span> rateLimiter.acquirePermission();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>RedisRateLimiter</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisRateLimiter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CustomRateLimiter</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StringRedisTemplate stringRedisTemplate;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> maxPermits;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> windowSeconds;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">REDIS_SCRIPT</span> <span class="hljs-operator">=</span><br>      <span class="hljs-string">&quot;local key = KEYS[1] &quot;</span> +<br>          <span class="hljs-string">&quot;local currentCount = redis.call(&#x27;incr&#x27;, key) &quot;</span> +<br>          <span class="hljs-string">&quot;if tonumber(currentCount) == 1 then &quot;</span> +<br>          <span class="hljs-string">&quot;    redis.call(&#x27;expire&#x27;, key, ARGV[1]) &quot;</span> +<br>          <span class="hljs-string">&quot;end &quot;</span> +<br>          <span class="hljs-string">&quot;return currentCount &lt;= tonumber(ARGV[2])&quot;</span>;<br><br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">RedisRateLimiter</span><span class="hljs-params">(StringRedisTemplate stringRedisTemplate, <span class="hljs-type">int</span> maxPermits,</span><br><span class="hljs-params">      <span class="hljs-type">int</span> windowSeconds)</span> &#123;<br>    <span class="hljs-built_in">this</span>.maxPermits = maxPermits;<br>    <span class="hljs-built_in">this</span>.windowSeconds = windowSeconds;<br>    <span class="hljs-built_in">this</span>.stringRedisTemplate = stringRedisTemplate;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(String key)</span> &#123;<br>    DefaultRedisScript&lt;Boolean&gt; script = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;(REDIS_SCRIPT, Boolean.class);<br><br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span><br>        stringRedisTemplate.execute(script, Collections.singletonList(<span class="hljs-string">&quot;rate:limit:&quot;</span> + key),<br>            String.valueOf(windowSeconds), String.valueOf(maxPermits));<br>    <span class="hljs-keyword">return</span> result != <span class="hljs-literal">null</span> &amp;&amp; result;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>GuavaRateLimiter</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GuavaRateLimiter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CustomRateLimiter</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, RateLimiter&gt; limiters = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> permitsPerSecond;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">GuavaRateLimiter</span><span class="hljs-params">(<span class="hljs-type">double</span> permitsPerSecond)</span> &#123;<br>    <span class="hljs-built_in">this</span>.permitsPerSecond = permitsPerSecond;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(String key)</span> &#123;<br>    <span class="hljs-type">RateLimiter</span> <span class="hljs-variable">rateLimiter</span> <span class="hljs-operator">=</span><br>        limiters.computeIfAbsent(key, k -&gt; RateLimiter.create(permitsPerSecond));<br>    <span class="hljs-keyword">return</span> rateLimiter.tryAcquire();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="RateLimiter注解实现"><a href="#RateLimiter注解实现" class="headerlink" title="RateLimiter注解实现"></a>RateLimiter注解实现</h3><ul><li>@RateLimiter</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.METHOD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> RateLimiter &#123;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 限流唯一标识，默认为方法全限定名</span><br><span class="hljs-comment">   */</span><br>  String <span class="hljs-title function_">key</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 限流策略，支持不同类型的限流器</span><br><span class="hljs-comment">   */</span><br>  RateLimiterType <span class="hljs-title function_">type</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> RateLimiterType.GUAVA;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 限流时间窗口</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-type">int</span> <span class="hljs-title function_">timeWindow</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">1</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 时间单位</span><br><span class="hljs-comment">   */</span><br>  TimeUnit <span class="hljs-title function_">timeUnit</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> TimeUnit.SECONDS;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 在时间窗口内允许通过的请求数</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-type">int</span> <span class="hljs-title function_">permits</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">50</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 获取令牌最大等待时间，0表示非阻塞</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-type">long</span> <span class="hljs-title function_">timeout</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-number">0</span>;<br><br>  <span class="hljs-comment">/**</span><br><span class="hljs-comment">   * 触发限流时的提示消息</span><br><span class="hljs-comment">   */</span><br>  String <span class="hljs-title function_">message</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;请求过于频繁，请稍后再试&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>RateLimiterAspect</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RateLimiterAspect</span> &#123;<br><br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RateLimiterProperties properties;<br><br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RateLimiterFactory rateLimiterFactory;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">RateLimiterAspect</span><span class="hljs-params">(RateLimiterProperties properties,</span><br><span class="hljs-params">      RateLimiterFactory rateLimiterFactory)</span> &#123;<br>    <span class="hljs-built_in">this</span>.properties = properties;<br>    <span class="hljs-built_in">this</span>.rateLimiterFactory = rateLimiterFactory;<br>  &#125;<br><br>  <span class="hljs-meta">@Around(&quot;@annotation(com.ares.ratelimiter.annotation.RateLimiter)&quot;)</span><br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">rateLimit</span><span class="hljs-params">(ProceedingJoinPoint point)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br><br>    <span class="hljs-keyword">if</span> (!properties.isEnabled()) &#123;<br>      <span class="hljs-keyword">return</span> point.proceed();<br>    &#125;<br><br>    <span class="hljs-type">MethodSignature</span> <span class="hljs-variable">signature</span> <span class="hljs-operator">=</span> (MethodSignature) point.getSignature();<br>    <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> signature.getMethod();<br><br>    <span class="hljs-type">RateLimiter</span> <span class="hljs-variable">rateLimit</span> <span class="hljs-operator">=</span> method.getAnnotation(RateLimiter.class);<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> method.getDeclaringClass().getName() + <span class="hljs-string">&quot;.&quot;</span> + method.getName();<br>    <span class="hljs-type">CustomRateLimiter</span> <span class="hljs-variable">limiter</span> <span class="hljs-operator">=</span> rateLimiterFactory.createRateLimiter(rateLimit, methodName);<br><br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">if</span> (limiter.tryAcquire(methodName)) &#123;<br>        <span class="hljs-keyword">return</span> point.proceed();<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 获取自定义消息或使用默认消息</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> rateLimit.message();<br>        <span class="hljs-keyword">if</span> (message.isEmpty()) &#123;<br>          message = properties.getDefaultMessage();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (properties.getApis().containsKey(methodName)<br>            &amp;&amp; properties.getApis().get(methodName).getMessage() != <span class="hljs-literal">null</span>) &#123;<br>          message = properties.getApis().get(methodName).getMessage();<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResponseStatusException</span>(HttpStatus.TOO_MANY_REQUESTS, message);<br>      &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      limiter.release(methodName); <span class="hljs-comment">// 如果有需要释放的资源</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="待优化扩展方向"><a href="#待优化扩展方向" class="headerlink" title="待优化扩展方向"></a>待优化扩展方向</h3><ul><li>动态配置</li><li>支持多级限流</li><li>支持降级处理</li><li>支持用户级别或IP级别限流</li><li>限流指标监控</li></ul>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
      <category>工具</category>
      
      <category>高可用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
      <tag>高可用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java反射与动态代理</title>
    <link href="/2025/06/10/java-%E5%8F%8D%E5%B0%84%E4%B8%8E%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <url>/2025/06/10/java-%E5%8F%8D%E5%B0%84%E4%B8%8E%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>Java中的反射（Reflection）和动态代理（Dynamic Proxy）是两个强大的特性，它们在处理对象、类和方法时提供了高度的灵活性。</p><ul><li>反射主要用于需要在运行时检查或反射关于类、接口、字段和方法信息的场景；</li><li>动态代理则更适用于需要在不修改原始代码的情况下增加额外处理逻辑的情况，如拦截方法调用以添加日志记录或安全控制等。</li></ul><span id="more"></span><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>反射允许运行中的Java程序获取类信息，并操作对象。它提供了以下主要功能：</p><ul><li><strong>获取类的信息</strong>：可以通过 <code>Class</code> 对象获取类的构造器、字段（成员变量）、方法等信息。</li><li><strong>创建实例</strong>：通过反射可以在运行时创建类的实例，即使这个类的名字是在编译期未知的。</li><li><strong>调用方法和访问字段</strong>：可以调用一个对象的方法或访问其字段（包括私有字段），而不需要在代码中直接引用这些方法或字段。</li><li><strong>修改类的行为</strong>：例如，可以在运行时改变某个字段的值或者调用通常不可访问的私有方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectionExample</span> &#123;  <br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;  <br>  <br>    <span class="hljs-comment">// 方式一：通过全类名Class.forName()  </span><br>    Class&lt;?&gt; clazz = Class.forName(<span class="hljs-string">&quot;com.ares.basic.proxy.Person&quot;</span>);  <br>    <span class="hljs-comment">// 方式二：通过对象.getClass()  </span><br>    <span class="hljs-comment">//Person persons = new Person();    </span><br>    <span class="hljs-comment">//Class&lt;? extends Person&gt; clazz1 = persons.getClass();    </span><br>    <span class="hljs-comment">// 方式三：通过类名.class  </span><br>    <span class="hljs-comment">//Class&lt;?&gt; clazz2 = Person.class;  </span><br>    <span class="hljs-comment">// 调用无参构造（需保证类有无参构造）  </span><br>    <span class="hljs-comment">//Person persons1 = (Person) clazz.newInstance();  </span><br>  <br>    <span class="hljs-comment">// 通过有参构造方法创建对象实例  </span><br>    Constructor&lt;?&gt; constructor = clazz.getConstructor(String.class, <span class="hljs-type">int</span>.class);  <br>    <span class="hljs-type">Person</span> <span class="hljs-variable">person</span> <span class="hljs-operator">=</span> (Person) constructor.newInstance(<span class="hljs-string">&quot;ares&quot;</span>, <span class="hljs-number">20</span>);  <br>  <br>    <span class="hljs-comment">// 调用getName方法  </span><br>    <span class="hljs-type">Method</span> <span class="hljs-variable">getNameMethod</span> <span class="hljs-operator">=</span> clazz.getMethod(<span class="hljs-string">&quot;getName&quot;</span>);  <br>    <span class="hljs-type">Object</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> getNameMethod.invoke(person);  <br>    System.out.println(<span class="hljs-string">&quot;Name: &quot;</span> + name);  <br>  <br>    <span class="hljs-comment">// 修改私有字段age  </span><br>    <span class="hljs-type">Field</span> <span class="hljs-variable">ageField</span> <span class="hljs-operator">=</span> clazz.getDeclaredField(<span class="hljs-string">&quot;age&quot;</span>);  <br>    <span class="hljs-comment">// 允许访问私有字段  </span><br>    ageField.setAccessible(<span class="hljs-literal">true</span>); <br>    ageField.set(person, <span class="hljs-number">31</span>);  <br>  <br>    <span class="hljs-comment">// 再次调用getAge方法  </span><br>    <span class="hljs-type">Method</span> <span class="hljs-variable">getAgeMethod</span> <span class="hljs-operator">=</span> clazz.getMethod(<span class="hljs-string">&quot;getAge&quot;</span>);  <br>    <span class="hljs-type">Object</span> <span class="hljs-variable">age</span> <span class="hljs-operator">=</span> getAgeMethod.invoke(person);  <br>    System.out.println(<span class="hljs-string">&quot;Updated Age: &quot;</span> + age);  <br>  <br>    <span class="hljs-comment">// 打印整个对象  </span><br>    System.out.println(<span class="hljs-string">&quot;person= &quot;</span> + person);  <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式是常用的设计模式，他的特征是代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。代理类与委托类之间通常会存在关联关系，一个代理类的对象与一个委托类的对象关联，代理类的对象本身并不真正实现服务，而是通过调用委托类的对象的相关方法，来提供特定的服务。简单的说就是，我们在访问实际对象时，是通过代理对象来访问的，代理模式就是在访问实际对象时引入一定程度的间接性。<br><img src="/images/java%E5%8F%8D%E5%B0%84%E4%B8%8E%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86_%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.png"></p><h3 id="代理模式示例"><a href="#代理模式示例" class="headerlink" title="代理模式示例"></a>代理模式示例</h3><p>Log接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Log</span> &#123;<br>  <span class="hljs-keyword">void</span> <span class="hljs-title function_">info</span><span class="hljs-params">(String msg)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>ConsoleLog具体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsoleLog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Log</span> &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">info</span><span class="hljs-params">(String msg)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;console log: &quot;</span> + msg);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>FileLog具体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FileLog</span> <span class="hljs-keyword">implements</span>  <span class="hljs-title class_">Log</span> &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">info</span><span class="hljs-params">(String msg)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;file log:&quot;</span> + msg);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>LogProxy代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LogProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Log</span> &#123;<br><br>  Log log;<br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">LogProxy</span><span class="hljs-params">(Log log)</span> &#123;<br>    <span class="hljs-keyword">if</span> (log <span class="hljs-keyword">instanceof</span> ConsoleLog) &#123;<br>      <span class="hljs-built_in">this</span>.log = (ConsoleLog) log;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (log <span class="hljs-keyword">instanceof</span> FileLog) &#123;<br>      <span class="hljs-built_in">this</span>.log = (FileLog) log;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">info</span><span class="hljs-params">(String msg)</span> &#123;<br>    log.info(msg);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StaticProxyExample</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Log</span> <span class="hljs-variable">consoleLog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConsoleLog</span>();<br>    <span class="hljs-type">LogProxy</span> <span class="hljs-variable">logProxy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LogProxy</span>(consoleLog);<br>    logProxy.info(<span class="hljs-string">&quot;console log by proxy&quot;</span>);<br><br>    <span class="hljs-type">Log</span> <span class="hljs-variable">fileLog</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileLog</span>();<br>    <span class="hljs-type">LogProxy</span> <span class="hljs-variable">fileLogProxy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LogProxy</span>(fileLog);<br>    fileLogProxy.info(<span class="hljs-string">&quot;file log by proxy&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>代理类在程序运行时创建的代理方式被成为动态代理。相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。 </p><h3 id="jdk动态代理"><a href="#jdk动态代理" class="headerlink" title="jdk动态代理"></a>jdk动态代理</h3><p>利用反射机制生成一个实现代理接口的匿名类，在调用具体方法前调用InvokeHandler来处理。JDK从1.3版本就开始支持动态代理类的创建。主要核心类只有2个：<code>java.lang.reflect.Proxy</code> 和 <code>java.lang.reflect.InvocationHandler</code> 。创建步骤如下：</p><ul><li>定义业务接口：首先需要有一个业务接口（或多个），这是代理对象要实现的接口。</li><li>实现InvocationHandler接口：编写一个处理器类，它实现了InvocationHandler接口，并覆盖invoke方法。这个方法会在代理对象调用任何方法时被触发。</li><li>创建代理对象：使用<code>Proxy.newProxyInstance()</code>方法创建代理对象。此方法需要三个参数：<ul><li>类加载器（ClassLoader）：用于加载代理类。</li><li>业务接口的Class数组：代理对象需要实现的接口列表。</li><li>InvocationHandler实例：处理方法调用的处理器。</li></ul></li></ul><ul><li>创建Proxy Handle</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdkDynamicProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InvocationHandler</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object target;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">JdkDynamicProxy</span><span class="hljs-params">(Object target)</span> &#123;<br>    <span class="hljs-built_in">this</span>.target = target;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>    System.out.println(<span class="hljs-string">&quot;Before method call: &quot;</span> + method.getName());<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> method.invoke(target, args);<br>    System.out.println(<span class="hljs-string">&quot;After method call: &quot;</span> + method.getName());<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="cglib动态代理"><a href="#cglib动态代理" class="headerlink" title="cglib动态代理"></a>cglib动态代理</h3><p>利用ASM开源包，将代理对象类的class文件加载进来，通过修改其字节码生成子类来处理。Cglib底层是字节码处理框架ASM。相较于jdk动态代理只能基于接口，<code>CGLIB通过继承的方式创建目标类的子类来实现代理，代理对象既可以赋值给实现类，又可以赋值给接口，但这种通过继承类的实现方式，不能代理final修饰的类</code> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CglibDynamicProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span> &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">intercept</span><span class="hljs-params">(Object o, Method method, Object[] objects, MethodProxy proxy)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>    System.out.println(<span class="hljs-string">&quot;Before method: &quot;</span> + method.getName());<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> proxy.invokeSuper(o, objects);<br>    System.out.println(<span class="hljs-string">&quot;After method: &quot;</span> + method.getName());<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ByteBuddy动态代理"><a href="#ByteBuddy动态代理" class="headerlink" title="ByteBuddy动态代理"></a>ByteBuddy动态代理</h3><p>ByteBuddy和Cglib一样，也是基于ASM实现。ByteBuddy常用的应用就是java agent，其主要作用就是在class被加载之前对其拦截，插入自己的代码。与CGLIB和JDK动态代理相比，ByteBuddy提供了更加灵活和高效的代理机制。新版本的Spring的动态代理使用ByteBuddy实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ByteBuddyDynamicProxy</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object bean;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Method[] methods;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ByteBuddyDynamicProxy</span><span class="hljs-params">(Object bean, Method[] methods)</span> &#123;<br>    <span class="hljs-built_in">this</span>.bean = bean;<br>    <span class="hljs-built_in">this</span>.methods = methods;<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getProxyClass</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    Class&lt;?&gt; clazz = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteBuddy</span>()<br>        .subclass(bean.getClass())<br>        .method(ElementMatchers.anyOf(methods))<br>        .intercept(MethodDelegation.to(Interceptor.class))<br>        .make()<br>        .load(ByteBuddyDynamicProxy.class.getClassLoader())<br>        .getLoaded();<br>    <span class="hljs-keyword">return</span> clazz.getDeclaredConstructor().newInstance();<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Interceptor</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">intercept</span><span class="hljs-params">(<span class="hljs-meta">@SuperCall</span> Callable&lt;Void&gt; zuper)</span><span class="hljs-keyword">throws</span> Exception &#123;<br>      System.out.println(<span class="hljs-string">&quot;Before method execution.&quot;</span>);<br>      <span class="hljs-comment">// 这里会执行被代理方法，可以做额外的扩展，如事务管理或性能监控</span><br>      zuper.call();<br>      System.out.println(<span class="hljs-string">&quot;After method execution.&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@RuntimeType</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">intercept</span><span class="hljs-params">(<span class="hljs-meta">@Origin</span> Method method, <span class="hljs-meta">@AllArguments</span> Object[] args, <span class="hljs-meta">@SuperCall</span> Callable&lt;?&gt; callable</span><br><span class="hljs-params">    )</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>      System.out.println(<span class="hljs-string">&quot;Before method execution.&quot;</span>);<br><span class="hljs-comment">// 这里会执行被代理方法，可以做额外的扩展，如事务管理或性能监控</span><br>      callable.call();<br>      System.out.println(<span class="hljs-string">&quot;After method execution.&quot;</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="javassist动态代理"><a href="#javassist动态代理" class="headerlink" title="javassist动态代理"></a>javassist动态代理</h3><p>Javassist（Java Programming Assistant）是一个用于编辑或创建Java字节码（即.class文件）的库。它使得在运行时处理字节码变得更加容易。Javassist允许开发者以接近源代码的形式操作类和方法，而不是直接处理字节码。这使得它相比于直接操作字节码的方式更易于理解和使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JavassistDynamicProxy</span> &#123;<br>  <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getProxyInstance</span><span class="hljs-params">(Log log)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">ProxyFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyFactory</span>();<br>    factory.setSuperclass(log.getClass());<br>    <span class="hljs-keyword">return</span> factory.create(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Class</span>[<span class="hljs-number">0</span>], <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">0</span>], (self, thisMethod, proceed, args) -&gt; &#123;<br>      System.out.println(<span class="hljs-string">&quot;Before method: &quot;</span> + thisMethod.getName());<br>      <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> thisMethod.invoke(self, args);<br>      System.out.println(<span class="hljs-string">&quot;After method: &quot;</span> + thisMethod.getName());<br>      <span class="hljs-keyword">return</span> result;<br>    &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
      <category>动态代理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>动态代理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring-data-jpa基础</title>
    <link href="/2025/06/10/spring-data-jpa%E5%9F%BA%E7%A1%80/"/>
    <url>/2025/06/10/spring-data-jpa%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p><code>Java Persistence API（JPA）</code> 是 Java 的 ORM 框架标准，它为管理关系数据提供了一个标准、基于面向对象的API，开发者可以用极简的代码即可实现对数据的访问和操作。JPA维护了一个 <code>Persistence Context</code> (持久化上下文)，在持久化上下文中维护实体的生命周期。主要包含三个方面的内容：</p><ul><li>ORM元数据。JPA支持annotion或xml两种形式描述对象-关系映射。</li><li>实体操作API。实现对实体对象的CRUD操作。</li><li>查询语言。约定了面向对象的查询语言<strong>JPQL（Java Persistence Query Language）</strong>。</li></ul><span id="more"></span><h2 id="JPA核心接口"><a href="#JPA核心接口" class="headerlink" title="JPA核心接口"></a>JPA核心接口</h2><p><img src="/images/spring-data-jpa%E5%9F%BA%E7%A1%80_JpaRepository%E7%B1%BB%E5%9B%BE.png"></p><p>Repository 接口是 Spring Data 的一个核心接口, 是一个标记接口。业务接口继承Repository，则该接口会被IOC容器识别为一个Repository Bean注入到IOC容器中，只要遵循Spring Data的方法定义规范，就无需写实现类。</p><p>CrudRepository： 继承 Repository，实现了一组 CRUD 相关的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-comment">//保存单个实体</span><br>T <span class="hljs-title function_">save</span><span class="hljs-params">(T entity)</span>; <br><span class="hljs-comment">//保存集合</span><br>Iterable <span class="hljs-title function_">save</span><span class="hljs-params">(Iterable&lt;? extends T&gt; entities)</span>; <br><span class="hljs-comment">//根据id查找实体</span><br>T <span class="hljs-title function_">findOne</span><span class="hljs-params">(ID id)</span>; <br><span class="hljs-comment">//根据id判断实体是否存在</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">exists</span><span class="hljs-params">(ID id)</span>; <br><span class="hljs-comment">//查询所有实体</span><br>Iterable <span class="hljs-title function_">findAll</span><span class="hljs-params">()</span>; <br><span class="hljs-comment">//查询实体数量</span><br><span class="hljs-type">long</span> <span class="hljs-title function_">count</span><span class="hljs-params">()</span>; <br><span class="hljs-comment">//根据Id删除实体</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(ID id)</span>; <br><span class="hljs-comment">//删除一个实体</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(T entity)</span>; <br><span class="hljs-comment">//删除一个实体的集合</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(Iterable&lt;? extends T&gt; entities)</span>; <br><span class="hljs-comment">//删除所有实体</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteAll</span><span class="hljs-params">()</span>; <br></code></pre></td></tr></table></figure><p>PagingAndSortingRepository： 继承 CrudRepository，实现了一组分页排序相关的方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//排序</span><br>Iterable <span class="hljs-title function_">findAll</span><span class="hljs-params">(Sort sort)</span>; <br><span class="hljs-comment">//分页查询</span><br>Page <span class="hljs-title function_">findAll</span><span class="hljs-params">(Pageable pageable)</span>; <br></code></pre></td></tr></table></figure><p>JpaRepository：实现了一组 JPA 规范相关的方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//查找所有实体</span><br>List <span class="hljs-title function_">findAll</span><span class="hljs-params">()</span>; <br><span class="hljs-comment">//排序、查找所有实体</span><br>List <span class="hljs-title function_">findAll</span><span class="hljs-params">(Sort sort)</span>; <br><span class="hljs-comment">//保存集合</span><br>List <span class="hljs-title function_">save</span><span class="hljs-params">(Iterable&lt;? extends T&gt; entities)</span>; <br><span class="hljs-comment">//执行缓存与数据库同步</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">flush</span><span class="hljs-params">()</span>; <br><span class="hljs-comment">//强制执行持久化</span><br>T <span class="hljs-title function_">saveAndFlush</span><span class="hljs-params">(T entity)</span>; <br><span class="hljs-comment">//删除一个实体集合</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteInBatch</span><span class="hljs-params">(Iterable entities)</span>; <br><br></code></pre></td></tr></table></figure><p>在实际开发中直接实现 JpaRepository 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">OrderRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">JpaRepository</span>&lt;OrderEntity, Long&gt; &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="查询方式"><a href="#查询方式" class="headerlink" title="查询方式"></a>查询方式</h2><p>JPA提供了多种查询方式实现：</p><ul><li>JPA接口默认实现接口</li><li>基于命名规则查询：<code>find + [By + 属性名 + 查询条件] + [And/Or + 属性名 + 查询条件]</code>, 条件关键字如：<ul><li>Like：模糊查询</li><li>In：集合包含查询</li><li>NotContaining：不包含查询</li><li>Containing：包含查询</li><li>OrderBy：排序</li><li>First&#x2F;Top：限制结果数量</li></ul></li><li><code>@Query</code> 查询 <ul><li>位置参数</li><li>命名参数</li><li>SpEL表达</li></ul></li></ul><h3 id="JPA接口默认实现接口"><a href="#JPA接口默认实现接口" class="headerlink" title="JPA接口默认实现接口"></a>JPA接口默认实现接口</h3><p>JpaRepository 实现了一些基本的默认 CRUD 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;T&gt; <span class="hljs-title function_">findAll</span><span class="hljs-params">()</span>;<br>Page&lt;T&gt; <span class="hljs-title function_">findAll</span><span class="hljs-params">(Pageable pageable)</span>;<br>T <span class="hljs-title function_">getOne</span><span class="hljs-params">(ID id)</span>;<br>T S <span class="hljs-title function_">save</span><span class="hljs-params">(T entity)</span>;<br><span class="hljs-keyword">void</span> <span class="hljs-title function_">deleteById</span><span class="hljs-params">(ID id)</span>;<br></code></pre></td></tr></table></figure><h3 id="基于命名规则查询"><a href="#基于命名规则查询" class="headerlink" title="基于命名规则查询"></a>基于命名规则查询</h3><blockquote><p>find + [By + 属性名 + 查询条件] + [And&#x2F;Or + 属性名 + 查询条件]</p></blockquote><p>命名规则解析机制： Spring Data JPA会根据方法名称进行解析，它会根据方法名解析出查询条件和参数，将其转换为对应的JPQL查询。关键字与SQL对应关系如下：</p><table><thead><tr><th align="left">Keyword</th><th align="left">JPQL snippet</th></tr></thead><tbody><tr><td align="left">And</td><td align="left">… where x.lastname &#x3D; ?1 and x.firstname &#x3D; ?2</td></tr><tr><td align="left">Or</td><td align="left">… where x.lastname &#x3D; ?1 or x.firstname &#x3D; ?2</td></tr><tr><td align="left">Is, Equals</td><td align="left">… where x.firstname &#x3D; ?1</td></tr><tr><td align="left">Between</td><td align="left">… where x.startDate between ?1 and ?2</td></tr><tr><td align="left">LessThan</td><td align="left">… where x.age &lt; ?1</td></tr><tr><td align="left">LessThanEqual</td><td align="left">… where x.age ⇐ ?1</td></tr><tr><td align="left">GreaterThan</td><td align="left">… where x.age &gt; ?1</td></tr><tr><td align="left">GreaterThanEqual</td><td align="left">… where x.age &gt;&#x3D; ?1</td></tr><tr><td align="left">After</td><td align="left">… where x.startDate &gt; ?1</td></tr><tr><td align="left">Before</td><td align="left">… where x.startDate &lt; ?1</td></tr><tr><td align="left">IsNull</td><td align="left">… where x.age is null</td></tr><tr><td align="left">IsNotNull, NotNull</td><td align="left">… where x.age not null</td></tr><tr><td align="left">Like</td><td align="left">… where x.firstname like ?1</td></tr><tr><td align="left">NotLike</td><td align="left">… where x.firstname not like ?1</td></tr><tr><td align="left">StartingWith</td><td align="left">… where x.firstname like ?1 (parameter bound with appended %)</td></tr><tr><td align="left">EndingWith</td><td align="left">… where x.firstname like ?1 (parameter bound with prepended %)</td></tr><tr><td align="left">Containing</td><td align="left">… where x.firstname like ?1 (parameter bound wrapped in %)</td></tr><tr><td align="left">OrderBy</td><td align="left">… where x.age &#x3D; ?1 order by x.lastname desc</td></tr><tr><td align="left">Not</td><td align="left">… where x.lastname &lt;&gt; ?1</td></tr><tr><td align="left">In</td><td align="left">… where x.age in ?1</td></tr><tr><td align="left">NotIn</td><td align="left">… where x.age not in ?1</td></tr><tr><td align="left">TRUE</td><td align="left">… where x.active &#x3D; true</td></tr><tr><td align="left">FALSE</td><td align="left">… where x.active &#x3D; false</td></tr><tr><td align="left">IgnoreCase</td><td align="left">… where UPPER(x.firstame) &#x3D; UPPER(?1)</td></tr></tbody></table><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Order <span class="hljs-title function_">findByOrderId</span><span class="hljs-params">(Long orderId)</span>;<br>List&lt;Order&gt; <span class="hljs-title function_">findByUserId</span><span class="hljs-params">(Long userId)</span>;<br></code></pre></td></tr></table></figure><h3 id="Query-注解查询"><a href="#Query-注解查询" class="headerlink" title="@Query 注解查询"></a><code>@Query</code> 注解查询</h3><ul><li>位置参数</li><li>命名参数</li><li>SpEL表达</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 位置参数</span><br><span class="hljs-meta">@Query(&quot;select count(o) from OrderEntity o where o.userId = ?1&quot;)</span><br>Long <span class="hljs-title function_">countWithFirstname</span><span class="hljs-params">(Long userId)</span>;<br><br><span class="hljs-comment">// 命名参数</span><br><span class="hljs-meta">@Query(&quot;select o from OrderEntity o where o.orderId = :orderId or o.userId = :userId&quot;)</span><br>List&lt;OrderEntity&gt; <span class="hljs-title function_">findByOrderIdAndUserId</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;orderId&quot;)</span> Long orderId, <span class="hljs-meta">@Param(&quot;userId&quot;)</span> Long userId)</span>;<br><br><span class="hljs-comment">// SpEL表达</span><br><span class="hljs-meta">@Query(&quot;select o from OrderEntity o where o.userId = :#&#123;#order.orderId&#125;&quot;)</span><br>List&lt;OrderEntity&gt; <span class="hljs-title function_">findByOrderIdAsSpELExpression</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;order&quot;)</span> OrderEntity order)</span>;<br></code></pre></td></tr></table></figure><h3 id="复杂条件查询"><a href="#复杂条件查询" class="headerlink" title="复杂条件查询"></a>复杂条件查询</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">Specification&lt;OrderEntity&gt; specification = (root, criteriaQuery, criteriaBuilder) -&gt; &#123;<br><span class="hljs-type">Subquery</span> <span class="hljs-variable">subQuery</span> <span class="hljs-operator">=</span> criteriaQuery.subquery(String.class);<br><span class="hljs-type">Root</span> <span class="hljs-variable">from</span> <span class="hljs-operator">=</span> subQuery.from(OrderEntity.class);<br>subQuery.select(from.get(<span class="hljs-string">&quot;userId&quot;</span>)).where(criteriaBuilder.equal(from.get(<span class="hljs-string">&quot;orderId&quot;</span>), <span class="hljs-string">&quot;123456&quot;</span>));<br><span class="hljs-keyword">return</span> criteriaBuilder.and(root.get(<span class="hljs-string">&quot;userId&quot;</span>).in(subQuery));<br>&#125;;<br><span class="hljs-keyword">return</span> orderRepository.findAll(specification);<br></code></pre></td></tr></table></figure><h3 id="基于命名规则实现机制"><a href="#基于命名规则实现机制" class="headerlink" title="基于命名规则实现机制"></a>基于命名规则实现机制</h3><p>Spring Data JPA在启动时会解析Repository接口中的方法名称，根据命名规则将方法名转换为JPQL查询，如果有@Query注解，则使用注解中定义的查询语句。在底层通过通过JdkDynamicAopProxy的invoke方法创建了一个动态代理对象来处理这些方法。</p><h4 id="代理对象创建核心类"><a href="#代理对象创建核心类" class="headerlink" title="代理对象创建核心类"></a>代理对象创建核心类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JpaRepositoryFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RepositoryFactorySupport</span> &#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EntityManager entityManager;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> QueryExtractor extractor;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CrudMethodMetadataPostProcessor crudMethodMetadataPostProcessor;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CrudMethodMetadata crudMethodMetadata;<br><br>  ....<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">JpaRepositoryFactory</span><span class="hljs-params">(EntityManager entityManager)</span> &#123;<br><br>Assert.notNull(entityManager, <span class="hljs-string">&quot;EntityManager must not be null&quot;</span>);<br><br><span class="hljs-built_in">this</span>.entityManager = entityManager;<br><span class="hljs-built_in">this</span>.extractor = PersistenceProvider.fromEntityManager(entityManager);<br><span class="hljs-built_in">this</span>.crudMethodMetadataPostProcessor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CrudMethodMetadataPostProcessor</span>();<br><span class="hljs-built_in">this</span>.entityPathResolver = SimpleEntityPathResolver.INSTANCE;<br><span class="hljs-built_in">this</span>.queryMethodFactory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultJpaQueryMethodFactory</span>(extractor);<br><span class="hljs-built_in">this</span>.queryRewriterProvider = QueryRewriterProvider.simple();<br><br>addRepositoryProxyPostProcessor(crudMethodMetadataPostProcessor);<br>addRepositoryProxyPostProcessor((factory, repositoryInformation) -&gt; &#123;<br><span class="hljs-keyword">if</span> (isTransactionNeeded(repositoryInformation.getRepositoryInterface())) &#123;<br>        <span class="hljs-comment">// 创建 AOP 代理 </span><br>factory.addAdvice(SurroundingTransactionDetectorMethodInterceptor.INSTANCE);<br>&#125;<br>&#125;);<br>    .....<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>RepositoryFactorySupport: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RepositoryFactorySupport</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanClassLoaderAware</span>, BeanFactoryAware &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;RepositoryInformationCacheKey, RepositoryInformation&gt; repositoryInformationCache;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;RepositoryProxyPostProcessor&gt; postProcessors;<br><br><span class="hljs-keyword">private</span> Optional&lt;Class&lt;?&gt;&gt; repositoryBaseClass;<br><span class="hljs-keyword">private</span> <span class="hljs-meta">@Nullable</span> QueryLookupStrategy.Key queryLookupStrategyKey;<br><span class="hljs-keyword">private</span> List&lt;QueryCreationListener&lt;?&gt;&gt; queryPostProcessors;<br><span class="hljs-keyword">private</span> List&lt;RepositoryMethodInvocationListener&gt; methodInvocationListeners;<br><span class="hljs-keyword">private</span> NamedQueries namedQueries;<br><span class="hljs-keyword">private</span> ClassLoader classLoader;<br><span class="hljs-keyword">private</span> QueryMethodEvaluationContextProvider evaluationContextProvider;<br><span class="hljs-keyword">private</span> BeanFactory beanFactory;<br><span class="hljs-keyword">private</span> Lazy&lt;ProjectionFactory&gt; projectionFactory;<br><br>  .....<br>&#125;<br></code></pre></td></tr></table></figure><p>QueryExecutorMethodInterceptor: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">QueryExecutorMethodInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MethodInterceptor</span> &#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RepositoryInformation repositoryInformation;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Method, RepositoryQuery&gt; queries;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Method, RepositoryMethodInvoker&gt; invocationMetadataCache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentReferenceHashMap</span>&lt;&gt;();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Method, MethodParameter&gt; returnTypeMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> QueryExecutionResultHandler resultHandler;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> NamedQueries namedQueries;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;QueryCreationListener&lt;?&gt;&gt; queryPostProcessors;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RepositoryInvocationMulticaster invocationMulticaster;<br><br>  ....<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="代理创建主要步骤"><a href="#代理创建主要步骤" class="headerlink" title="代理创建主要步骤"></a>代理创建主要步骤</h4><ul><li>配置启动方式：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableJpaRepositories(</span><br><span class="hljs-meta">    bootstrapMode = BootstrapMode.DEFERRED  // 可选：DEFAULT, LAZY, DEFERRED</span><br><span class="hljs-meta">)</span><br></code></pre></td></tr></table></figure><ul><li><p>Repository 接口检测：</p><ul><li>扫描 @EnableJpaRepositories 注解配置的包路径</li><li>找到继承了 Repository 接口的接口</li></ul></li><li><p>创建 RepositoryFactoryBean：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JpaRepositoryFactoryBean</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Repository</span>&lt;S, ID&gt;, S, ID&gt; <br>    <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RepositoryFactoryBeanSupport</span>&lt;T, S, ID&gt; &#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> RepositoryFactorySupport <span class="hljs-title function_">createRepositoryFactory</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JpaRepositoryFactory</span>(entityManager);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="代理实现的核心机制"><a href="#代理实现的核心机制" class="headerlink" title="代理实现的核心机制"></a>代理实现的核心机制</h4><ul><li>基础实现类：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> Class&lt;?&gt; getRepositoryBaseClass(RepositoryMetadata metadata) &#123;<br>    <span class="hljs-keyword">return</span> SimpleJpaRepository.class;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>查询方法的解析和代理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> Optional&lt;QueryLookupStrategy&gt; <span class="hljs-title function_">getQueryLookupStrategy</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Key key,</span><br><span class="hljs-params">        ValueExpressionDelegate valueExpressionDelegate)</span> &#123;<br>    <br>    <span class="hljs-type">JpaQueryConfiguration</span> <span class="hljs-variable">queryConfiguration</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JpaQueryConfiguration</span>(<span class="hljs-comment">/*...*/</span>);<br>    <span class="hljs-keyword">return</span> Optional.of(JpaQueryLookupStrategy.create(<br>        entityManager, <br>        queryMethodFactory,<br>        key, <br>        queryConfiguration<br>    ));<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>方法拦截器：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">JpaRepositoryFactory</span><span class="hljs-params">(EntityManager entityManager)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    addRepositoryProxyPostProcessor((factory, repositoryInformation) -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (isTransactionNeeded(repositoryInformation.getRepositoryInterface())) &#123;<br>            factory.addAdvice(SurroundingTransactionDetectorMethodInterceptor.INSTANCE);<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>代理对象的创建过程: CrudMethodMetadata 代理创建</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CrudMethodMetadataPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RepositoryProxyPostProcessor</span> &#123;<br>    CrudMethodMetadata <span class="hljs-title function_">getCrudMethodMetadata</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ProxyFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ProxyFactory</span>();<br>        factory.addInterface(CrudMethodMetadata.class);<br>        factory.setTargetSource(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadBoundTargetSource</span>());<br>        <span class="hljs-keyword">return</span> (CrudMethodMetadata) factory.getProxy(<span class="hljs-built_in">this</span>.classLoader);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>动态方法实现<ul><li>对于查询方法，生成对应的 JPQL 或 SQL</li><li>对于默认方法，使用 SimpleJpaRepository 中的实现</li><li>对于自定义查询（@Query），使用注解中定义的查询语句</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> RepositoryFragments <span class="hljs-title function_">getRepositoryFragments</span><span class="hljs-params">(</span><br><span class="hljs-params">      RepositoryMetadata metadata,   </span><br><span class="hljs-params">      EntityManager entityManager,</span><br><span class="hljs-params">EntityPathResolver resolver, </span><br><span class="hljs-params">      CrudMethodMetadata crudMethodMetadata)</span> &#123;<br><br>  <span class="hljs-type">boolean</span> <span class="hljs-variable">isQueryDslRepository</span> <span class="hljs-operator">=</span> QUERY_DSL_PRESENT<br>      &amp;&amp; QuerydslPredicateExecutor.class.isAssignableFrom(metadata.getRepositoryInterface());<br><br>  <span class="hljs-keyword">if</span> (isQueryDslRepository) &#123;<br>    ....<br>    QuerydslJpaPredicateExecutor&lt;?&gt; querydslJpaPredicateExecutor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QuerydslJpaPredicateExecutor</span>&lt;&gt;(<br>        getEntityInformation(metadata.getDomainType()), entityManager, resolver, crudMethodMetadata);<br>    invokeAwareMethods(querydslJpaPredicateExecutor);<br>    <span class="hljs-keyword">return</span> RepositoryFragments.just(querydslJpaPredicateExecutor);<br>  &#125;<br>  <span class="hljs-keyword">return</span> RepositoryFragments.empty();<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>QueryDSL支持</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> RepositoryFragments <span class="hljs-title function_">getRepositoryFragments</span><span class="hljs-params">(RepositoryMetadata metadata)</span> &#123;<br>    <span class="hljs-comment">// 添加 QuerydslJpaPredicateExecutor 支持</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>整个过程的工作流程：</p><ul><li>启动时扫描 Repository 接口</li><li>为每个接口创建 JpaRepositoryFactory</li><li>通过工厂创建代理对象：<ul><li>基础实现来自 SimpleJpaRepository</li><li>查询方法通过方法名或注解解析</li><li>添加事务、缓存等切面</li></ul></li><li>注入代理对象到使用处</li></ul><h2 id="实体注解"><a href="#实体注解" class="headerlink" title="实体注解"></a>实体注解</h2><h3 id="基础注解"><a href="#基础注解" class="headerlink" title="基础注解"></a>基础注解</h3><h4 id="Entity"><a href="#Entity" class="headerlink" title="@Entity"></a>@Entity</h4><p>标记一个类为实体类，表示该类将映射到数据库表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Entity</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure><h4 id="Table"><a href="#Table" class="headerlink" title="@Table"></a>@Table</h4><p>指定实体类映射到的数据库表信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Entity</span><br><span class="hljs-meta">@Table(name = &quot;employees&quot;, schema = &quot;hr&quot;, </span><br><span class="hljs-meta">       uniqueConstraints = &#123;@UniqueConstraint(columnNames = &#123;&quot;email&quot;, &quot;company_id&quot;&#125;)&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Employee</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure><h4 id="Id"><a href="#Id" class="headerlink" title="@Id"></a>@Id</h4><p>标记实体类的主键字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Id</span><br><span class="hljs-keyword">private</span> Long id;<br></code></pre></td></tr></table></figure><h4 id="GeneratedValue"><a href="#GeneratedValue" class="headerlink" title="@GeneratedValue"></a>@GeneratedValue</h4><p>指定主键的生成策略。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Id</span><br><span class="hljs-meta">@GeneratedValue(strategy = GenerationType.IDENTITY)</span><br><span class="hljs-keyword">private</span> Long id;<br></code></pre></td></tr></table></figure><p>生成策略包括：</p><ul><li><code>GenerationType.IDENTITY</code>: 依赖数据库的自增长特性</li><li><code>GenerationType.SEQUENCE</code>: 使用数据库序列生成主键</li><li><code>GenerationType.TABLE</code>: 使用表来模拟序列</li><li><code>GenerationType.AUTO</code>: 由持久性提供者自动选择合适的策略</li></ul><h4 id="Column"><a href="#Column" class="headerlink" title="@Column"></a>@Column</h4><p>指定字段映射到表中列的详细信息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Column(name = &quot;user_name&quot;, length = 50, nullable = false, unique = true)</span><br><span class="hljs-keyword">private</span> String username;<br></code></pre></td></tr></table></figure><p>主要属性：</p><ul><li><code>name</code>: 列名（默认为字段名）</li><li><code>length</code>: 列长度</li><li><code>nullable</code>: 是否允许为空</li><li><code>unique</code>: 是否唯一约束</li><li><code>insertable</code>: 插入时是否包含此字段</li><li><code>updatable</code>: 更新时是否包含此字段</li><li><code>precision</code>: 浮点数的精度</li><li><code>scale</code>: 浮点数的小数位数</li></ul><h4 id="Transient"><a href="#Transient" class="headerlink" title="@Transient"></a>@Transient</h4><p>标记字段不会被持久化到数据库。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transient</span><br><span class="hljs-keyword">private</span> String tempValue;<br></code></pre></td></tr></table></figure><h4 id="Temporal"><a href="#Temporal" class="headerlink" title="@Temporal"></a>@Temporal</h4><p>指定日期类型字段映射到的SQL日期类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Temporal(TemporalType.DATE)</span><br><span class="hljs-keyword">private</span> Date birthDate;<br><br><span class="hljs-meta">@Temporal(TemporalType.TIMESTAMP)</span><br><span class="hljs-keyword">private</span> Date createdAt;<br></code></pre></td></tr></table></figure><p>类型包括：</p><ul><li><code>TemporalType.DATE</code>: 只包含日期信息</li><li><code>TemporalType.TIME</code>: 只包含时间信息</li><li><code>TemporalType.TIMESTAMP</code>: 包含日期和时间信息</li></ul><h3 id="有用的注解"><a href="#有用的注解" class="headerlink" title="有用的注解"></a>有用的注解</h3><h4 id="Version"><a href="#Version" class="headerlink" title="@Version"></a>@Version</h4><p>用于实现乐观锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Version</span><br><span class="hljs-keyword">private</span> Long version;<br></code></pre></td></tr></table></figure><h4 id="Where"><a href="#Where" class="headerlink" title="@Where"></a>@Where</h4><p>定义实体类的查询条件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Entity</span><br><span class="hljs-meta">@Where(clause = &quot;deleted = false&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Document</span> &#123; ... &#125;<br></code></pre></td></tr></table></figure><h4 id="Formula-Hibernate特有-实体字段直接映射SQL表达式，替代重复计算逻辑"><a href="#Formula-Hibernate特有-实体字段直接映射SQL表达式，替代重复计算逻辑" class="headerlink" title="@Formula (Hibernate特有) - 实体字段直接映射SQL表达式，替代重复计算逻辑"></a>@Formula (Hibernate特有) - 实体字段直接映射SQL表达式，替代重复计算逻辑</h4><p>定义计算列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Formula(&quot;(SELECT COUNT(c.id) FROM comments c WHERE c.post_id = id)&quot;)</span><br><span class="hljs-keyword">private</span> Long commentCount;<br></code></pre></td></tr></table></figure><h4 id="SQLRestriction：实体级原生SQL条件，简化动态查询"><a href="#SQLRestriction：实体级原生SQL条件，简化动态查询" class="headerlink" title="@SQLRestriction：实体级原生SQL条件，简化动态查询"></a>@SQLRestriction：实体级原生SQL条件，简化动态查询</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Entity</span><br><span class="hljs-meta">@Table(name = &quot;product&quot;)</span><br><span class="hljs-meta">@SQLRestriction(&quot;deleted = 0&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> &#123;<br>  <span class="hljs-comment">// ...其它属性</span><br>  <br>  <span class="hljs-comment">/**0: 未删除, 1: 已删除*/</span><br>  <span class="hljs-meta">@Column(columnDefinition = &quot;int default 0&quot;)</span><br>  <span class="hljs-keyword">private</span> Integer deleted ;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Filter-参数化过滤条件，支持会话级控制"><a href="#Filter-参数化过滤条件，支持会话级控制" class="headerlink" title="@Filter: 参数化过滤条件，支持会话级控制"></a>@Filter: 参数化过滤条件，支持会话级控制</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Entity</span><br><span class="hljs-meta">@Table(name = &quot;product&quot;)</span><br><span class="hljs-meta">@FilterDef(name = &quot;filterByDeletedAndStock&quot;, parameters = &#123;</span><br><span class="hljs-meta">    @ParamDef(name = &quot;state&quot;, type = Integer.class),</span><br><span class="hljs-meta">    @ParamDef(name = &quot;stock&quot;, type = Integer.class)</span><br><span class="hljs-meta">&#125;)</span><br><span class="hljs-meta">@Filters(&#123;</span><br><span class="hljs-meta">    @Filter(name = &quot;filterByDeletedAndStock&quot;, condition = &quot;deleted=:state and stock &gt;:stock&quot;)</span><br><span class="hljs-meta">&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Product</span> &#123;&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>spring</category>
      
      <category>spring-boot</category>
      
      <category>spring-data</category>
      
      <category>JPA</category>
      
      <category>ORM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>spring</tag>
      
      <tag>spring-boot</tag>
      
      <tag>spring-data</tag>
      
      <tag>JPA</tag>
      
      <tag>ORM</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
