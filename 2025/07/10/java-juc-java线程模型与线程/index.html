

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="ares">
  <meta name="keywords" content="">
  
    <meta name="description" content="概述在现代操作系统中，线程是处理器调度和分配的基本单位，进程则是作为资源(内存地址、文件 I&#x2F;O 等)拥有的基本单位。线程是进程内部的一个执行单元，每一个进程至少有一个主执行线程，它无需由用户去主动创建，是由系统自动创建的。用户根据需要在应用程序中创建其它线程，多个线程并发地运行于同一个进程中。">
<meta property="og:type" content="article">
<meta property="og:title" content="java线程模型与多线程基础">
<meta property="og:url" content="http://example.com/2025/07/10/java-juc-java%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/index.html">
<meta property="og:site_name" content="Ares&#39;s Notes">
<meta property="og:description" content="概述在现代操作系统中，线程是处理器调度和分配的基本单位，进程则是作为资源(内存地址、文件 I&#x2F;O 等)拥有的基本单位。线程是进程内部的一个执行单元，每一个进程至少有一个主执行线程，它无需由用户去主动创建，是由系统自动创建的。用户根据需要在应用程序中创建其它线程，多个线程并发地运行于同一个进程中。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/java-juc-java%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B_java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.png">
<meta property="article:published_time" content="2025-07-10T11:03:24.000Z">
<meta property="article:modified_time" content="2025-11-04T08:07:55.156Z">
<meta property="article:author" content="ares">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="juc">
<meta property="article:tag" content="并发">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/images/java-juc-java%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B_java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.png">
  
  
  
  <title>java线程模型与多线程基础 - Ares&#39;s Notes</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":"§"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.1.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Ares&#39;s Notes</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">java线程模型与多线程基础</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-07-10 19:03" pubdate>
          2025年7月10日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          7.1k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          59 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">java线程模型与多线程基础</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在现代操作系统中，线程是处理器调度和分配的基本单位，进程则是作为资源(内存地址、文件 I&#x2F;O 等)拥有的基本单位。线程是进程内部的一个执行单元，每一个进程至少有一个主执行线程，它无需由用户去主动创建，是由系统自动创建的。用户根据需要在应用程序中创建其它线程，多个线程并发地运行于同一个进程中。</p>
<span id="more"></span>

<p>在进行并发编程时，如果希望通过多线程执行任务让程序运行得更快，会面临诸多挑战：</p>
<ul>
<li>上下文切换问题；</li>
<li>死锁问题；</li>
<li>硬件和硬件资源限制。</li>
</ul>
<h3 id="上下文切换问题"><a href="#上下文切换问题" class="headerlink" title="上下文切换问题"></a>上下文切换问题</h3><p>CPU 通过给每个线程分配 CPU 时间片来实现事件推进，CPU分配给各个线程的时间非常短，所以 CPU 通过不停地切换线程执行，让我们感觉多个线程是同时执行的。<font color=green>在CPU切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态，所以任务从保存到再加载的过程就是一次上下文切换</font>。</p>
<p>线程上下文切换是有成本的，主要体现在以下几个方面：</p>
<ul>
<li><strong>CPU 开销</strong>：保存和恢复线程状态需要 CPU 执行额外的指令</li>
<li><strong>缓存失效</strong>：上下文切换可能导致 CPU 缓存、TLB（Translation Lookaside Buffer）和分支预测器的失效，从而增加内存访问延迟。</li>
<li><strong>内核态开销</strong>：上下文切换通常涉及从用户态切换到内核态的操作，这进一步增加了开销。</li>
</ul>
<p><strong>减少上下文切换的方法：</strong></p>
<ul>
<li>减少线程数量：使用合理数量的线程，避免线程过多导致频繁切换;</li>
<li>无锁编程：减少线程之间的锁竞争，降低阻塞几率；</li>
<li>使用适当的线程池：利用线程池复用线程，避免频繁的线程创建和销毁；</li>
<li>CAS 算法：使用 CAS 算法来更新数据，而不需要加锁；</li>
<li>线程池复用：选择合适的调度策略，减少不必要的上下文切换。</li>
</ul>
<h3 id="Linux系统分层架构"><a href="#Linux系统分层架构" class="headerlink" title="Linux系统分层架构"></a>Linux系统分层架构</h3><p>进程作为资源拥有者，其调度及系统资源的分配离不开操作系统。这里以Linux系统为例，为了确保系统的安全性、稳定性和高效性，Linux 使用 <strong>用户空间 (User Space) 与内核空间 (Kernel Space)</strong> 的分离设计。 </p>
<p><strong>内核空间 (Kernel Space)</strong><br>内核是 Linux 操作系统的核心，直接与硬件层交互，它负责管理系统的所有资源，并为上层软件提供接口。Linux 内核采用<strong>宏内核（monolithic kernel）</strong> 架构，这意味着所有的核心功能（如设备驱动、文件系统、内存管理、进程管理等）都包含在一个单一的、受保护的地址空间内。内核的主要功能包括：</p>
<ul>
<li>内存管理：管理系统的 RAM，确保进程高效、安全地使用内存。</li>
<li>进程管理：负责创建、调度和终止进程，公平地分配 CPU 时间。</li>
<li>设备驱动程序：控制特定的硬件设备，将硬件操作抽象为统一的接口。</li>
<li>文件系统：管理数据的存储和检索，提供对不同类型文件系统的支持。</li>
<li>网络管理：处理网络通信协议和接口。</li>
<li>系统调用接口：提供应用程序访问内核功能的接口。</li>
</ul>
<p><strong>用户空间 (User Space)</strong><br>用户空间是用户与计算机硬件之间的高级抽象层，它提供了一个安全、稳定且灵活的环境，允许各种应用程序运行，同时将复杂的硬件管理和系统控制任务留给特权的内核空间来处理。它是受限的、非特权的环境，与具有完全硬件访问权限的内核空间严格隔离。主要特点：</p>
<ul>
<li>隔离性：每个用户空间进程通常运行在自己独立的虚拟内存空间中，无法直接访问其他进程或内核的内存。</li>
<li>非特权模式 (User Mode)：用户空间的代码在 CPU 的非特权级别（如 x86 架构的 Ring 3）运行，权限受限。</li>
<li>通过系统调用与内核通信：当用户程序需要执行特权操作（如文件 I&#x2F;O、网络访问、内存分配等）时，必须发起系统调用 (System Call)，请求内核代为执行。</li>
<li>健壮性与安全性：用户空间的设计提供了一个沙盒环境。即使某个用户程序崩溃，也不会影响到操作系统内核或其他程序，从而保证了系统的稳定性。</li>
</ul>
<p><font color=red>总之，用户空间和内核空间的分离通过引入特权隔离层，使得 Linux 操作系统能够在一个多任务、多用户的环境中提供一个健壮、可靠且安全的运行平台。</font></p>
<h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><p>由于Linux系统的分层架构，线程的实现可以分为两类：<strong>用户级线程(User-LevelThread, ULT)和内核级线程(Kemel-LevelThread, KLT)</strong>。在用户级线程中，线程的创建和销毁都是由用户程序来完成，用户程序需要调用系统提供的接口来创建和销毁线程，而线程的调度则交由操作系统来完成。多线程模型即用户级线程和内核级线程的不同连接方式，线程模型影响着并发规模及操作成本(开销)。通常多线程有如下几种实现：</p>
<ul>
<li><p><strong>多对一模式 - 使用用户线程实现(m:1)</strong>：多个用户线程映射到一个内核线程，用户线程建立在用户空间的线程库上，用户线程的建立、同步、销毁和调度完全在用户态中完成，对内核透明。</p>
<ul>
<li><p>优点：</p>
<ul>
<li>线程的上下文切换都发生在用户空间，避免了模态切换（mode switch），减少了性能的开销。</li>
<li>用户线程的创建不受内核资源的限制，可以支持更大规模的线程数量。</li>
</ul>
</li>
<li><p>缺点：</p>
<ul>
<li>所有的线程基于一个内核调度实体即内核线程，这意味着只有一个处理器可以被利用，浪费了其它处理器资源，不支持并行，在多处理器环境下这是不能够被接受的，如果线程因为 I&#x2F;O 操作陷入了内核态，内核态线程阻塞等待 I&#x2F;O 数据，则所有的线程都将会被阻塞。</li>
<li>增加了复杂度，所有的线程操作都需要用户程序自己处理，而且在用户空间要想自己实现 “阻塞的时候把线程映射到其他处理器上” 异常困难。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>一对一模式 - 使用内核线程实现(1:1)</strong>：程序使用的是轻量级进程（Light Weight Process, LWP），轻量级进程就是我们通常意义上所讲的线程, 也是属于用户线程。在实现上每个用户线程都映射到一个内核线程，每个线程都成为一个独立的调度单元，由内核调度器独立调度，一个线程的阻塞不会影响到其他线程，从而保障整个进程继续工作。</p>
<ul>
<li>优点：<ul>
<li>每个线程都成为一个独立的调度单元，使用内核提供的线程调度功能及处理器映射，可以完成线程的切换，并将线程的任务映射到其他处理器上，充分利用多核处理器的优势，实现真正的并行。</li>
</ul>
</li>
<li>缺点：<ul>
<li>每创建一个用户级线程都需要创建一个内核级线程与其对应，因此需要消耗一定的内核资源, 而内核资源是有限的，所以能创建的线程数量也是有限的。</li>
<li>模态切换频繁，各种线程操作，如创建、析构及同步，都需要进行系统调用，需要频繁的在用户态和内核态之间切换，开销大。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>多对多模式 - 混合模型(m:n)</strong>：内核线程和用户线程的数量比为 M : N，这种模型需要内核线程调度器和用户空间线程调度器相互操作，本质上是多个线程被映射到了多个内核线程。其综合了前面两种模型的优点：</p>
<ul>
<li>用户线程的创建、切换、析构及同步依然发生在用户空间，能创建数量更多的线程，支持更大规模的并发。</li>
<li>大部分的线程上下文切换都发生在用户空间，减少了模态切换带来的开销。</li>
<li>可以使用内核提供的线程调度功能及处理器映射，充分利用多核处理器的优势，实现真正的并行，并降低了整个进程被完全阻塞的风险。</li>
</ul>
</li>
</ul>
<h3 id="Java线程模型"><a href="#Java线程模型" class="headerlink" title="Java线程模型"></a>Java线程模型</h3><p>Java 的线程是映射到操作系统的原生线程之上。JVM 只封装了底层操作系统的差异，不同的操作系统可能使用不同的线程模型，例如 Linux 和 windows 可能使用了一对一模型，solaris 和 unix 某些版本可能使用多对多模型，所以谈到 Java 语言的多线程模型，需要针对具体 JVM 实现。</p>
<p>在Java中Thread类实现了对操作系统线程的抽象。具体来说，在Java中一个操作系统线程与一个Thread对象关联，通过调用Thread对象的start()方法来启动一个操作系统线程执行。其运行逻辑：在调用<code>Thread.start()</code>方法之后，会调用到JVM本地方法，随后申请创建一个新的操作系统线程环境执行<code>Thread.run()</code>，在<code>Thread.run()</code>中最终调用的的<code>Runnable.run()</code>，也就是通过Thread.start()启动的线程最终执行的是Runnable.run()。</p>
<h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><p>在 Java 中，线程可以使用 <code>java.lang.Thread</code> 类来创建和管理线程，最常见的写法例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadTest</span> &#123;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>());<br>    thread.setName(<span class="hljs-string">&quot;test-thread&quot;</span>);<br>    thread.start();<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>      System.out.println(<span class="hljs-string">&quot;线程运行，线程名称为:&quot;</span> + Thread.currentThread().getName());<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="线程生命周期与状态"><a href="#线程生命周期与状态" class="headerlink" title="线程生命周期与状态"></a>线程生命周期与状态</h3><p>在 Java 中线程的生命周期中一共有 6 种状态：</p>
<ul>
<li>New（新创建）</li>
<li>Runnable（可运行）</li>
<li>Blocked（被阻塞）</li>
<li>Waiting（等待）</li>
<li>Timed Waiting（计时等待）</li>
<li>Terminated（被终止）</li>
</ul>
<p><img src="/images/java-juc-java%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B_java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li><p><strong>New</strong><br>表示线程被创建但尚未启动的状态：当我们用 new Thread() 新建一个线程时，如果线程没有开始运行 start() 方法，所以也没有开始执行 run() 方法里面的代码，那么此时它的状态就是 New。而一旦线程调用了 start()，它的状态就会从 New 变成 Runnable。</p>
</li>
<li><p><strong>Runable</strong><br>对应操作系统线程状态中的两种状态，<strong>分别是 Running 和 Ready</strong>。Java 中处于 Runnable 状态的线程有可能正在执行，也有可能没有正在执行，正在等待被分配 CPU 资源。所以，如果一个正在运行的线程是 Runnable 状态，当它运行到任务的一半时，执行该线程的 CPU 被调度去做其他事情，导致该线程暂时不运行，它的状态依然不变，还是 Runnable，因为它有可能随时被调度回来继续执行任务。</p>
</li>
<li><p><strong>Blocked</strong> 从箭头的流转方向可以看出，从 Runnable 状态进入 Blocked 状态只有一种可能，就是进入 synchronized 保护的代码时没有抢到 monitor 锁，无论是进入 synchronized 代码块，还是 synchronized 方法，都是一样。</p>
</li>
<li><p><strong>Waiting</strong> 状态有三种可能性：</p>
<ul>
<li>没有设置 Timeout 参数的 Object.wait() 方法。</li>
<li>没有设置 Timeout 参数的 Thread.join() 方法。</li>
<li>LockSupport.park() 方法。</li>
</ul>
</li>
<li><p><strong>Timed Waiting</strong> 状态：</p>
<ul>
<li>设置了时间参数的 Thread.sleep(long millis) 方法；</li>
<li>设置了时间参数的 Object.wait(long timeout) 方法；</li>
<li>设置了时间参数的 Thread.join(long millis) 方法；</li>
<li>设置了时间参数的 LockSupport.parkNanos(long nanos) 方法和 LockSupport.parkUntil(long deadline) 方法。</li>
</ul>
</li>
</ul>
<h3 id="Thread-运行逻辑"><a href="#Thread-运行逻辑" class="headerlink" title="Thread 运行逻辑"></a>Thread 运行逻辑</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>   <span class="hljs-comment">/* What will be run. */</span><br>  <span class="hljs-keyword">private</span> Runnable target;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//省略</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">started</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>      start0();<br>      started = <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      <span class="hljs-comment">//省略</span><br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start0</span><span class="hljs-params">()</span>;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (target != <span class="hljs-literal">null</span>) &#123;<br>      target.run();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>从上面的代码可以看到，在执行 thread.start() 时会调用 JNI 方法 start0()，JVM 执行 start0() 会创建并启动一个真正的操作系统级线程，并将该线程的执行入口与 Java 线程的 run() 方法关联起来。 具体过程如下：</p>
<ul>
<li><strong>调用JNI接口</strong>：JVM 通过 Java Native Interface (JNI) 调用预先加载好的本地库（例如, 在 Linux 中是 libpthread，在 Windows 中是使用 Win32 API 的 kernel32.lib）中对应的 C&#x2F;C++ 函数。</li>
<li><strong>创建操作系统线程</strong>：在本地代码中，JVM 调用底层的操作系统API来创建一个新的原生线程。例如，在 POSIX 系统（如 Linux、macOS）上，会调用 pthread_create() 函数；在 Windows 上，会调用 CreateThread() 函数。这个新的操作系统线程会拥有自己独立的堆栈空间 (stack)。</li>
<li>指定执行入口函数: 在调用操作系统 API 创建线程时，JVM 会传递一个特定的 C&#x2F;C++ 函数地址作为新线程的执行入口点。在 OpenJDK 源码中，这个入口函数通常是 thread_entry() 或类似的函数。</li>
<li><strong>回调Java</strong>：当新的操作系统线程开始执行时，它首先运行上述指定的 C&#x2F;C++ 入口函数 (thread_entry)。这个入口函数负责进行必要的设置（如与 JVM 环境的关联），然后 <strong>回调（thunk back）</strong> 到 Java 层，最终执行对应 Java Thread 对象的 run() 方法。</li>
<li><strong>并发执行</strong>: 此时，原来的主线程从 start() 方法返回，继续执行其后续代码；新创建的线程则开始并发执行其 run() 方法中的业务逻辑。</li>
</ul>
<p>总之：<font color=red>start0() 是连接 Java 世界和底层操作系统线程机制的桥梁，它利用 JNI 请求OS创建新线程，并确保新线程的起点是用户定义的 run() 方法</font>。</p>
<h2 id="virtual-thread"><a href="#virtual-thread" class="headerlink" title="virtual thread"></a>virtual thread</h2><p><strong>虚拟线程（Virtual Threads）是JDK 21引入的，其实现原理是一种用户态线程（User-mode threads）模型，由 JVM 而非操作系统（OS）管理和调度，使用载体线程（Carrier Threads）</strong> 作为底层执行资源的抽象层。传统的平台线程（Platform Threads）采用 1:1 模型，即一个 Java 线程永久绑定一个 OS 线程。虚拟线程则采用 M:N 模型，M 个虚拟线程复用 N 个（数量少得多的）平台线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">sealed</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseVirtualThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span><br>        <span class="hljs-keyword">permits</span> VirtualThread, ThreadBuilders.BoundVirtualThread &#123;<br>  <span class="hljs-comment">// 省略</span><br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VirtualThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseVirtualThread</span> &#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">DEFAULT_SCHEDULER</span> <span class="hljs-operator">=</span> createDefaultScheduler();<br>  <span class="hljs-comment">// scheduler and continuation</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Executor scheduler;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Continuation cont;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Runnable runContinuation;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>由上面代码可看到，与平台线程类似，虚拟线程也是平台线程的一个实例<code>java.lang.Thread</code>。但虚拟线程的实际执行依赖于由平台线程组成的、小的、共享的线程池，这些平台线程称为<code>载体线程</code>。JVM 在实现上依赖于线程池，默认使用 ForkJoinPool 实例作为调度器，管理这些载体线程，通常其并行度与可用 CPU 核心数相当。</p>
<p>虚拟线程的核心思想是解耦：将业务逻辑（虚拟线程）与底层执行资源（载体线程&#x2F;OS线程）分离。通过在 I&#x2F;O 阻塞时动态切换任务，JVM 可以在少量 OS 线程上高效地运行海量的并发任务，同时保留了简单易懂的一个请求一个线程的同步编程模型。</p>
<h3 id="virtual-thread-使用"><a href="#virtual-thread-使用" class="headerlink" title="virtual thread 使用"></a>virtual thread 使用</h3><p><strong>使用 Thread 类和 Thread.Builder 接口创建虚拟线程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> Thread.ofVirtual().start(() -&gt; System.out.println(<span class="hljs-string">&quot;Hello&quot;</span>));<br><br>Thread.<span class="hljs-type">Builder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> Thread.ofVirtual().name(<span class="hljs-string">&quot;MyThread&quot;</span>);<br><span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> () -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;Running thread&quot;</span>);<br>&#125;;<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> builder.start(task);<br></code></pre></td></tr></table></figure>

<p><strong>使用 Executors.newVirtualThreadPerTaskExecutor() 方法创建和运行虚拟线程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">myExecutor</span> <span class="hljs-operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;<br>    Future&lt;?&gt; future = myExecutor.submit(() -&gt; System.out.println(<span class="hljs-string">&quot;Running thread&quot;</span>));<br>    future.get();<br>    System.out.println(<span class="hljs-string">&quot;Task completed&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>


                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Java/" class="category-chain-item">Java</a>
  
  

      </span>
    
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%B9%B6%E5%8F%91/" class="category-chain-item">并发</a>
  
  

      </span>
    
  
    
      <span class="category-chain">
        
  <a href="/categories/juc/" class="category-chain-item">juc</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Java/" class="print-no-link">#Java</a>
      
        <a href="/tags/juc/" class="print-no-link">#juc</a>
      
        <a href="/tags/%E5%B9%B6%E5%8F%91/" class="print-no-link">#并发</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>java线程模型与多线程基础</div>
      <div>http://example.com/2025/07/10/java-juc-java线程模型与线程/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>ares</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年7月10日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/07/13/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/" title="java线程池实现">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">java线程池实现</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/07/04/java-juc-%E9%94%81/" title="java锁基础与实现">
                        <span class="hidden-mobile">java锁基础与实现</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  



  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});

    Fluid.utils.listenDOMLoaded(function() {
      Fluid.events.registerRefreshCallback(function() {
        if ('mermaid' in window) {
          mermaid.init();
        }
      });
    });
  });
</script>






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
