<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="线程池 Thread Pool 是一种基于池化思想管理线程的工具，线程池维护多个线程，等待管理者分配可并发执行的任务：  一方面避免了处理任务时创建销毁线程开销的代价， 另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。">
<meta property="og:type" content="article">
<meta property="og:title" content="java线程池实现">
<meta property="og:url" content="http://example.com/2025/07/13/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/index.html">
<meta property="og:site_name" content="Ares&#39;s Notes">
<meta property="og:description" content="线程池 Thread Pool 是一种基于池化思想管理线程的工具，线程池维护多个线程，等待管理者分配可并发执行的任务：  一方面避免了处理任务时创建销毁线程开销的代价， 另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86_ThreadPoolExecutor%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9E%B6%E6%9E%84.png">
<meta property="og:image" content="http://example.com/images/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86_%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png">
<meta property="og:image" content="http://example.com/images/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86_ThreadPoolExecutor%E4%BB%BB%E5%8A%A1%E6%8F%90%E4%BA%A4%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="http://example.com/images/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86_tomcat%E6%9E%B6%E6%9E%84.png">
<meta property="article:published_time" content="2025-07-13T11:03:24.000Z">
<meta property="article:modified_time" content="2025-11-07T01:39:17.673Z">
<meta property="article:author" content="ares">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="juc">
<meta property="article:tag" content="并发">
<meta property="article:tag" content="线程池">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86_ThreadPoolExecutor%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9E%B6%E6%9E%84.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>java线程池实现</title>
    <!-- async scripts -->
    <!-- Google Analytics -->

  <script async src="https://www.googletagmanager.com/gtag/js?id=G-RL5NX8NL9X"></script>
  <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-RL5NX8NL9X');
  </script>


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<meta name="generator" content="Hexo 8.1.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" aria-label="上一篇" href="/2025/07/15/java-juc-ForkJoinPool%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%8E%9F%E7%90%86/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2025/07/10/java-juc-java%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2025/07/13/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2025/07/13/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/&text=java线程池实现"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2025/07/13/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/&title=java线程池实现"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2025/07/13/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/&is_video=false&description=java线程池实现"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=java线程池实现&body=Check out this article: http://example.com/2025/07/13/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2025/07/13/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/&title=java线程池实现"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2025/07/13/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/&title=java线程池实现"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2025/07/13/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/&title=java线程池实现"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2025/07/13/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/&title=java线程池实现"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2025/07/13/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/&name=java线程池实现&description=&lt;p&gt;线程池 Thread Pool 是一种基于池化思想管理线程的工具，线程池维护多个线程，等待管理者分配可并发执行的任务：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一方面避免了处理任务时创建销毁线程开销的代价，&lt;/li&gt;
&lt;li&gt;另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。&lt;/li&gt;
&lt;/ul&gt;"><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2025/07/13/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/&t=java线程池实现"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadPoolExecutor%E5%9F%BA%E7%A1%80%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text">ThreadPoolExecutor基础与使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BlockingQueue%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">1.1.</span> <span class="toc-text">BlockingQueue阻塞队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ELinkedTransferQueue%E5%AE%9E%E7%8E%B0ThreadPoolExecutor%E8%87%AA%E5%AE%9A%E4%B9%89%E9%98%9F%E5%88%97%EF%BC%9A"><span class="toc-number">1.1.1.</span> <span class="toc-text">基于LinkedTransferQueue实现ThreadPoolExecutor自定义队列：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadFactory"><span class="toc-number">1.2.</span> <span class="toc-text">ThreadFactory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RejectedExecutionHandler"><span class="toc-number">1.3.</span> <span class="toc-text">RejectedExecutionHandler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-ThreadPoolExecutor-%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.</span> <span class="toc-text">自定义 ThreadPoolExecutor 实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadPoolExecutor-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8E%9F%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">ThreadPoolExecutor 运行时原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.1.</span> <span class="toc-text">线程池生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1%E6%B5%81%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">线程池提交任务流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%B0%83%E4%BC%98"><span class="toc-number">3.</span> <span class="toc-text">线程池调优</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tomcat%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">4.</span> <span class="toc-text">Tomcat线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">5.</span> <span class="toc-text">自定义设计实现一个线程池</span></a></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        java线程池实现
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">ares</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2025-07-13T11:03:24.000Z" class="dt-published" itemprop="datePublished">2025-07-13</time>
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/Java/">Java</a> › <a class="category-link" href="/categories/juc/">juc</a> › <a class="category-link" href="/categories/%E5%B9%B6%E5%8F%91/">并发</a> › <a class="category-link" href="/categories/%E7%BA%BF%E7%A8%8B%E6%B1%A0/">线程池</a>
    </div>


      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/Java/" rel="tag">Java</a>, <a class="p-category" href="/tags/juc/" rel="tag">juc</a>, <a class="p-category" href="/tags/%E5%B9%B6%E5%8F%91/" rel="tag">并发</a>, <a class="p-category" href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/" rel="tag">线程池</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <p>线程池 Thread Pool 是一种基于池化思想管理线程的工具，线程池维护多个线程，等待管理者分配可并发执行的任务：</p>
<ul>
<li>一方面避免了处理任务时创建销毁线程开销的代价，</li>
<li>另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。</li>
</ul>
<span id="more"></span>
<p>合理地使用线程池有如下优点：</p>
<ul>
<li><strong>降低资源消耗</strong>：通过重复利用已创建的线程降低线程创建和销毁造成的消耗；</li>
<li><strong>提高响应速度</strong>：当任务达到时，任务可以不需要等到线程创建就能立即执行；</li>
<li><strong>提高线程的可管理性</strong>：线程资源是稀缺的，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。</li>
</ul>
<h2 id="ThreadPoolExecutor基础与使用"><a href="#ThreadPoolExecutor基础与使用" class="headerlink" title="ThreadPoolExecutor基础与使用"></a>ThreadPoolExecutor基础与使用</h2><p>在java中 <strong>ThreadPoolExecutor</strong> 是核心的线程池实现，这个类实现了一个线程池需要的各个方法，它实现了任务提交、线程管理、监控等等方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>线程池核心参数</strong></p>
<ul>
<li><strong>corePoolSize</strong>：核心线程数。线程池在创建后，会一直保持这个数量的线程。当有任务提交时，如果当前运行的线程数小于corePoolSize，线程池会创建一个新的核心线程来执行任务。</li>
<li><strong>maximumPoolSize</strong>：最大线程数。线程池中允许创建的最大线程数。当工作队列已满，且当前运行的线程数小于maximumPoolSize时，线程池会创建新的非核心线程来执行任务。</li>
<li><strong>keepAliveTime</strong>：非核心线程空闲时间。当线程池中的线程数量超过corePoolSize时，如果某个线程空闲时间超过keepAliveTime，它就会被终止，直到线程数量回到corePoolSize。</li>
<li><strong>TimeUnit unit</strong>：keepAliveTime的时间单位。</li>
<li><strong>BlockingQueue workQueue</strong>：任务队列。当核心线程都在忙碌时，新提交的任务会被放入这个队列中等待执行。</li>
<li><strong>ThreadFactory threadFactory</strong>：线程工厂。用于创建新线程。</li>
<li><strong>RejectedExecutionHandler handler</strong>：拒绝策略。当线程池和工作队列都已满时，用于处理新任务的策略。</li>
</ul>
<h3 id="BlockingQueue阻塞队列"><a href="#BlockingQueue阻塞队列" class="headerlink" title="BlockingQueue阻塞队列"></a>BlockingQueue阻塞队列</h3><p>Java线程池（ThreadPoolExecutor）常用的几种阻塞队列类型如下：</p>
<ul>
<li><p>ArrayBlockingQueue</p>
<ul>
<li>实现：基于数组实现有界的阻塞队列，遵循 FIFO（先进先出）原则。</li>
<li>队列满时: 当队列已满，提交任务的线程会被阻塞，直到队列有可用空间。</li>
<li>公平性: 构造函数可选择是否启用公平策略。公平模式下，等待时间最长的线程优先获得队列访问权。</li>
<li>适用场景: 任务提交和处理速度都可控，需要限制等待任务数量以控制系统资源的场景。</li>
</ul>
</li>
<li><p>LinkedBlockingQueue</p>
<ul>
<li>实现：基于链表实现的可选有界（默认无界）的阻塞队列。</li>
<li>无界模式: 如果不指定容量，LinkedBlockingQueue 的最大容量为 Integer.MAX_VALUE。当核心线程数已满时，所有新任务都会进入此队列。由于队列无限大，永远不会触发最大线程数的创建，也不会执行拒绝策略。这可以防止任务被拒绝，但如果任务处理速度跟不上，可能导致内存溢出。</li>
<li>有界模式: 在构造时可指定容量，例如 new LinkedBlockingQueue&lt;&gt;(100)。此时，它类似于 ArrayBlockingQueue，在队列满时会阻塞生产者。</li>
<li>适用场景: 任务提交速度相对稳定，且任务量不会瞬间暴增，或者希望任务队列尽可能容纳所有任务的场景。</li>
</ul>
</li>
<li><p>SynchronousQueue：一个没有容量的阻塞队列，每次插入操作都必须等待另一个线程的移除操作。</p>
<ul>
<li>直接交付: 任务提交后不会被存储在队列中，而是直接交付给工作线程。如果没有空闲线程，会立即创建一个新线程（不超过 maximumPoolSize）来执行任务。</li>
<li>即时执行: 这种“手递手”的模式确保了任务提交后能被立即处理，但可能导致线程数快速增长。</li>
<li>适用场景: 高响应性要求，需要快速处理突发性任务，且 maximumPoolSize 足够大以避免拒绝任务的场景。newFixedThreadPool 和 newCachedThreadPool 在内部就使用了 SynchronousQueue。</li>
</ul>
</li>
<li><p><font color=red>LinkedTransferQueue：TransferQueue 接口的一个无界、非阻塞、线程安全的实现。</font></p>
<ul>
<li>融合了 SynchronousQueue 的即时传递特性和 LinkedBlockingQueue 的链表队列特性，并且使用 <strong>无锁（CAS操作）</strong> 的方式来最大化并发性能。</li>
<li>无界： 逻辑上无容量限制。</li>
<li>高效传输： 结合了 SynchronousQueue 的即时传输能力和 LinkedBlockingQueue 的队列能力，性能极高。transfer() 方法，生产者可以阻塞等待消费者接收，实现零缓冲区的同步交付。</li>
<li>适用场景：适用于需要低延迟、高并发消息传递的场景。</li>
</ul>
</li>
<li><p>PriorityBlockingQueue：一个无界的阻塞队列，其中元素根据其自然排序或指定的 Comparator 进行排序。</p>
<ul>
<li>优先级: 队列中的任务不是按照 FIFO 顺序执行，而是按照优先级顺序执行。</li>
<li>无界: 类似 LinkedBlockingQueue 的无界模式，maximumPoolSize 无效，且任务不会被拒绝，但可能导致内存问题。</li>
<li>适用场景: 需要根据任务的优先级来安排执行顺序，而不是简单的 FIFO 顺序的场景。</li>
</ul>
</li>
<li><p>DelayQueue（少用于线程池，但也是阻塞队列的一种）</p>
<ul>
<li>一个无界阻塞队列，只在元素的延迟时间到期时才允许取出元素。</li>
<li>延迟执行: 放入 DelayQueue 的元素必须实现 Delayed 接口，该接口定义了任务的延迟时间。只有当队列中的任务到期时，消费者才能取出并执行该任务。</li>
<li>适用场景: 需要延时执行任务的场景，例如定时任务调度、缓存过期清理等。</li>
</ul>
</li>
</ul>
<p><font color=blue>线程池最常用的是前三种：ArrayBlockingQueue、LinkedBlockingQueue 和 SynchronousQueue。可以通过ThreadPoolExecutor的构造函数自定义队列类型，实现不同的任务调度策略。</font></p>
<h4 id="基于LinkedTransferQueue实现ThreadPoolExecutor自定义队列："><a href="#基于LinkedTransferQueue实现ThreadPoolExecutor自定义队列：" class="headerlink" title="基于LinkedTransferQueue实现ThreadPoolExecutor自定义队列："></a><strong>基于LinkedTransferQueue实现ThreadPoolExecutor自定义队列：</strong></h4><p>LinkedTransferQueue 实现了一个基于链接节点的、线程安全的 TransferQueue 接口，该队列中的元素可以在生产者线程和消费者线程之间高效传输，LinkedTransferQueue 通常用于需要高效、线程安全的数据传输的场景，尤其是当生产和消费速率不一致时。</p>
<p>相较于SynchronousQueue，区别在于通用性、内部缓冲能力、并发实现方式:</p>
<ul>
<li>SynchronousQueue 是一个纯粹的握手（handoff）机制。它就像一个接力棒交换点，生产者扔出任务的同时，必须有消费者准备接住，否则双方都会阻塞。它永远不会在内部存储元素。如果需要一个简单的、高效的、零容量的线程间直接数据交换点时，例如 Executors.newCachedThreadPool() 的默认队列。</li>
<li><font color=red>LinkedTransferQueue则更灵活。如果调用 put() 或 offer() 方法，且当前没有等待的消费者，它会将元素像普通队列一样存储在内部链表中。只有在使用 transfer() 方法时，才会强制执行即时传递的阻塞行为。如果需要一个更通用的消息传递工具，它可以根据情况动态选择是即时传递（低延迟）还是排队缓冲（高吞吐量），并且需要极致的并发性能时。 </font></li>
</ul>
<p>和LinkedBlockingQueue相比，LinkedTransferQueue有更好的性能。LinkedTransferQueue采用 <strong>无锁（Lock-Free）</strong> 算法，完全依赖于底层的 CAS (Compare-And-Swap) 原子操作来更新链表节点和指针。这消除了锁带来的开销和竞争，尤其是在多核处理器环境下，性能通常远超 LinkedBlockingQueue。而LinkedBlockingQueue使用了两把独立的 ReentrantLock 锁 (takeLock 和 putLock) 来保护队列的头部和尾部。生产者和消费者可以在不同的锁下并行操作，例如，一个线程在添加元素到队尾，另一个线程在从队头移除元素，但在高并发生产者之间或高并发消费者之间仍然存在锁竞争。</p>
<ul>
<li>LinkedBlockingQueue: 适合传统的生产者-消费者模型，需要一个稳定的缓冲区来平衡不同生产&#x2F;消费速率的场景。它提供了容量控制（有界队列可以防止内存耗尽）。</li>
<li>LinkedTransferQueue: 适用于高性能的消息传递、事件驱动架构或需要低延迟同步通信的场景。它的无界特性意味着需要自行管理任务堆积导致的内存使用。下面是一个基于LinkedTransferQueue容量限制的队列实现：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WorkerQueue</span> <span class="keyword">extends</span> <span class="title class_">LinkedTransferQueue</span>&lt;Runnable&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> DefaultThreadPoolExecutor executor;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setExecutor</span><span class="params">(DefaultThreadPoolExecutor executor)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.executor = executor;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">force</span><span class="params">(Runnable o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!executor.isShutdown()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>(</span><br><span class="line">          <span class="string">&quot;Executor not running, can&#x27;t force a command into the queue&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.offer(o);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 仿tomcat TaskQueue</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(<span class="meta">@Nonnull</span> Runnable runnable)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">poolSize</span> <span class="operator">=</span> executor.getPoolSize();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当线程数达到最大线程数时，新提交任务入队</span></span><br><span class="line">    <span class="keyword">if</span> (poolSize == executor.getMaximumPoolSize()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">super</span>.offer(runnable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当提交的任务数小于线程池中已有的线程数时，即有空闲线程，任务入队即可</span></span><br><span class="line">    <span class="keyword">if</span> (executor.getSubmittedTasksCount().get() &lt;= poolSize) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">super</span>.offer(runnable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前线程数量未达到最大线程数，直接返回false，让线程池创建新线程</span></span><br><span class="line">    <span class="keyword">if</span> (poolSize &lt; executor.getMaximumPoolSize()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后的兜底，放入队列</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.offer(runnable);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ThreadFactory"><a href="#ThreadFactory" class="headerlink" title="ThreadFactory"></a>ThreadFactory</h3><p>ThreadFactory 表示线程工厂，用于指定为线程池创建新线程的方式，threadFactory可以设置线程名称、线程组、优先级等参数。在jdk中，ThreadFactory 是一个接口，在使用时需要自己实现，下面是一个自定义ThreadFactory实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultThreadFactory</span> <span class="keyword">implements</span> <span class="title class_">ThreadFactory</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">poolId</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">threadId</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String prefix;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">boolean</span> daemon;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> priority;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">DefaultThreadFactory</span><span class="params">(String name)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(name, <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">DefaultThreadFactory</span><span class="params">(String name, <span class="type">boolean</span> daemon)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(name, daemon, Thread.NORM_PRIORITY, <span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">DefaultThreadFactory</span><span class="params">(String name, <span class="type">boolean</span> daemon, ThreadGroup group)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>(name, daemon, Thread.NORM_PRIORITY, group);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">DefaultThreadFactory</span><span class="params">(String name, <span class="type">boolean</span> daemon, <span class="type">int</span> priority, ThreadGroup group)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.prefix = name + <span class="string">&quot;-&quot;</span> + poolId.incrementAndGet() + <span class="string">&quot;-thread-&quot;</span>;</span><br><span class="line">    <span class="built_in">this</span>.daemon = daemon;</span><br><span class="line">    <span class="built_in">this</span>.priority = priority;</span><br><span class="line">    <span class="built_in">this</span>.group = group;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Thread <span class="title function_">newThread</span><span class="params">(Runnable runnable)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(group, runnable, prefix + threadId.incrementAndGet(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (thread.isDaemon() != daemon) &#123;</span><br><span class="line">      thread.setDaemon(daemon);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (thread.getPriority() != priority) &#123;</span><br><span class="line">      thread.setPriority(priority);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> thread;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过实现ThreadFactory接口，我们可以完全控制线程的创建过程，使其更适合特定的应用场景：</p>
<ul>
<li>需要为线程池中的线程提供有意义的名称时。</li>
<li>需要统一配置线程属性时。</li>
<li>需要跟踪线程创建情况时。</li>
<li>需要为线程添加特殊的异常处理时。</li>
</ul>
<h3 id="RejectedExecutionHandler"><a href="#RejectedExecutionHandler" class="headerlink" title="RejectedExecutionHandler"></a>RejectedExecutionHandler</h3><p>Java 线程池 ThreadPoolExecutor 在无法处理新提交的任务时（即线程池已满，且工作队列也已满），会使用 RejectedExecutionHandler 定义的拒绝策略进行处理。Java提供了四种内置的拒绝策略，都在ThreadPoolExecutor.AbortPolicy等静态类中： </p>
<ul>
<li><p>AbortPolicy(中止策略)：</p>
<ul>
<li>默认策略。直接抛出 RejectedExecutionException 运行时异常，调用者线程可以捕获这个异常，并进行相应处理。</li>
<li>适用场景：<ul>
<li>关键任务场景： 当系统负载已满，且新任务非常重要，不允许被静默丢弃时。</li>
<li>快速失败： 需要立即感知到系统容量已满，并及时向上游反馈或记录日志。</li>
</ul>
</li>
</ul>
</li>
<li><p>CallerRunsPolicy：由提交任务的线程（调用者）自己来执行这个任务。</p>
<ul>
<li>不抛弃任务，而是将任务回退到调用该线程池的线程中执行。例如，在 main 线程提交任务，如果线程池满了，该任务就在 main 线程中执行。</li>
<li>适用场景：<ul>
<li>减缓生产速度： 当上游任务的生产者线程开始执行自己的任务时，它会被阻塞或减慢提交速度，从而实现了天然的“反压”（Backpressure）机制，平衡了系统的负载。</li>
<li><strong>保障任务不丢失</strong>： 确保每一个任务都会被执行，但会增加调用者线程的负担。</li>
</ul>
</li>
</ul>
</li>
<li><p>DiscardPolicy(丢弃策略)：</p>
<ul>
<li>默默地丢弃新提交的任务，不做任何处理，也不抛出异常。</li>
<li>适用场景：<ul>
<li>非关键任务：适用于那些不重要、丢失了也无妨的日志记录、统计信息收集等任务。</li>
<li>允许数据丢失的监控系统：在高并发场景下，少量数据丢失可以接受，以保障核心系统的稳定性。</li>
</ul>
</li>
</ul>
</li>
<li><p>DiscardOldestPolicy(丢弃最老策略)</p>
<ul>
<li>丢弃工作队列中等待时间最长的那个任务（队列头部的任务），然后尝试重新提交当前新任务。如果重新提交失败（例如队列还是满的或线程池已关闭），则继续尝试或失败。</li>
<li>适用场景：<ul>
<li>时效性任务： 适用于需要处理最新数据、而旧数据价值不大的场景（例如实时行情数据、传感器最新读数）。</li>
<li>保持队列最新： 确保队列中保存的任务具有较高的时效性。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>如果需要自定义丢弃策略可以实现 RejectedExecutionHandler 接口，创建自定义的拒绝逻辑：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CustomRejectedExecutionHandler</span> <span class="keyword">implements</span> <span class="title class_">RejectedExecutionHandler</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> &#123;</span><br><span class="line">    <span class="comment">// 在这里实现自定义逻辑，例如：记录日志、将任务保存到数据库或消息队列，稍后重试或发送邮件或告警通知</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Task Rejected: &quot;</span> + r.toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><font color=red>注意：在选择拒绝策略时，需要权衡任务的重要性、系统的稳定性和性能。</font></p>
<h3 id="自定义-ThreadPoolExecutor-实现"><a href="#自定义-ThreadPoolExecutor-实现" class="headerlink" title="自定义 ThreadPoolExecutor 实现"></a>自定义 ThreadPoolExecutor 实现</h3><ul>
<li>自定义WorkQueue - 前面基于 LinkedTransferQueue 实现有界队列</li>
<li>自定义ThreadFactory -  前面实现的 DefaultThreadFactory</li>
<li>自定义RejectedExecutionHandler - 前面的示例</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title class_">ThreadPoolExecutor</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXIMUM_POOL_SIZE</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">KEEP_ALIVE_TIME</span> <span class="operator">=</span> <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CORE_POOL_SIZE</span> <span class="operator">=</span> Runtime.getRuntime().availableProcessors() + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 正在处理的任务数</span></span><br><span class="line">  <span class="meta">@Getter</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">submittedTasksCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 最大允许同时处理的任务数</span></span><br><span class="line">  <span class="meta">@Getter</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">int</span> maxTask;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 其他构造方法省略</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">DefaultThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize, <span class="type">int</span> maximumPoolSize, <span class="type">int</span> queueCapacity,</span></span><br><span class="line"><span class="params">      <span class="type">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">      ThreadFactory threadFactory, RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);</span><br><span class="line">    ((WorkerQueue) getQueue()).setExecutor(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">this</span>.maxTask = maximumPoolSize + queueCapacity;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(<span class="meta">@Nonnull</span> Runnable command)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> submittedTasksCount.incrementAndGet();</span><br><span class="line">    <span class="comment">// 超过最大的并发任务限制，进行 reject</span></span><br><span class="line">    <span class="comment">// 依赖的LinkedTransferQueue没有长度限制，因此这里进行控制</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt; maxTask) &#123;</span><br><span class="line">      submittedTasksCount.decrementAndGet();</span><br><span class="line">      getRejectedExecutionHandler().rejectedExecution(command, <span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>.execute(command);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException rx) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!((WorkerQueue) getQueue()).force(command)) &#123;</span><br><span class="line">        submittedTasksCount.decrementAndGet();</span><br><span class="line">        getRejectedExecutionHandler().rejectedExecution(command, <span class="built_in">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> &#123;</span><br><span class="line">    submittedTasksCount.decrementAndGet();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DefaultThreadPoolExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultThreadPoolExecutor</span>(</span><br><span class="line">    <span class="number">10</span>, </span><br><span class="line">    <span class="number">30</span>, </span><br><span class="line">    <span class="number">60</span>,</span><br><span class="line">    <span class="number">60</span>, </span><br><span class="line">    TimeUnit.SECONDS,</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">WorkerQueue</span>(),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">DefaultThreadFactory</span>(<span class="string">&quot;test&quot;</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">CustomRejectedExecutionHandler</span>());</span><br><span class="line">executor.execute(()-&gt; System.out.println(<span class="string">&quot;test DefaultThreadPoolExecutor execute&quot;</span>));</span><br><span class="line">executor.submit(()-&gt; System.out.println(<span class="string">&quot;test DefaultThreadPoolExecutor submit&quot;</span>));</span><br></pre></td></tr></table></figure>

<h2 id="ThreadPoolExecutor-运行时原理"><a href="#ThreadPoolExecutor-运行时原理" class="headerlink" title="ThreadPoolExecutor 运行时原理"></a>ThreadPoolExecutor 运行时原理</h2><p><img src="/images/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86_ThreadPoolExecutor%E8%BF%90%E8%A1%8C%E6%97%B6%E6%9E%B6%E6%9E%84.png"></p>
<p>线程池在内部实际上构建了一个生产者消费者模型，将线程和任务两者解耦，并不直接关联，从而良好的缓冲任务，复用线程。线程池的运行主要分成两部分：任务管理、线程管理。</p>
<ul>
<li>任务管理部分充当生产者的角色，当任务提交后，线程池会判断该任务后续的流转：<ul>
<li>直接申请线程执行该任务；</li>
<li>缓冲到队列中等待线程执行；</li>
<li>拒绝该任务。</li>
</ul>
</li>
<li>线程管理部分是消费者，它们被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务的时候，线程就会被回收。</li>
</ul>
<h3 id="线程池生命周期"><a href="#线程池生命周期" class="headerlink" title="线程池生命周期"></a>线程池生命周期</h3><p><img src="/images/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86_%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png"></p>
<p>线程池运行的状态，并不是用户显式设置的，而是伴随着线程池的运行由内部维护。线程池内部使用一个 <code>32</code> 位的整数维护两个值：运行状态 <code>runState</code> 和线程数量 <code>workerCount</code> 两个参数维护在一起，其中高 <code>3</code> 位用于存放线程池状态，低 <code>29</code> 位表示线程数 <code>CAPACITY</code> 。用一个 <code>AtomicInteger</code> 变量存储来个值，可避免数据不一致问题，避免了锁的使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title class_">AbstractExecutorService</span> &#123;</span><br><span class="line">  <span class="comment">// 状态 RUNNING 线程数 = 0</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">AtomicInteger</span> <span class="variable">ctl</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="number">0</span>)); </span><br><span class="line">  <span class="comment">// 这里 COUNT_BITS 设置为 29(32-3)，意味着前三位用于存放线程状态，后29位用于存放线程数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> Integer.SIZE - <span class="number">3</span>;  </span><br><span class="line">  <span class="comment">// 最大容量（2^29 - 1 = 536870911）</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CAPACITY</span>   <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;  </span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 线程运行状态，总共有5个状态，需要3位来表示（所以偏移量的29 = 32 - 3）</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * RUNNING    :    接受新任务并且处理已经进入阻塞队列的任务</span></span><br><span class="line"><span class="comment">  * SHUTDOWN    ：    不接受新任务，但是处理已经进入阻塞队列的任务</span></span><br><span class="line"><span class="comment">  * STOP        :    不接受新任务，不处理已经进入阻塞队列的任务并且中断正在运行的任务</span></span><br><span class="line"><span class="comment">  * TIDYING    :    所有的任务都已经终止，workerCount为0， 线程转化为TIDYING状态并且调用terminated钩子函数</span></span><br><span class="line"><span class="comment">  * TERMINATED:    terminated钩子函数已经运行完成</span></span><br><span class="line"><span class="comment">  **/</span></span><br><span class="line">  <span class="comment">//111 00000000000000000000000000000</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RUNNING</span>    <span class="operator">=</span> -<span class="number">1</span> &lt;&lt; COUNT_BITS;  </span><br><span class="line">  <span class="comment">// 000 00000000000000000000000000000</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SHUTDOWN</span>   <span class="operator">=</span>  <span class="number">0</span> &lt;&lt; COUNT_BITS;  </span><br><span class="line">  <span class="comment">// 001 00000000000000000000000000000</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">STOP</span>       <span class="operator">=</span>  <span class="number">1</span> &lt;&lt; COUNT_BITS;  </span><br><span class="line">  <span class="comment">// 010 00000000000000000000000000000</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TIDYING</span>    <span class="operator">=</span>  <span class="number">2</span> &lt;&lt; COUNT_BITS;  </span><br><span class="line">  <span class="comment">// 011 00000000000000000000000000000</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">TERMINATED</span> <span class="operator">=</span>  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">  <span class="comment">// 将CAPACITY取非后和c进行取与运算，可以得到高3位的值，即线程池的状态</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">runStateOf</span><span class="params">(<span class="type">int</span> c)</span>     &#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125; </span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将c和CAPACITY取与运算，可以得到低29位的值，即线程池的个数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">workerCountOf</span><span class="params">(<span class="type">int</span> c)</span>  &#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ctlOf</span><span class="params">(<span class="type">int</span> rs, <span class="type">int</span> wc)</span> &#123; <span class="keyword">return</span> rs | wc; &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由源码可以看到，Java 线程池（ThreadPoolExecutor）有五种状态，由一个名为 ctl 的 AtomicInteger 变量进行管理:<br><strong>RUNNING（运行中）</strong></p>
<ul>
<li>状态描述: 线程池的初始状态，也是正常工作状态。</li>
<li>行为: 接受新提交的任务，并处理任务队列中的任务。</li>
<li>状态切换: 线程池创建后即处于 RUNNING 状态。</li>
</ul>
<p><strong>SHUTDOWN（关闭）</strong></p>
<ul>
<li>状态描述: 线程池进入温和的关闭状态。</li>
<li>行为: 不再接受新的任务，但会继续处理任务队列中已有的任务，直到所有任务都执行完毕。</li>
<li>状态切换: 调用 shutdown() 方法会使线程池进入 SHUTDOWN 状态。</li>
</ul>
<p><strong>STOP（停止）</strong></p>
<ul>
<li>状态描述: 线程池进入强制关闭状态。</li>
<li>行为: 不再接受新任务，不处理任务队列中剩余的任务，并且会中断所有正在执行的任务。</li>
<li>状态切换: 调用 shutdownNow() 方法会使线程池进入 STOP 状态。</li>
</ul>
<p><strong>TIDYING（整理）</strong></p>
<ul>
<li>状态描述: 线程池处于资源清理阶段，所有任务都已终止，工作线程数也已变为0。</li>
<li>行为: 在该状态下，会执行 terminated() 钩子方法，进行最后的清理工作。</li>
<li>状态切换:<ul>
<li>从 SHUTDOWN 状态进入：当任务队列为空且线程池中的工作线程数为0时。</li>
<li>从 STOP 状态进入：当线程池中的工作线程数为0时。</li>
</ul>
</li>
</ul>
<p><strong>TERMINATED（终止）</strong></p>
<ul>
<li>状态描述: 线程池已彻底终止。</li>
<li>行为: 线程池中的所有任务都已处理完毕，所有工作线程都已退出，terminated() 方法也已执行完成。</li>
<li>状态切换: 从 TIDYING 状态进入。</li>
</ul>
<h3 id="线程池提交任务流程"><a href="#线程池提交任务流程" class="headerlink" title="线程池提交任务流程"></a>线程池提交任务流程</h3><p><img src="/images/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86_ThreadPoolExecutor%E4%BB%BB%E5%8A%A1%E6%8F%90%E4%BA%A4%E6%B5%81%E7%A8%8B.png"></p>
<p>上图中，当一个任务通过execute()或submit()方法提交给ThreadPoolExecutor时，它会遵循以下步骤：</p>
<ul>
<li>检查核心线程数：如果当前运行的线程数少于corePoolSize，线程池会立刻创建一个新的核心线程来执行任务。</li>
<li>进入任务队列：如果当前运行的线程数已达到corePoolSize，任务会被放入workQueue中排队等待。</li>
<li>创建非核心线程：如果队列已满，但当前运行的线程数小于maximumPoolSize，线程池会创建新的非核心线程来处理队列中的任务。</li>
<li>执行拒绝策略：如果线程数已达到maximumPoolSize且队列已满，线程池会根据预设的handler（拒绝策略）来处理这个新任务。</li>
<li>线程复用：当一个工作线程执行完任务后，它不会被销毁，而是会从任务队列中循环获取下一个任务并执行。如果这个线程是非核心线程，并且空闲时间超过keepAliveTime，它才会被终止。</li>
</ul>
<h2 id="线程池调优"><a href="#线程池调优" class="headerlink" title="线程池调优"></a>线程池调优</h2><p>配置线程池的线程数没有一成不变的规则，它主要取决于<strong>任务类型（是CPU密集型还是I&#x2F;O密集型）和服务器的硬件资源（如CPU核心数）</strong>。<br><strong>核心考量因素</strong></p>
<ul>
<li>任务类型：CPU密集型 vs I&#x2F;O密集型<ul>
<li><strong>CPU密集型任务</strong>：这类任务需要大量CPU计算，比如复杂的数学运算、图像处理等。它们会持续占用CPU，如果线程数远大于CPU核心数，会造成频繁的线程上下文切换，反而降低性能。</li>
<li><strong>I&#x2F;O密集型任务</strong>：这类任务需要频繁地进行磁盘读写、网络通信等I&#x2F;O操作。当一个线程在等待I&#x2F;O时，它会释放CPU，让其他线程有机会执行。因此，可以配置较多的线程数以充分利用CPU的空闲时间。</li>
</ul>
</li>
<li>服务器硬件资源：CPU核心数可以通过 <code>Runtime.getRuntime().availableProcessors()</code> 方法获取当前服务器的CPU核心数。这是配置线程池大小的重要参考值。</li>
</ul>
<p><strong>线程池大小配置策略</strong><br><strong>CPU密集型任务</strong>：对于CPU密集型任务，线程池的最佳大小应该等于或略大于CPU核心数。</p>
<ul>
<li>推荐大小：CPU核心数 + 1</li>
<li>原因：多出的一个线程可以防止因偶尔的页缺失或其它系统中断而导致的CPU空闲，确保CPU始终处于忙碌状态。</li>
</ul>
<p><strong>I&#x2F;O密集型任务</strong>：对于I&#x2F;O密集型任务，线程池可以配置得更大一些，因为线程在等待I&#x2F;O操作时不会消耗CPU。</p>
<ul>
<li>推荐公式：CPU核心数 * (1 + 任务等待时间 &#x2F; 任务计算时间)</li>
<li>计算等待时间与计算时间比率（Blocking Coefficient）：这个比率需要通过性能测试和监控来估算。例如，如果任务的等待时间是计算时间的5倍，那么比率就是5，<font color=red>如果难以获取精确比率，一个经验值是 2 * CPU核心数</font>。</li>
<li>注意事项：过多的线程数也会导致内存消耗和上下文切换增加，因此需要进行基准测试和监控来找到最佳平衡点。</li>
</ul>
<p><strong>混合型任务</strong>：如果线程池中包含CPU密集型和I&#x2F;O密集型两种任务，最佳实践是：</p>
<ul>
<li>拆分线程池：为不同类型的任务创建独立的线程池，然后根据各自的特性进行配置。</li>
<li>优点：<ul>
<li>避免互相影响：I&#x2F;O密集型任务的阻塞不会影响CPU密集型任务的执行。</li>
<li>便于调优：可以针对性地调整不同线程池的参数。</li>
</ul>
</li>
</ul>
<p>如果需要动态调整ThreadPoolExecutor参数，可以通过对应参数的 set 方法进行操作，set相关的方法是线程安全的，如setMaximumPoolSize(int maximumPoolSize)。但需要注意的是 LinkedBlockingQueue 的容量通常无法动态修改，并且动态参数调整可能会影响正在执行的任务。</p>
<h2 id="Tomcat线程池"><a href="#Tomcat线程池" class="headerlink" title="Tomcat线程池"></a>Tomcat线程池</h2><p><img src="/images/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86_tomcat%E6%9E%B6%E6%9E%84.png"></p>
<p>Tomcat 的整体架构包含连接器和容器两大部分，其中连接器负责与外部通信，容器负责内部逻辑处理。在连接器中：</p>
<ul>
<li>使用 ProtocolHandler 接口来封装I&#x2F;O模型和应用层协议的差异，其中I&#x2F;O模型可以选择非阻塞I&#x2F;O、异步I&#x2F;O或APR，应用层协议可以选择HTTP、HTTPS或AJP。ProtocolHandler将I&#x2F;O模型和应用层协议进行组合，让EndPoint只负责字节流的收发，Processor负责将字节流解析为Tomcat Request&#x2F;Response对象，实现功能模块的高内聚和低耦合，ProtocolHandler接口继承关系如下图示。</li>
<li>通过适配器 Adapter 将Tomcat Request对象转换为标准的ServletRequest对象。</li>
</ul>
<p>在Tomcat中，通过AbstractEndpoint类提供底层的网络I&#x2F;O的处理，若用户没有配置自定义公共线程池，则AbstractEndpoint通过createExecutor方法来创建Tomcat默认线程池。其中，TaskQueue、ThreadPoolExecutor分别为Tomcat自定义任务队列、线程池实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">  internalExecutor = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (getUseVirtualThreads()) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> <span class="title class_">VirtualThreadExecutor</span>(getName() + <span class="string">&quot;-virt-&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="type">TaskQueue</span> <span class="variable">taskqueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskQueue</span>(maxQueueSize);</span><br><span class="line">      <span class="type">TaskThreadFactory</span> <span class="variable">tf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TaskThreadFactory</span>(getName() + <span class="string">&quot;-exec-&quot;</span>, daemon, getThreadPriority());</span><br><span class="line">      executor = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(getMinSpareThreads(), getMaxThreads(), getThreadsMaxIdleTime(),</span><br><span class="line">              TimeUnit.MILLISECONDS, taskqueue, tf);</span><br><span class="line">      taskqueue.setParent((ThreadPoolExecutor) executor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<p>Tomcat自定义线程池继承于java.util.concurrent. ThreadPoolExecutor，并新增了一些成员变量来更高效地统计已经提交但尚未完成的任务数量（submittedCount），包括已经在队列中的任务和已经交给工作线程但还未开始执行的任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">      maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">      maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">      keepAliveTime &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (workQueue == <span class="literal">null</span> || threadFactory == <span class="literal">null</span> || handler == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">  <span class="built_in">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">  <span class="built_in">this</span>.workQueue = workQueue;</span><br><span class="line">  <span class="built_in">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">  <span class="built_in">this</span>.threadFactory = threadFactory;</span><br><span class="line">  <span class="built_in">this</span>.handler = handler;</span><br><span class="line"></span><br><span class="line">  prestartAllCoreThreads();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Tomcat在自定义线程池ThreadPoolExecutor中重写了execute()方法，并实现对提交执行的任务进行submittedCount加一。Tomcat在自定义ThreadPoolExecutor中，当线程池抛出RejectedExecutionException异常后，会调用force()方法再次向TaskQueue中进行添加任务的尝试。如果添加失败，则submittedCount减一后，再抛出RejectedExecutionException。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span> &#123;</span><br><span class="line">  submittedCount.incrementAndGet();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    executeInternal(command);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (RejectedExecutionException rx) &#123;</span><br><span class="line">    <span class="keyword">if</span> (getQueue() <span class="keyword">instanceof</span> TaskQueue) &#123;</span><br><span class="line">      <span class="comment">// If the Executor is close to maximum pool size, concurrent</span></span><br><span class="line">      <span class="comment">// calls to execute() may result (due to Tomcat&#x27;s use of</span></span><br><span class="line">      <span class="comment">// TaskQueue) in some tasks being rejected rather than queued.</span></span><br><span class="line">      <span class="comment">// If this happens, add them to the queue.</span></span><br><span class="line">      <span class="keyword">final</span> <span class="type">TaskQueue</span> <span class="variable">queue</span> <span class="operator">=</span> (TaskQueue) getQueue();</span><br><span class="line">      <span class="keyword">if</span> (!queue.force(command)) &#123;</span><br><span class="line">          submittedCount.decrementAndGet();</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>(sm.getString(<span class="string">&quot;threadPoolExecutor.queueFull&quot;</span>));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      submittedCount.decrementAndGet();</span><br><span class="line">      <span class="keyword">throw</span> rx;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在Tomcat中重新定义了一个阻塞队列TaskQueue，它继承于LinkedBlockingQueue。在Tomcat中，核心线程数默认值为10，最大线程数默认为200，为了避免线程到达核心线程数后后续任务放入队列等待，Tomcat通过自定义任务队列TaskQueue重写offer方法实现了核心线程池数达到配置数后线程的创建。具体地，从线程池任务调度机制实现可知，当offer方法返回false时，线程池将尝试创建新新线程，从而实现任务的快速响应。TaskQueue核心实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TaskQueue</span> <span class="keyword">extends</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">ThreadPoolExecutor</span> <span class="variable">parent</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">TaskQueue</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">TaskQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>(capacity);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">TaskQueue</span><span class="params">(Collection&lt;? extends Runnable&gt; c)</span> &#123;</span><br><span class="line">      <span class="built_in">super</span>(c);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setParent</span><span class="params">(ThreadPoolExecutor tp)</span> &#123;</span><br><span class="line">      parent = tp;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Used to add a task to the queue if the task has been rejected by the Executor.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> o         The task to add to the queue</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span>          &#123;<span class="doctag">@code</span> true&#125; if the task was added to the queue,</span></span><br><span class="line"><span class="comment">   *                      otherwise &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">force</span><span class="params">(Runnable o)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (parent == <span class="literal">null</span> || parent.isShutdown()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RejectedExecutionException</span>(sm.getString(<span class="string">&quot;taskQueue.notRunning&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//forces the item onto the queue, to be used if the task is rejected</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.offer(o); </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(Runnable o)</span> &#123;</span><br><span class="line">    <span class="comment">//we can&#x27;t do any checks</span></span><br><span class="line">    <span class="comment">//forces the item onto the queue, to be used if the task is rejected</span></span><br><span class="line">    <span class="comment">// 1. parent为线程池，Tomcat中为自定义线程池实例</span></span><br><span class="line">    <span class="keyword">if</span> (parent==<span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.offer(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 当线程数达到最大线程数时，新提交任务入队</span></span><br><span class="line">    <span class="comment">//we are maxed out on threads, simply queue the object</span></span><br><span class="line">    <span class="keyword">if</span> (parent.getPoolSizeNoLock() == parent.getMaximumPoolSize()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.offer(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 当提交的任务数小于线程池中已有的线程数时，即有空闲线程，任务入队即可</span></span><br><span class="line">    <span class="comment">//we have idle threads, just add it to the queue</span></span><br><span class="line">    <span class="keyword">if</span> (parent.getSubmittedCount() &lt;= parent.getPoolSizeNoLock()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.offer(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4. 【关键点】如果当前线程数量未达到最大线程数，直接返回false，让线程池创建新线程</span></span><br><span class="line">      <span class="comment">//if we have less threads than maximum force creation of a new thread</span></span><br><span class="line">    <span class="keyword">if</span> (parent.getPoolSizeNoLock() &lt; parent.getMaximumPoolSize()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 最后的兜底，放入队列</span></span><br><span class="line">    <span class="comment">//if we reached here, we need to add it to the queue</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">super</span>.offer(o);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Runnable <span class="title function_">poll</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">          <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="built_in">super</span>.poll(timeout, unit);</span><br><span class="line">      <span class="keyword">if</span> (runnable == <span class="literal">null</span> &amp;&amp; parent != <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// the poll timed out, it gives an opportunity to stop the current</span></span><br><span class="line">          <span class="comment">// thread if needed to avoid memory leaks.</span></span><br><span class="line">          parent.stopCurrentThreadIfNeeded();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> runnable;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Runnable <span class="title function_">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      <span class="keyword">if</span> (parent != <span class="literal">null</span> &amp;&amp; parent.currentThreadShouldBeStopped()) &#123;</span><br><span class="line">          <span class="keyword">return</span> poll(parent.getKeepAliveTime(TimeUnit.MILLISECONDS),</span><br><span class="line">                  TimeUnit.MILLISECONDS);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">super</span>.take();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自定义设计实现一个线程池"><a href="#自定义设计实现一个线程池" class="headerlink" title="自定义设计实现一个线程池"></a>自定义设计实现一个线程池</h2><p>一个线程池的核心是一个生产者-消费者模型：</p>
<ul>
<li>生产者（任务提交者）：向线程池提交任务。</li>
<li>缓冲区（任务队列）：存储待执行的任务，使用阻塞队列实现线程安全。</li>
<li>消费者（工作线程）：不断从任务队列中取出任务并执行。</li>
</ul>
<p><strong>实现思路</strong></p>
<ul>
<li><p><strong>生产者-消费者模型</strong>：execute 方法是生产者，将 Runnable 任务放入 BlockingQueue（任务队列）。WorkerThread 是消费者，从队列中取出任务并执行。</p>
</li>
<li><p><strong>BlockingQueue 的选择</strong>：使用 BlockingQueue（如 LinkedBlockingQueue）来处理线程安全问题。它天生支持阻塞式地“放入”（put）和“取出”（take&#x2F;poll）。</p>
</li>
<li><p><strong>Worker 线程的生命周期</strong>：WorkerThread 的 run() 方法是一个核心循环。</p>
<ul>
<li>通过调用 getTask() 来获取任务。</li>
<li>getTask() 必须使用带超时的 poll(timeout)，而不是 take()。如果使用 take()，当调用 shutdown()（优雅关闭）时，如果队列为空，工作线程将永远阻塞在 take()，导致线程池无法终止。使用 poll(timeout) 允许线程在超时后醒来，重新检查 state 变量，从而在 state &#x3D;&#x3D; SHUTDOWN 且队列为空时安全退出。</li>
</ul>
</li>
<li><p><strong>volatile 状态</strong>：使用 volatile int state 来管理线程池的状态（RUNNING, SHUTDOWN, STOP）。volatile 保证了当一个线程（例如调用 shutdown() 的主线程）修改 state 时，所有其他工作线程都能立即看到这个变化。</p>
</li>
<li><p><strong>shutdown() vs shutdownNow()：</strong></p>
<ul>
<li>shutdown()：将状态设为 SHUTDOWN。getTask() 方法检测到此状态后，会继续处理队列中剩余的任务，但一旦队列为空，getTask() 将返回 null，导致 WorkerThread 退出。</li>
<li>shutdownNow()：将状态设为 STOP，并调用所有 worker.interrupt()。正在 poll() 或 sleep() 的线程会抛出 InterruptedException。getTask() 捕获此异常后返回 null，导致线程立即退出。</li>
</ul>
</li>
</ul>
<p><strong>一个简单的实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">LinkedBlockingQueue</span> <span class="variable">taskQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>();</span><br><span class="line">  <span class="keyword">private</span> <span class="type">AtomicBoolean</span> <span class="variable">running</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">submitTask</span><span class="params">(Object task)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">      taskQueue.put(task);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(running.get()) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有任务，会使线程阻塞，一旦有任务，会被唤醒</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">task</span> <span class="operator">=</span> taskQueue.take(); </span><br><span class="line">        doSomething(task);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(running.compareAndSet(<span class="literal">true</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">      System.out.println(Thread.currentThread() + <span class="string">&quot; is stoped&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">(Object task)</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">首页</a></li>
        
          <li><a href="/archives/">归档</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadPoolExecutor%E5%9F%BA%E7%A1%80%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-number">1.</span> <span class="toc-text">ThreadPoolExecutor基础与使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#BlockingQueue%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">1.1.</span> <span class="toc-text">BlockingQueue阻塞队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8ELinkedTransferQueue%E5%AE%9E%E7%8E%B0ThreadPoolExecutor%E8%87%AA%E5%AE%9A%E4%B9%89%E9%98%9F%E5%88%97%EF%BC%9A"><span class="toc-number">1.1.1.</span> <span class="toc-text">基于LinkedTransferQueue实现ThreadPoolExecutor自定义队列：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadFactory"><span class="toc-number">1.2.</span> <span class="toc-text">ThreadFactory</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RejectedExecutionHandler"><span class="toc-number">1.3.</span> <span class="toc-text">RejectedExecutionHandler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-ThreadPoolExecutor-%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.</span> <span class="toc-text">自定义 ThreadPoolExecutor 实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadPoolExecutor-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8E%9F%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">ThreadPoolExecutor 运行时原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.1.</span> <span class="toc-text">线程池生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1%E6%B5%81%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">线程池提交任务流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%B0%83%E4%BC%98"><span class="toc-number">3.</span> <span class="toc-text">线程池调优</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tomcat%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">4.</span> <span class="toc-text">Tomcat线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">5.</span> <span class="toc-text">自定义设计实现一个线程池</span></a></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2025/07/13/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2025/07/13/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/&text=java线程池实现"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2025/07/13/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/&title=java线程池实现"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2025/07/13/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/&is_video=false&description=java线程池实现"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=java线程池实现&body=Check out this article: http://example.com/2025/07/13/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2025/07/13/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/&title=java线程池实现"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2025/07/13/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/&title=java线程池实现"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2025/07/13/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/&title=java线程池实现"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2025/07/13/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/&title=java线程池实现"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2025/07/13/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/&name=java线程池实现&description=&lt;p&gt;线程池 Thread Pool 是一种基于池化思想管理线程的工具，线程池维护多个线程，等待管理者分配可并发执行的任务：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一方面避免了处理任务时创建销毁线程开销的代价，&lt;/li&gt;
&lt;li&gt;另一方面避免了线程数量膨胀导致的过分调度问题，保证了对内核的充分利用。&lt;/li&gt;
&lt;/ul&gt;"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2025/07/13/java-juc-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86/&t=java线程池实现"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2023-2025
    ares
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->


 
  <link
    rel="preload"
    href="/lib/font-awesome/css/all.min.css"
    as="style"
    onload="this.onload=null;this.rel='stylesheet'"
  />
  <noscript
    ><link
      rel="stylesheet"
      href="/lib/font-awesome/css/all.min.css"
  /></noscript>


    <!-- jquery -->

  
<script src="/lib/jquery/jquery.min.js"></script>





<!-- clipboard -->

  
    
<script src="/lib/clipboard/clipboard.min.js"></script>

  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
