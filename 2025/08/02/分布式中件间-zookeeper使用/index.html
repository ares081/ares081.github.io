

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="ares">
  <meta name="keywords" content="">
  
    <meta name="description" content="Zookeeper 是一个开源的分布式协调框架，基于ZAB协议来确保在分布式环境下的数据一致性和可靠性，实现了一个高可用的、小型的、树形结构（类似文件系统）的数据存储。通常用于分布式系统中的配置管理、同步服务、命名服务等，Zookeeper 主要用于以下几种场景：  分布式锁：通过 Zookeeper 提供的节点机制，可以实现分布式环境中的锁机制。 配置管理：Zookeeper 用作分布式系统的配">
<meta property="og:type" content="article">
<meta property="og:title" content="分布式中件间-zookeeper使用">
<meta property="og:url" content="http://example.com/2025/08/02/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E4%BB%B6%E9%97%B4-zookeeper%E4%BD%BF%E7%94%A8/index.html">
<meta property="og:site_name" content="Ares&#39;s Notes">
<meta property="og:description" content="Zookeeper 是一个开源的分布式协调框架，基于ZAB协议来确保在分布式环境下的数据一致性和可靠性，实现了一个高可用的、小型的、树形结构（类似文件系统）的数据存储。通常用于分布式系统中的配置管理、同步服务、命名服务等，Zookeeper 主要用于以下几种场景：  分布式锁：通过 Zookeeper 提供的节点机制，可以实现分布式环境中的锁机制。 配置管理：Zookeeper 用作分布式系统的配">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-08-02T14:33:24.000Z">
<meta property="article:modified_time" content="2025-11-24T03:36:05.835Z">
<meta property="article:author" content="ares">
<meta property="article:tag" content="中间件">
<meta property="article:tag" content="分布式">
<meta property="article:tag" content="架构">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>分布式中件间-zookeeper使用 - Ares&#39;s Notes</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":"§"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":"G-RL5NX8NL9X"},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.1.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Ares&#39;s Notes</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">分布式中件间-zookeeper使用</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-08-02 22:33" pubdate>
          2025年8月2日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          20k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          164 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">分布式中件间-zookeeper使用</h1>
            
            
              <div class="markdown-body">
                
                <p>Zookeeper 是一个开源的分布式协调框架，基于ZAB协议来确保在分布式环境下的数据一致性和可靠性，实现了一个高可用的、小型的、树形结构（类似文件系统）的数据存储。通常用于分布式系统中的配置管理、同步服务、命名服务等，Zookeeper 主要用于以下几种场景：</p>
<ul>
<li>分布式锁：通过 Zookeeper 提供的节点机制，可以实现分布式环境中的锁机制。</li>
<li>配置管理：Zookeeper 用作分布式系统的配置中心，客户端可以从 Zookeeper 获取共享的配置信息。</li>
<li>命名服务：Zookeeper 可以作为一个高效的命名服务，提供唯一的命名空间。</li>
<li>集群管理：Zookeeper 可以用来管理分布式系统中节点的健康状况和成员变更。</li>
</ul>
<span id="more"></span>
<h2 id="zookeeper客户端"><a href="#zookeeper客户端" class="headerlink" title="zookeeper客户端"></a>zookeeper客户端</h2><p>在 Java 生态中，有多种 ZooKeeper 客户端可供选择。主要包括 ZooKeeper 官方原生客户端、以及两个流行的第三方开源客户端 ZkClient 和 Apache Curator。目前在生产环境中最被推荐和广泛使用的是 Apache Curator。 </p>
<table>
<thead>
<tr>
<th align="left">客户端</th>
<th align="left">优点</th>
<th align="left">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>官方原生客户端：Zookeeper</strong></td>
<td align="left">官方支持，最基础的 API</td>
<td align="left">API 复杂、功能简单，需要手动处理连接丢失、Watcher（观察者）一次性注册等问题，不推荐在生产环境直接使用</td>
</tr>
<tr>
<td align="left"><strong>ZkClient</strong></td>
<td align="left">对原生 API 进行了封装，提供了更简洁的 API</td>
<td align="left">社区不活跃，文档不完善，异常处理简化（抛出 RuntimeException），重试机制较难用</td>
</tr>
<tr>
<td align="left"><strong>Apache Curator</strong></td>
<td align="left">简化了 ZooKeeper 的复杂性，提供了高级 API、连接管理、重试机制、各种分布式场景的抽象封装（如分布式锁、领导选举）</td>
<td align="left">学习曲线相对复杂（相比 ZkClient）</td>
</tr>
</tbody></table>
<h3 id="官方原生客户端：Zookeeper"><a href="#官方原生客户端：Zookeeper" class="headerlink" title="官方原生客户端：Zookeeper"></a>官方原生客户端：Zookeeper</h3><p>ZooKeeper 的官方原生 Java 客户端库<strong>org.apache.zookeeper</strong>虽然功能基础，但提供了所有与 ZooKeeper 服务端交互的核心接口和类，实现了建立、管理连接和执行所有数据操作。下面是ZookKeeper的其中一个构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ZooKeeper</span><span class="hljs-params">(String connectString, <span class="hljs-type">int</span> sessionTimeout, Watcher watcher)</span>&#123;&#125;<br><br></code></pre></td></tr></table></figure>
<ul>
<li>connectString: 集群地址列表（如 “host1:2181,host2:2181”）。</li>
<li>sessionTimeout: 会话超时时间（毫秒），ZooKeeper 依赖心跳来维持会话，超时后会话失效，临时节点将被删除。</li>
<li>watcher: 默认的全局 Watcher，用于处理连接状态变化等事件。</li>
</ul>
<p>ZooKeeper增删改的核心方法如下：</p>
<ul>
<li><p>create：用于创建节点，可以指定节点路径、节点数据、节点的访问权限、节点类型</p>
</li>
<li><p>delete：删除节点，每个节点都有一个版本，删除时可指定删除的版本，类似乐观锁。设置-1，则就直接删除节点。</p>
</li>
<li><p>exists：节点存不存在，若存在返回节点Stat信息，否则返回null。</p>
</li>
<li><p>getChildren：获取子节点。</p>
</li>
<li><p>getData&#x2F;setData：获取&#x2F;设置节点数据。</p>
</li>
<li><p>getACL&#x2F;setACL：获取节点访问权限列表，每个节点都可以设置访问权限，指定只有特定的客户端才能访问和操作节点。ACL说明：</p>
<ul>
<li>Ids.CREATOR_ALL_ACL：只有创建节点的客户端才有所有权限</li>
<li>Ids.OPEN_ACL_UNSAFE：这是一个完全开放的权限，所有客户端都有权限</li>
<li>Ids.READ_ACL_UNSAFE：所有客户端只有读取的</li>
</ul>
</li>
<li><p>close：关闭连接并终止会话。</p>
</li>
</ul>
<p>Watcher 接口（事件监听）：org.apache.zookeeper.Watcher 是处理 ZooKeeper 客户端事件的核心接口。ZooKeeper 的设计原则是“一次性通知”（One-time trigger），即一个 Watcher 只能监听一次事件，事件触发后就需要重新注册。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 监控所有被触发的事件处理</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(WatchedEvent event)</span>;<br></code></pre></td></tr></table></figure>
<p>在使用时可以通过实现 <strong>process(WatchedEvent event)</strong> 来做一些自定义处理逻辑与Watcher重新注册。WatchedEvent 包含事件的所有信息：</p>
<ul>
<li>EventType: 事件类型（如 NodeCreated, NodeDeleted, NodeDataChanged, NodeChildrenChanged）。</li>
<li>KeeperState: 客户端连接状态（如 SyncConnected, Disconnected, Expired）。</li>
<li>getPath(): 发生事件的 ZNode 路径。</li>
</ul>
<p>Stat元数据类：org.apache.zookeeper.data.Stat 类用于存储 ZNode 的所有元数据（Metadata），例如版本号、创建&#x2F;修改时间等。在调用 getData() 或 exists() 方法时，该对象会被填充。重要的属性包括：</p>
<ul>
<li>czxid: 创建 ZNode 的事务 ID。</li>
<li>mzxid: 最后修改 ZNode 数据的事务 ID。</li>
<li>version: 数据的版本号。</li>
<li>cversion: 子节点列表的版本号。</li>
<li>dataLength: 数据长度。</li>
</ul>
<p>AsyncCallback 接口（异步操作回调）：原生客户端支持同步（Synchronous）和异步（Asynchronous）两种 API。当使用异步方法时（方法名通常以 Async 结尾），需要实现 AsyncCallback 接口来处理操作完成后的结果。常见的子接口：</p>
<ul>
<li>DataCallback: 用于 getData 异步操作。</li>
<li>StatCallback: 用于 exists 异步操作。</li>
<li>VoidCallback: 用于 delete 异步操作。</li>
<li>StringCallback: 用于 create 异步操作。</li>
<li>ChildrenCallback: 用于 getChildren 异步操作。</li>
</ul>
<p>基于原生客户端实现同步队列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用原生 zookeeper api</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Watcher</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(Sync.class);<br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> ZooKeeper zookeeper;<br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> String root;<br>  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">mutex</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><br><br>  Sync(String addr, String root) <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-built_in">this</span>.zookeeper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZooKeeper</span>(addr, <span class="hljs-number">3000</span>, <span class="hljs-built_in">this</span>);<br>    <span class="hljs-built_in">this</span>.root = root;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(WatchedEvent watchedEvent)</span> &#123;<br>    logger.info(watchedEvent.toString());<br>    <span class="hljs-keyword">synchronized</span> (mutex) &#123;<br>      mutex.notify();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">static</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Queue</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br><br>    Queue(String address, String root) <span class="hljs-keyword">throws</span> IOException, InterruptedException, KeeperException &#123;<br>      <span class="hljs-built_in">super</span>(address, root);<br>      <span class="hljs-keyword">if</span> (zookeeper == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;zookeeper is null&quot;</span>);<br>      &#125;<br><br>      <span class="hljs-type">Stat</span> <span class="hljs-variable">stat</span> <span class="hljs-operator">=</span> zookeeper.exists(root, <span class="hljs-literal">false</span>);<br>      <span class="hljs-keyword">if</span> (stat == <span class="hljs-literal">null</span>) &#123;<br>        zookeeper.create(root, <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">0</span>], Ids.OPEN_ACL_UNSAFE,<br>            CreateMode.PERSISTENT);<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">produce</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> <span class="hljs-keyword">throws</span> InterruptedException, KeeperException &#123;<br>      <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">4</span>);<br>      <span class="hljs-type">byte</span>[] value;<br>      b.putInt(i);<br>      value = b.array();<br>      zookeeper.create(root + <span class="hljs-string">&quot;/element&quot;</span>, value, Ids.OPEN_ACL_UNSAFE,<br>          CreateMode.PERSISTENT_SEQUENTIAL);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">consume</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> KeeperException, InterruptedException &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">retvalue</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>      <span class="hljs-type">Stat</span> <span class="hljs-variable">stat</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>      <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">synchronized</span> (mutex) &#123;<br>          List&lt;String&gt; list = zookeeper.getChildren(root, <span class="hljs-literal">true</span>);<br>          <span class="hljs-keyword">if</span> (list.isEmpty()) &#123;<br>            logger.info(<span class="hljs-string">&quot;consumer going to wait&quot;</span>);<br>            mutex.wait();<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> Integer.parseInt(list.get(<span class="hljs-number">0</span>).substring(<span class="hljs-number">7</span>));<br>            <span class="hljs-type">String</span> <span class="hljs-variable">minNode</span> <span class="hljs-operator">=</span> list.get(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">for</span> (String s : list) &#123;<br>              <span class="hljs-type">int</span> <span class="hljs-variable">tempValue</span> <span class="hljs-operator">=</span> Integer.parseInt(s.substring(<span class="hljs-number">7</span>));<br>              <span class="hljs-keyword">if</span> (tempValue &lt; min) &#123;<br>                min = tempValue;<br>                minNode = s;<br>              &#125;<br>            &#125;<br>            logger.info(<span class="hljs-string">&quot;Temporary value: &#123;&#125;/&#123;&#125;&quot;</span>, root, minNode);<br>            <span class="hljs-type">byte</span>[] b = zookeeper.getData(root + <span class="hljs-string">&quot;/&quot;</span> + minNode, <span class="hljs-literal">false</span>, stat);<br>            zookeeper.delete(root + <span class="hljs-string">&quot;/&quot;</span> + minNode, <span class="hljs-number">0</span>);<br>            <span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.wrap(b);<br>            retvalue = buffer.getInt();<br>            <span class="hljs-keyword">return</span> retvalue;<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>原生客户端的使用流程通常如下：</p>
<ul>
<li>创建 ZooKeeper 实例，传入全局 Watcher。</li>
<li>等待连接建立（SyncConnected 状态）。</li>
<li>执行操作（create, getData 等），并根据需要注册临时的 Watcher。</li>
<li>处理 KeeperException 异常。</li>
<li>处理 Watcher 事件（并在需要时重新注册 Watcher）。</li>
<li>调用 close() 结束会话。</li>
</ul>
<p>由于需要手动管理连接状态和 Watcher 的重复注册，原生客户端使用起来相对繁琐，这也是 Apache Curator 等第三方客户端流行的原因。</p>
<h3 id="Apache-Curator5-7"><a href="#Apache-Curator5-7" class="headerlink" title="Apache Curator5.7"></a>Apache Curator5.7</h3><p>Apache Curator 是 Netflix 开源并贡献给 Apache 基金会的 ZooKeeper 客户端框架，它极大地简化了 ZooKeeper 的使用，提供了许多强大的特性来解决原生客户端的痛点。使用原生Zookeeper客户端时存在着如下几个问题：</p>
<ul>
<li>连接丢失（ConnectionLossException）后不会自动重连。</li>
<li>会话过期（Session Expired）后，需要手动关闭旧客户端、重新创建新客户端、并恢复所有瞬时（EPHEMERAL）节点和 Watcher。</li>
<li>开发者必须手动编写复杂的重试逻辑。</li>
<li>Watcher 是“一次性”的（One-time trigger）。事件触发后立即失效，如果需要持续监听，必须在处理完事件后立即重新注册 Watcher。这个过程容易出错，且在并发场景下可能导致遗漏事件。</li>
<li>原生 API 方法参数多，使用复杂，代码冗长。例如，create(path, data, acl, mode) 需要同时指定 ACL 和模式，不够直观。</li>
<li>原生客户端只提供最基本的原语（如创建节点、删除节点），实现分布式锁、领导选举等高级功能需要开发者自己设计复杂的算法，并手动处理各种竞争条件和边界情况。</li>
</ul>
<p>Curator 框架解决了原生客户端的使用问题，其核心特性可以概括为以下几点：</p>
<ul>
<li><p><strong>健壮的连接管理和重试机制：</strong></p>
<ul>
<li><p>连接状态监听： Curator 提供了一个 ConnectionStateListener，可以方便地监听连接状态的变化（CONNECTED, SUSPENDED, RECONNECTED, LOST）。</p>
</li>
<li><p>自动重连与重试策略： 内置了强大的重试机制（Retry Policy），如 ExponentialBackoffRetry（指数退避重试）。当出现连接丢失、操作失败等情况时，Curator 会自动根据策略进行重试，极大地简化了错误处理。重试策略：</p>
<ul>
<li>ExponentialBackoffRetry：指数退避重试（推荐）。</li>
<li>RetryNTimes：重试固定次数。</li>
<li>RetryUntilStopped：一直重试直到停止。</li>
</ul>
</li>
<li><p>会话管理： 自动处理会话过期后的恢复逻辑，透明地重建临时节点和重新注册 Watcher。</p>
</li>
</ul>
</li>
<li><p><strong>简化的 API 和 Fluent 风格</strong>：Curator 使用了现代化的链式调用（Fluent API）设计模式，使得代码更简洁、可读性更高，相比原生客户端冗长的方法签名，Curator 提供了更直观的接口。</p>
</li>
<li><p><strong>高级 Watcher 封装（缓存机制）</strong>：Curator 解决了原生客户端 Watcher“一次性触发”的痛点，提供了持久化和缓存功能。</p>
<ul>
<li>持久化 Watcher（Persistent Watcher）： Curator 提供了高级接口，这些接口会自动管理 Watcher 的注册和重新注册。</li>
<li>事件缓存： *Cache 等组件不仅监听事件，还会缓存节点数据，使得应用程序能够及时获取最新的节点状态，而无需每次都去 ZooKeeper 服务端拉取数据。</li>
</ul>
</li>
<li><p><strong>内置的 Recipes（分布式协调组件）</strong>：这是 Curator 最受欢迎的特性，它将常见的 ZooKeeper 使用场景抽象成了可以直接使用的组件。</p>
<ul>
<li>分布式锁（Distributed Locks）：InterProcessMutex、InterProcessSemaphoreMutex、InterProcessReadWriteLock。</li>
<li>领导选举（Leader Election）： LeaderSelector 组件，允许多个客户端竞争领导权，并在当前领导者宕机时自动进行新的选举。</li>
<li>分布式计数器（Distributed Counter）： 提供了线程安全的分布式计数器实现。</li>
<li>服务发现（Service Discovery）： 提供了构建服务注册与发现系统的框架和工具。</li>
<li>分布式队列&#x2F;屏障： DistributedQueue、DistributedBarrier 等。</li>
</ul>
</li>
<li><p><strong>Zookeeper 2 风格的集成（Testing Server）</strong>：Curator 提供了 TestingServer 和 TestingCluster 类，使得在单元测试和集成测试中启动一个嵌入式的 ZooKeeper 实例变得非常简单，极大地提高了开发和测试效率。</p>
</li>
</ul>
<p>综上，Curator 是目前 Java 生态中最成熟、最稳定的 ZooKeeper 客户端，它将复杂的底层交互封装成了一套易于使用、且经过生产验证的 API 和组件。</p>
<h4 id="Curator-核心组件"><a href="#Curator-核心组件" class="headerlink" title="Curator 核心组件"></a>Curator 核心组件</h4><p>Curator 框架的核心设计围绕几个关键组件和接口展开，它们协同工作，提供了健壮且易于使用的 ZooKeeper 客户端功能。Curator 的核心组件主要有：</p>
<ul>
<li><p><strong>CuratorFramework (核心接口)</strong>：CuratorFramework 是 Curator 框架的主要接口，代表了客户端与 ZooKeeper 集群的连接会话，是所有操作的起点。 它是与 ZooKeeper 服务端通信的门面（Facade），封装了连接管理、重试机制、会话状态监听以及数据操作的所有逻辑。通常使用 CuratorFrameworkFactory 的构建者模式来创建实例。</p>
</li>
<li><p><strong>RetryPolicy (重试策略)</strong>：RetryPolicy 是一个接口，定义了当 ZooKeeper 操作失败时（例如网络波动导致连接丢失）客户端应如何重试的规则，实现了自动化的错误恢复机制，避免开发者手动编写复杂的重试逻辑。</p>
</li>
<li><p><strong>ConnectionStateListener (连接状态监听器)</strong>：这个监听器用于监控 CuratorFramework 实例与 ZooKeeper 集群的连接状态。使用时应用程序可以对连接状态的变化做出反应，例如会话挂起、重新连接或完全丢失。关键状态有：</p>
<ul>
<li>CONNECTED：首次成功连接或重新连接成功。</li>
<li>SUSPENDED：连接丢失，但会话可能仍然有效（在超时时间内）。</li>
<li>RECONNECTED：连接从挂起状态恢复。</li>
<li>LOST：会话超时，连接永久丢失（临时节点会被删除），需要重新建立一个新的 CuratorFramework 实例。</li>
</ul>
</li>
<li><p><strong>CuratorCache (原 TreeCache 等缓存组件)</strong>：Curator 3.x 以后引入了 CuratorCache，整合了早期版本中的 NodeCache、PathChildrenCache 和 TreeCache 的功能。实现了本地缓存和持久化 Watcher 功能，在本地维护 ZNode 结构和数据的最新副本，并自动处理 Watcher 的重新注册，确保不错过任何事件。使用时可以直接从本地缓存获取数据，减少与 ZooKeeper 服务端的网络往返，同时简化了事件监听的复杂性。</p>
</li>
<li><p>Recipes (高级功能组件)：Recipes 并非一个单一的接口或类，而是一系列预构建的高级协调组件，基于 ZooKeeper 原语（如临时有序节点）实现分布式系统的通用模式，为复杂的分布式协调任务提供了即插即用的解决方案。</p>
</li>
</ul>
<h4 id="Curator核心方法"><a href="#Curator核心方法" class="headerlink" title="Curator核心方法"></a>Curator核心方法</h4><p>客户端生命周期管理：</p>
<ul>
<li>start(): 启动客户端实例并连接到 ZooKeeper 服务端。这是执行任何操作之前的必须步骤。</li>
<li>close(): 关闭连接，释放所有资源，并终止会话。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">CuratorFramework</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> CuratorFrameworkFactory<br>      .newClient(<span class="hljs-string">&quot;localhost:2181&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ExponentialBackoffRetry</span>(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>));<br>client.start();<br><br>client.close();<br></code></pre></td></tr></table></figure>

<p>数据操作核心方法：</p>
<ul>
<li><p>create()：用于在 ZooKeeper 中创建 ZNode。可以通过链式方法指定节点的类型（持久、临时、有序）和数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java">client.create()<br>      .withMode(CreateMode.EPHEMERAL)  <span class="hljs-comment">// 指定节点类型（如 CreateMode.EPHEMERAL 临时节点）。</span><br>      .compress(compressor) <span class="hljs-comment">// 压缩数据（可选）。</span><br>      .forPath(<span class="hljs-string">&quot;/path/to/ephemeral/node&quot;</span>, <span class="hljs-string">&quot;data&quot;</span>.getBytes()); <span class="hljs-comment">//指定路径和要存储的数据，执行操作。</span><br></code></pre></td></tr></table></figure></li>
<li><p>getData()：开始获得ZNode节点数据的操作，可以调用额外的方法(监控、后台处理或者获取状态watch, background or get stat) 并在最后调用forPath()指定要操作的ZNode。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">byte</span>[] data = client.getData()<br>                    .storingStatsIn(stat) <span class="hljs-comment">// 将节点的元数据存储到提供的 Stat 对象中（可选）。</span><br>                    .watched()                 <span class="hljs-comment">// 注册一个一次性的 Watcher 或者使用：usingWatcher(Watcher watcher)，通常使用缓存替代</span><br>                    .forPath(<span class="hljs-string">&quot;/path/to/node&quot;</span>); <span class="hljs-comment">// 指定路径和新数据，执行操作。</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>setData()：用于更新 ZNode 中的数据。可以通过指定版本号实现乐观锁，防止并发修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java">client.setData()<br>      .withVersion(-<span class="hljs-number">1</span>)    <span class="hljs-comment">// 定期望的数据版本号（可选，默认为 -1，表示匹配任何版本）。</span><br>      .forPath(<span class="hljs-string">&quot;/path/to/node&quot;</span>, <span class="hljs-string">&quot;newData&quot;</span>.getBytes()); <span class="hljs-comment">// 指定路径和新数据，执行操作。</span><br></code></pre></td></tr></table></figure></li>
<li><p>delete()：用于删除 ZNode。可以指定版本号，也可以递归删除子节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java">client.delete()<br>      .withVersion(<span class="hljs-type">int</span> version)   <span class="hljs-comment">// 指定版本号（可选）</span><br>      .guaranteed()               <span class="hljs-comment">// 保证删除成功。即使客户端连接丢失，Curator 也会在后台持续重试，直到节点被删除。</span><br>      .deletingChildrenIfNeeded() <span class="hljs-comment">// 如果节点有子节点，则递归删除（原生客户端不支持）。</span><br>      .forPath(<span class="hljs-string">&quot;/path/to/node&quot;</span>);  <span class="hljs-comment">// 指定路径，执行操作。</span><br></code></pre></td></tr></table></figure></li>
<li><p>getChildren()：用于获取某个 ZNode 下的所有子节点名称列表。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">List&lt;String&gt; children = client.getChildren().forPath(<span class="hljs-string">&quot;/path/to/parent&quot;</span>);<br></code></pre></td></tr></table></figure></li>
<li><p>checkExists()：检查节点是否存在，返回 Stat 对象（存在）或 null（不存在）。</p>
</li>
<li><p>inTransaction()：开始是原子ZooKeeper事务. 可以复合create, setData, check, and&#x2F;or delete 等操作然后调用commit()作为一个原子操作提交</p>
</li>
</ul>
<h4 id="Curator事件监听"><a href="#Curator事件监听" class="headerlink" title="Curator事件监听"></a>Curator事件监听</h4><p>在 Curator 中，事件监听主要通过 CuratorCache 缓存组件实现，这些组件内部封装了对 ZooKeeper 原生 Watcher 的使用，并提供了更友好、更强大的事件模型，解决了Watcher<strong>一次性注册、触发即失效</strong>的问题。在Curator中事件监听的两种方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-comment">// 使用：CuratorListener</span><br>client.getCuratorListenable()<br>      .addListener((curatorFramework, curatorEvent) -&gt; System.out.println(<span class="hljs-string">&quot;事件： &quot;</span> + curatorEvent));<br><br><span class="hljs-comment">// 使用：Watcher</span><br>client.getChildren()<br>      .usingWatcher((Watcher) watchedEvent -&gt; System.out.println(<span class="hljs-string">&quot;监听： &quot;</span> + watchedEvent)).forPath(<span class="hljs-string">&quot;/cache&quot;</span>);<br></code></pre></td></tr></table></figure>
<p>CuratorListenable中CuratorEventType触发返回的数据如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs text">事件类型         事件返回数据<br>CREATE          getResultCode() and getPath()<br>DELETE          getResultCode() and getPath()<br>EXISTS          getResultCode(), getPath() and getStat()<br>GET_DATA        getResultCode(), getPath(), getStat() and getData()<br>SET_DATA        getResultCode(), getPath() and getStat()<br>CHILDREN        getResultCode(), getPath(), getStat(), getChildren()<br>SYNC            getResultCode(), getStat()<br>GET_ACL         getResultCode(), getACLList()<br>SET_ACL         getResultCode()<br>TRANSACTION     getResultCode(), getOpResults()<br>WATCHED         getWatchedEvent()<br>GET_CONFIG      getResultCode(), getData()<br>RECONFIG        getResultCode(), getData()<br></code></pre></td></tr></table></figure>

<p>Curator提供了如下几个策略:</p>
<ul>
<li>ExponentialBackoffRetry:重试一定次数，每次重试sleep更多的时间</li>
<li>RetryNTimes:重试N次</li>
<li>RetryOneTime:重试一次</li>
<li>RetryUntilElapsed:重试一定的时间</li>
</ul>
<h2 id="服务注册与发现-curator-x-discovery"><a href="#服务注册与发现-curator-x-discovery" class="headerlink" title="服务注册与发现 - curator-x-discovery"></a>服务注册与发现 - curator-x-discovery</h2><p>curator-x-discovery 是 Apache Curator 库的一个扩展组件，专门用于在分布式系统中实现服务注册与发现功能。它构建在 ZooKeeper 之上，提供了一套高级 API，简化了使用 ZooKeeper 进行服务管理的复杂性。</p>
<p>curator-x-discovery 核心功能：<br><strong>服务注册 (Service Registration)</strong>：服务注册是指将一个服务实例的信息（如服务名、地址、端口、健康状态等）发布到 Zookeeper 集群中。Curator-X-Discovery 利用 Zookeeper 的节点来存储这些信息，每个服务实例在注册时会创建一个临时节点（ephemeral node）。这些节点只要对应的服务实例还在运行，就会存在；当实例下线或不可用时，Zookeeper 会自动删除这些节点。服务注册信息通常包含 <strong>服务名称（例如 service_name）、服务地址（如 IP 或主机名）和其他元数据</strong>。使用方法：discovery.registerService(instance)。</p>
<p><strong>服务发现 (Service Discovery)</strong>：服务发现是指让客户端能够查询到已注册的服务实例的位置，从而进行调用。Curator-X-Discovery 使用 Zookeeper 中的目录结构（路径）来组织服务。例如，&#x2F;services&#x2F;<service_name> 下的每个节点代表一个服务实例。通过监听 Zookeeper 节点的变化来实现服务的动态发现。当一个服务实例被注册或移除时，客户端能够接收到通知，自动更新可用服务列表。discovery.queryForInstances(serviceName);</p>
<p><strong>负载均衡策略 (Provider Strategies)</strong>：Curator-X-Discovery 还可以与负载均衡机制配合使用，确保客户端能够均匀地分配请求到不同的服务实例。通过 ServiceInstance（服务实例）类，Curator 可以将多个服务节点的信息提供给客户端，客户端可以选择不同的服务实例进行负载均衡。内置的负载均衡策略：</p>
<ul>
<li>RandomStrategy</li>
<li>RoundRobinStrategy</li>
<li>StickyStrategy</li>
</ul>
<p><strong>健康检查 (Health Checking)</strong>：为了确保服务的健康状态，Curator-X-Discovery 可以通过 Zookeeper 节点的 TTL（生存时间）机制来实现健康检查。同时，通过设置心跳机制或定期检查服务实例的健康状态，确保服务实例是可用的。当服务失效时，相关的临时节点会被清除，系统会自动剔除不可用的服务。</p>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>服务注册与发现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ZkRegistry</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Registry</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ServiceDiscovery&lt;ServiceMeta&gt; discovery;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ZkRegistry</span><span class="hljs-params">(RegistryProperties properties)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">CuratorFramework</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> CuratorFrameworkFactory.newClient(properties.getRegisterAddress(),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExponentialBackoffRetry</span>(properties.getSleepTime(), properties.getMaxRetries()));<br>    client.start();<br><br>    JsonInstanceSerializer&lt;ServiceMeta&gt; serializer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">JsonInstanceSerializer</span>&lt;&gt;(ServiceMeta.class);<br>    <span class="hljs-built_in">this</span>.discovery = ServiceDiscoveryBuilder.builder(ServiceMeta.class)<br>        .client(client)<br>        .serializer(serializer)<br>        .basePath(<span class="hljs-string">&quot;/&quot;</span> + properties.getNamespace())<br>        .build();<br>    <span class="hljs-built_in">this</span>.discovery.start();<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(ServiceMeta serviceMeta)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    ServiceInstance&lt;ServiceMeta&gt; instance = ServiceInstance.&lt;ServiceMeta&gt;builder()<br>        .name(buildNamespace(serviceMeta.getGroup(), serviceMeta.getApplication(),<br>            serviceMeta.getVersion()))<br>        .address(serviceMeta.getHost())<br>        .port(serviceMeta.getPort())<br>        .payload(serviceMeta)<br>        .build();<br>    discovery.registerService(instance);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unregister</span><span class="hljs-params">(ServiceMeta serviceMeta)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    ServiceInstance&lt;ServiceMeta&gt; serviceInstance = ServiceInstance<br>        .&lt;ServiceMeta&gt;builder()<br>        .name(buildNamespace(serviceMeta.getGroup(), serviceMeta.getApplication(),<br>            serviceMeta.getVersion()))<br>        .address(serviceMeta.getHost())<br>        .port(serviceMeta.getPort())<br>        .payload(serviceMeta)<br>        .build();<br>    discovery.unregisterService(serviceInstance);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> ServiceMeta <span class="hljs-title function_">lookup</span><span class="hljs-params">(String group, String serviceName,</span><br><span class="hljs-params">      String version, <span class="hljs-type">int</span> hashCode)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br>    Collection&lt;ServiceInstance&lt;ServiceMeta&gt;&gt; instances = discovery<br>        .queryForInstances(buildNamespace(group, serviceName, version));<br><br>    ServiceInstance&lt;ServiceMeta&gt; instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConsistentHashLoadBalancer</span>()<br>        .select((List&lt;ServiceInstance&lt;ServiceMeta&gt;&gt;) instances, hashCode);<br><br>    <span class="hljs-keyword">if</span> (instance != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> instance.getPayload();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> String <span class="hljs-title function_">buildNamespace</span><span class="hljs-params">(String group, String application, String version)</span> &#123;<br>    <span class="hljs-keyword">return</span> group + <span class="hljs-string">&quot;#&quot;</span> + application + <span class="hljs-string">&quot;#&quot;</span> + version;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>负载均衡策略：这里自定义实现ConsistentHash</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsistentHashLoadBalancer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">LoadBalancer</span>&lt;ServiceInstance&lt;ServiceMeta&gt;&gt; &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">VIRTUAL_NODE_SPLIT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;#&quot;</span>;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-variable">VIRTUAL_NODE_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> ServiceInstance&lt;ServiceMeta&gt; <span class="hljs-title function_">select</span><span class="hljs-params">(List&lt;ServiceInstance&lt;ServiceMeta&gt;&gt; instances,</span><br><span class="hljs-params">      <span class="hljs-type">int</span> hashCode)</span> &#123;<br>    <span class="hljs-keyword">if</span> (instances == <span class="hljs-literal">null</span> || instances.isEmpty()) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    TreeMap&lt;Integer, ServiceInstance&lt;ServiceMeta&gt;&gt; circle = buildConsistentHashRing(instances);<br>    <span class="hljs-keyword">return</span> allocateNode(circle, hashCode);<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> ServiceInstance&lt;ServiceMeta&gt; <span class="hljs-title function_">allocateNode</span><span class="hljs-params">(</span><br><span class="hljs-params">      TreeMap&lt;Integer, ServiceInstance&lt;ServiceMeta&gt;&gt; circle, <span class="hljs-type">int</span> hashCode)</span> &#123;<br>    Map.Entry&lt;Integer, ServiceInstance&lt;ServiceMeta&gt;&gt; entry = circle.ceilingEntry(hashCode);<br>    <span class="hljs-keyword">if</span> (entry == <span class="hljs-literal">null</span>) &#123;<br>      entry = circle.firstEntry();<br>    &#125;<br>    <span class="hljs-keyword">return</span> entry.getValue();<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> TreeMap&lt;Integer, ServiceInstance&lt;ServiceMeta&gt;&gt; <span class="hljs-title function_">buildConsistentHashRing</span><span class="hljs-params">(</span><br><span class="hljs-params">      List&lt;ServiceInstance&lt;ServiceMeta&gt;&gt; servers)</span> &#123;<br>    TreeMap&lt;Integer, ServiceInstance&lt;ServiceMeta&gt;&gt; ring = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (ServiceInstance&lt;ServiceMeta&gt; instance : servers) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; VIRTUAL_NODE_SIZE; i++) &#123;<br>        ring.put((buildServiceInstanceKey(instance) + VIRTUAL_NODE_SPLIT + i).hashCode(), instance);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ring;<br>  &#125;<br><br>  <span class="hljs-keyword">private</span> String <span class="hljs-title function_">buildServiceInstanceKey</span><span class="hljs-params">(ServiceInstance&lt;ServiceMeta&gt; instance)</span> &#123;<br>    <span class="hljs-type">ServiceMeta</span> <span class="hljs-variable">payload</span> <span class="hljs-operator">=</span> instance.getPayload();<br>    <span class="hljs-keyword">return</span> String.join(<span class="hljs-string">&quot;:&quot;</span>, payload.getHost(), String.valueOf(payload.getPort()));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>上面更标准的做法是实现 curator-x-discovery内置 ProviderStrategy 接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsistentHashStrategy</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ProviderStrategy</span>&lt;T&gt; &#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> ServiceInstance&lt;T&gt; <span class="hljs-title function_">getInstance</span><span class="hljs-params">(InstanceProvider&lt;T&gt; instance)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 这里实现</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>  <span class="hljs-type">RegistryProperties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegistryProperties</span>();<br>  properties.setNamespace(<span class="hljs-string">&quot;test&quot;</span>);<br>  properties.setMaxRetries(<span class="hljs-number">5</span>);<br>  properties.setSleepTime(<span class="hljs-number">1000</span>);<br>  properties.setRegisterAddress(<span class="hljs-string">&quot;127.0.0.1:2181&quot;</span>);<br><br>  <span class="hljs-type">ZkRegistry</span> <span class="hljs-variable">registry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZkRegistry</span>(properties);<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">11</span>; i++) &#123;<br>    <span class="hljs-type">ServiceMeta</span> <span class="hljs-variable">serviceMeta</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceMeta</span>();<br>    serviceMeta.setApplication(<span class="hljs-string">&quot;order-service&quot;</span>);<br>    serviceMeta.setGroup(<span class="hljs-string">&quot;A&quot;</span>);<br>    serviceMeta.setVersion(<span class="hljs-string">&quot;1.0&quot;</span>);<br>    serviceMeta.setHost(<span class="hljs-string">&quot;192.168.0.&quot;</span> + i);<br>    serviceMeta.setPort(<span class="hljs-number">8080</span>);<br>    registry.register(serviceMeta);<br>  &#125;<br><br>  <span class="hljs-type">ServiceMeta</span> <span class="hljs-variable">meta</span> <span class="hljs-operator">=</span> registry.lookup(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;order-service&quot;</span>, <span class="hljs-string">&quot;1.0&quot;</span>, <span class="hljs-number">2126277029</span>);<br>  System.out.println(meta.getApplication() + <span class="hljs-string">&quot;#&quot;</span> + meta.getHost() + <span class="hljs-string">&quot;:&quot;</span> + meta.getPort());<br>  <span class="hljs-type">ServiceMeta</span> <span class="hljs-variable">meta1</span> <span class="hljs-operator">=</span> registry.lookup(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;order-service&quot;</span>, <span class="hljs-string">&quot;1.0&quot;</span>, <span class="hljs-number">113466687</span>);<br>  System.out.println(meta1.getApplication() + <span class="hljs-string">&quot;#&quot;</span> + meta1.getHost() + <span class="hljs-string">&quot;:&quot;</span> + meta1.getPort());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>小结：<br>Curator-X-Discovery 提供了一种基于 Zookeeper 的服务注册与发现机制，简化了与 Zookeeper 的交互。它的工作原理是通过 Zookeeper 的临时节点、目录结构和监听机制来实现服务的动态注册、发现以及健康检查。通过使用 Curator 库，开发者可以更容易地实现一个高可用、动态可扩展的分布式服务发现系统。</p>
<h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>Apache Curator 提供的分布式锁实现主要依赖于 ZooKeeper 的 <strong>临时顺序节点（Ephemeral Sequential Nodes）</strong> 特性，其核心原理是<strong>利用 ZooKeeper 保证数据一致性、强顺序性和高可用的特点，模拟出一个分布式环境下的“公平锁”</strong>。以下两个特性是实现分布式锁的关键点：</p>
<ul>
<li>临时节点 (Ephemeral): 锁持有者与 ZooKeeper 的会话断开后，该节点会自动删除，从而避免死锁。</li>
<li>顺序节点 (Sequential): 每次创建的子节点都会有一个全局唯一的、单调递增的序号，这保证了锁的公平性（先到先得）。</li>
</ul>
<p>Curator 提供了如下几种类型的分布式锁：</p>
<ul>
<li>InterProcessMutex：可重入的排他锁（最常用）</li>
<li>InterProcessSemaphoreMutex：不可重入的排他锁</li>
<li>InterProcessReadWriteLock：读写锁（包含读锁和写锁）</li>
<li>InterProcessMultiLock：组合多个锁为一个逻辑锁</li>
</ul>
<h3 id="加锁过程"><a href="#加锁过程" class="headerlink" title="加锁过程"></a>加锁过程</h3><ul>
<li>创建锁根节点: Curator 会指定一个持久节点作为所有锁的父节点（例如 &#x2F;locks&#x2F;mylock），这个节点需要预先存在。</li>
<li>创建临时顺序子节点: 客户端 A 在父节点下创建一个子节点，例如 &#x2F;locks&#x2F;mylock&#x2F;lock-0000000001。</li>
<li>获取子节点列表: 客户端 A 读取父节点 &#x2F;locks&#x2F;mylock 下的所有当前子节点列表，并按序号升序排序。</li>
<li>判断是否为最小节点: 客户端 A 检查自己创建的节点是否是当前列表中序号最小的那个节点。<ul>
<li>如果是: 说明客户端 A 成功获取到锁。它可以执行临界区代码。</li>
<li>如果不是: 说明前面有其他客户端正在等待或持有锁。客户端 A 不能获取锁。</li>
</ul>
</li>
<li>监听前一个节点: 客户端 A 找到列表中位于它前面的那个节点（例如 &#x2F;locks&#x2F;mylock&#x2F;lock-0000000000），并给这个节点设置一个 ZooKeeper Watcher（监听器），然后进入等待状态。</li>
</ul>
<h3 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DistributeLock</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AutoCloseable</span>&#123;<br>  <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> Exception;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ZkDistributeLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DistributeLock</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicBoolean</span> <span class="hljs-variable">locked</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicBoolean</span>(<span class="hljs-literal">false</span>);<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> InterProcessMutex lock;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-title function_">ZkDistributeLock</span><span class="hljs-params">(CuratorProperties properties)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">CuratorFramework</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> CuratorFrameworkFactory.builder()<br>        .connectString(properties.getAddress())<br>        .connectionTimeoutMs(properties.getConnectionTimeout())<br>        .sessionTimeoutMs(properties.getSessionTimeout())<br>        .retryPolicy(<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExponentialBackoffRetry</span>(properties.getSleepTime(), properties.getMaxRetries()))<br>        .build();<br>    client.start();<br>    <span class="hljs-built_in">this</span>.lock = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterProcessMutex</span>(client, properties.getBasePath() + <span class="hljs-string">&quot;/inter-mutex&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">if</span> (timeout &gt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-type">boolean</span> <span class="hljs-variable">acquired</span> <span class="hljs-operator">=</span> lock.acquire(timeout, unit);<br>      <span class="hljs-keyword">if</span> (acquired) &#123;<br>        locked.compareAndSet(<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      lock.acquire();<br>      locked.compareAndSet(<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> locked.get();<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">releaseLock</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">if</span> (locked.compareAndSet(<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>)) &#123;<br>      lock.release();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    releaseLock();<br>  &#125;<br><br>  <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isLocked</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> locked.get();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>客户端使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ZkLockExample</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">CuratorProperties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CuratorProperties</span>();<br>    properties.setBasePath(<span class="hljs-string">&quot;/locks&quot;</span>);<br>    properties.setAddress(<span class="hljs-string">&quot;127.0.0.1:2181&quot;</span>);<br>    properties.setSessionTimeout(<span class="hljs-number">10000</span>);<br>    properties.setConnectionTimeout(<span class="hljs-number">1000</span>);<br>    properties.setMaxRetries(<span class="hljs-number">3</span>);<br>    properties.setSleepTime(<span class="hljs-number">3000</span>);<br>    <span class="hljs-comment">// try-with-resource 自动 release</span><br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">ZkDistributeLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZkDistributeLock</span>(properties)) &#123;<br>      lock.tryLock(<span class="hljs-number">3000</span>, TimeUnit.MILLISECONDS);<br>    &#125;<br><br>    <span class="hljs-comment">// 手动release</span><br>    <span class="hljs-type">ZkDistributeLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZkDistributeLock</span>(properties);<br>    <span class="hljs-keyword">try</span> &#123;<br>      lock.tryLock(<span class="hljs-number">3000</span>, TimeUnit.MILLISECONDS);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>      lock.releaseLock();<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Curator 提供的分布式锁实现基于 ZooKeeper 的临时顺序节点，通过监听节点删除事件实现锁的获取与释放，保证了分布式环境下的可靠性和公平性。不过，需要注意的是，ZooKeeper 的性能限制可能影响系统的扩展性，尤其是在高并发场景下。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%9E%B6%E6%9E%84/" class="category-chain-item">架构</a>
  
  

      </span>
    
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%88%86%E5%B8%83%E5%BC%8F/" class="category-chain-item">分布式</a>
  
  

      </span>
    
  
    
      <span class="category-chain">
        
  <a href="/categories/%E4%B8%AD%E9%97%B4%E4%BB%B6/" class="category-chain-item">中间件</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E6%9E%B6%E6%9E%84/" class="print-no-link">#架构</a>
      
        <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/" class="print-no-link">#分布式</a>
      
        <a href="/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/" class="print-no-link">#中间件</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>分布式中件间-zookeeper使用</div>
      <div>http://example.com/2025/08/02/分布式中件间-zookeeper使用/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>ares</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年8月2日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/08/07/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E9%97%B4%E4%BB%B6-%E5%9F%BA%E4%BA%8Ezookeeper%E5%AE%9E%E7%8E%B0%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/" title="分布式中件间-基于zookeeper实现配置中心">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">分布式中件间-基于zookeeper实现配置中心</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/08/02/%E5%88%86%E5%B8%83%E5%BC%8F%E4%B8%AD%E4%BB%B6%E9%97%B4-zookeeper%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/" title="分布式中件间-zookeeper原理分析">
                        <span class="hidden-mobile">分布式中件间-zookeeper原理分析</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  



  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});

    Fluid.utils.listenDOMLoaded(function() {
      Fluid.events.registerRefreshCallback(function() {
        if ('mermaid' in window) {
          mermaid.init();
        }
      });
    });
  });
</script>






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
