

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=dark>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="ares">
  <meta name="keywords" content="">
  
    <meta name="description" content="概述在上篇中介绍了响应式编程基础，其中提到在JDK中只提供了接口规范，并没有提供丰富的操作算子。而 Project Reactor就是基于Reactive Streams规范的具体实现。Project Reactor是由 Spring 团队维护的，与 Spring 生态系统（特别是 Spring WebFlux）无缝集成，其专注于高性能的服务器端应用，特别强调与函数式编程和响应式流规范的集成。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 响应式编程-Project Reactor基础">
<meta property="og:url" content="http://example.com/2025/08/19/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Ares&#39;s Notes">
<meta property="og:description" content="概述在上篇中介绍了响应式编程基础，其中提到在JDK中只提供了接口规范，并没有提供丰富的操作算子。而 Project Reactor就是基于Reactive Streams规范的具体实现。Project Reactor是由 Spring 团队维护的，与 Spring 生态系统（特别是 Spring WebFlux）无缝集成，其专注于高性能的服务器端应用，特别强调与函数式编程和响应式流规范的集成。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_Flux%E6%B5%81.png">
<meta property="og:image" content="http://example.com/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_Mono%E6%B5%81.png">
<meta property="og:image" content="http://example.com/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_defer.png">
<meta property="og:image" content="http://example.com/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_fromIterable.png">
<meta property="og:image" content="http://example.com/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_fromCallable.png">
<meta property="og:image" content="http://example.com/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_defaultEmpty.png">
<meta property="og:image" content="http://example.com/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_flatMap.png">
<meta property="og:image" content="http://example.com/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_distinct.png">
<meta property="og:image" content="http://example.com/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_merge.png">
<meta property="og:image" content="http://example.com/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_zip.png">
<meta property="og:image" content="http://example.com/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_concat.png">
<meta property="og:image" content="http://example.com/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_then.png">
<meta property="og:image" content="http://example.com/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_doOnNext.png">
<meta property="og:image" content="http://example.com/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_block.png">
<meta property="og:image" content="http://example.com/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_switchIfEmpty.png">
<meta property="og:image" content="http://example.com/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_onErrorResume.png">
<meta property="og:image" content="http://example.com/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_doFinally.png">
<meta property="og:image" content="http://example.com/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_onErrorMap.png">
<meta property="og:image" content="http://example.com/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_doOnError.png">
<meta property="article:published_time" content="2025-08-19T12:13:04.000Z">
<meta property="article:modified_time" content="2025-12-02T13:23:35.993Z">
<meta property="article:author" content="ares">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="响应式">
<meta property="article:tag" content="异步">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_Flux%E6%B5%81.png">
  
  
  
  <title>Java 响应式编程-Project Reactor基础 - Ares&#39;s Notes</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":false,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":"§"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 8.1.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Ares&#39;s Notes</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle">Java 响应式编程-Project Reactor基础</span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-08-19 20:13" pubdate>
          2025年8月19日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          18k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          147 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Java 响应式编程-Project Reactor基础</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在上篇中介绍了响应式编程基础，其中提到在JDK中只提供了接口规范，并没有提供丰富的操作算子。而 Project Reactor就是基于Reactive Streams规范的具体实现。Project Reactor是由 Spring 团队维护的，与 Spring 生态系统（特别是 Spring WebFlux）无缝集成，其专注于高性能的服务器端应用，特别强调与函数式编程和响应式流规范的集成。</p>
<span id="more"></span>

<h2 id="Project-Reactor基础"><a href="#Project-Reactor基础" class="headerlink" title="Project Reactor基础"></a>Project Reactor基础</h2><p>Reactor 项目主要是 reactor-core，这是一个基于 Java 8 的实现了响应式流规范 （Reactive Streams specification）的响应式库。Reactor 围绕两个核心发布者（Publisher）实现及其管理订阅和调度的机制展开：</p>
<ul>
<li><strong><code>Flux&lt;T&gt;</code></strong>：0到N个元素的异步序列：可以发出零个、一个或多个元素，最后可以发出一个完成信号或一个错误信号。用于处理数据流、事件序列、列表数据等，例如网络请求返回的多个结果。</li>
<li><strong><code>Mono&lt;T&gt;</code></strong>：0到1个元素的异步序列，最多发出一个元素，最后可以发出一个完成信号或一个错误信号。用于处理单个结果的异步操作，例如根据 ID 查找单个用户、执行一个 void 方法（返回 Mono）等。</li>
<li><strong>Scheduler</strong>：线程调度器，类似于 RxJava 的 Scheduler，用于管理执行上下文和线程切换。<ul>
<li>Schedulers.elastic()：动态线程池，适合 IO 任务。</li>
<li>Schedulers.parallel()：固定大小线程池，适合计算任务。</li>
<li>publishOn()&#x2F;subscribeOn()：用于控制操作符链的执行线程。</li>
</ul>
</li>
<li><strong>Subscriber</strong>：订阅者&#x2F;消费者，遵循 Reactive Streams 规范的标准接口，用于消费 Flux 或 Mono 发出的数据。onSubscribe(), onNext(), onError(), onComplete(), request() (背压控制)。</li>
<li><strong>Publisher</strong>：发布者&#x2F;数据源，Flux 和 Mono 实现的标准接口，定义了 subscribe(Subscriber s) 方法。这是响应式流规范的核心接口，代表可以发出元素和信号的数据源。</li>
</ul>
<p>在 Reactor 中，当创建了一条 Publisher 处理链，数据还不会开始生成。事实上是创建了一个抽象的对于异步处理流程的描述。只有真正“订阅（subscrib）”的时，将 Publisher 关联到一个 Subscriber 上，才会触发整个链的流动。这时候，Subscriber 会向上游发送一个 request 信号，一直到达源头的 Publisher。</p>
<h2 id="Flux与Mono组件"><a href="#Flux与Mono组件" class="headerlink" title="Flux与Mono组件"></a>Flux与Mono组件</h2><p>Flux 是一个发出(emit)0-N个元素组成的异步序列的<code>Publisher&lt;T&gt;</code>, 可以被onComplete信号或者onError信号所终止。一个 flux 的可能结果是一个 value、completion 或 error，就像在响应式流规范中规定的那样，这三种类型的信号被翻译为面向下游的 onNext，<code>onComplete</code>和<code>onError</code>方法。需要注意，<font color=red>所有的信号事件， 包括代表终止的信号事件都是可选的：如果没有 onNext 事件但是有一个 onComplete 事件， 那么发出的就是 空的 有限序列，但是去掉 onComplete 那么得到的就是一个 无限的 空序列</font>。</p>
<p><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_Flux%E6%B5%81.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FluxExample</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Flux&lt;String&gt; flux = Flux.just(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-string">&quot;World&quot;</span>, <span class="hljs-string">&quot;From&quot;</span>, <span class="hljs-string">&quot;Project&quot;</span>, <span class="hljs-string">&quot;Reactor&quot;</span>);<br><br>    flux.subscribe(System.out::println,<br>                    error -&gt; System.err.println(<span class="hljs-string">&quot;Error: &quot;</span> + error),<br>                    () -&gt; System.out.println(<span class="hljs-string">&quot;Completed&quot;</span>));<br><br>    Flux&lt;String&gt; flux1 = Flux.just(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>);<br>    Flux&lt;String&gt; flux2 = Flux.just(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>);<br><br>    <span class="hljs-comment">// Merge fluxes</span><br>    Flux&lt;String&gt; mergedFlux = Flux.merge(flux1, flux2);<br>    mergedFlux.subscribe(System.out::println);<br><br>    <span class="hljs-comment">// Zip fluxes</span><br>    Flux&lt;String&gt; zippedFlux = Flux.zip(flux1, flux2, (s1, s2) -&gt; s1 + s2);<br>    zippedFlux.subscribe(System.out::println);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Flux常用操作符：</p>
<ul>
<li>just()：可以指定序列中包含的全部元素。创建出来的Flux序列在发布这些元素之后会自动结束</li>
<li>fromArray()，fromIterable()，fromStream()：可以从一个数组，Iterable对象或Stream对象中穿件Flux对象</li>
<li>empty()：创建一个不包含任何元素，只发布结束消息的序列</li>
<li>error(Throwable error)：创建一个只包含错误消息的序列</li>
<li>never()：传建一个不包含任务消息通知的序列</li>
<li>range(int start, int count)：创建包含从start起始的count个数量的Integer对象的序列</li>
<li>interval(Duration period)和interval(Duration delay, Duration period)：创建一个包含了从0开始递增的Long对象的序列。其中包含的元素按照指定的间隔来发布。除了间隔时间之外，还可以指定起始元素发布之前的延迟时间</li>
<li>intervalMillis(long period)和intervalMillis(long delay, long period)：与interval()方法相同，但该方法通过毫秒数来指定时间间隔和延迟时间</li>
</ul>
<p><code>Mono&lt;T&gt;</code> 是一种特殊的 <code>Publisher&lt;T&gt;</code>， 它最多发出一个元素，然后终止于一个 onComplete 信号或一个 onError 信号。它只适用其中一部分可用于 Flux 的操作。比如，（两个 Mono 的）结合类操作可以忽略其中之一 而发出另一个 Mono，也可以将两个都发出，对于后一种情况会切换为一个 Flux。例如，Mono#concatWith(Publisher) 返回一个 Flux，而 Mono#then(Mono) 返回另一个 Mono。注意，<font color=red>Mono 可以用于表示“空”的只有完成概念的异步处理（比如 Runnable）。这种用 <code>Mono&lt;Void&gt;</code> 来创建</font>。</p>
<p><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_Mono%E6%B5%81.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MonoExample</span> &#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    Mono&lt;String&gt; mono = Mono.just(<span class="hljs-string">&quot;Hello Mono&quot;</span>);<br><br>    mono.subscribe(System.out::println,<br>                  error -&gt; System.err.println(<span class="hljs-string">&quot;Error: &quot;</span> + error),<br>                  () -&gt; System.out.println(<span class="hljs-string">&quot;Completed&quot;</span>));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Mono常用操作符：Mono类包含了与Flux类中相同的静态方法just()，empty()和never()等。Mono还有一些独有的静态方法：</p>
<ul>
<li>fromCallable()，fromCompletionStage()，fromFuture()，fromRunnable()和fromSupplier()：分别从Callable，CompletionStage，CompletableFuture，Runnable和Supplier中创建Mono。</li>
<li>delay(Duration duration)和delayMillis(long duration)：创建一个Mono序列，在指定的延迟时间之后，产生数字0作为唯一值。</li>
<li>ignoreElements(Publisher<T> source)：创建一个Mono序列，忽略作为源的Publisher中的所有元素，只产生消息。</li>
<li>justOrEmpty(Optional&lt;? extends T&gt; data)和justOrEmpty(T data)：从一个Optional对象或可能为null的对象中创建Mono。只有Optional对象中包含之或对象不为null时，Mono序列才产生对应的元素。</li>
</ul>
<h2 id="Backpressure处理："><a href="#Backpressure处理：" class="headerlink" title="Backpressure处理："></a>Backpressure处理：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BackpressureExample</span>&#123;<br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// 收集到缓冲区中，直到消费者准备好处理</span><br>    Flux.range(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>)<br>        .onBackpressureBuffer(<span class="hljs-number">10</span>)<br>        .subscribe(System.out::println);<br><br>    <span class="hljs-comment">// 如果消费者跟不上，直接删除</span><br>    Flux.range(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>)<br>        .onBackpressureDrop(item -&gt; System.out.println(<span class="hljs-string">&quot;Dropped: &quot;</span> + item))<br>        .subscribe(System.out::println);<br><br>    <span class="hljs-comment">// 只保留最新，其余丢弃</span><br>    Flux.range(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>)<br>        .onBackpressureLatest()<br>        .subscribe(System.out::println);<br><br>    <span class="hljs-comment">// 包含错误处理    </span><br>    Flux.range(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>)<br>        .onBackpressureError()<br>        .subscribe(<br>            System.out::println,<br>            error -&gt; System.err.println(<span class="hljs-string">&quot;Error: &quot;</span> + error));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用BaseSubscriber实现精细化流量控制（背压，Backpressure），通过重写 hookOnSubscribe 和 hookOnNext 方法，可以手动管理从发布者（Publisher）请求的数据量，而不是默认请求无限制的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java">Flux.range(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>)<br>    .subscribe(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BaseSubscriber</span>&lt;Integer&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hookOnSubscribe</span><span class="hljs-params">(Subscription subscription)</span> &#123;<br>            request(<span class="hljs-number">1</span>); <span class="hljs-comment">// Request the first item</span><br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hookOnNext</span><span class="hljs-params">(Integer value)</span> &#123;<br>            System.out.println(value);<br>            request(<span class="hljs-number">1</span>); <span class="hljs-comment">// Request the next item after processing the current one</span><br>        &#125;<br>    &#125;);<br></code></pre></td></tr></table></figure>
<p>BaseSubscriber 实现了 Subscriber 接口，并提供了方便的以 hook 开头的方法供重写。它的核心优势在于允许用户直接调用 request(long n) 方法来向上游发布者发出数据请求，从而避免因消费者处理速度慢而导致的系统过载。<font color=red>默认情况下，如果不重写 hookOnSubscribe 或 hookOnNext，BaseSubscriber 会自动发出一个无限制的请求（Long.MAX_VALUE）</font>。</p>
<ul>
<li><strong>hookOnSubscribe(Subscription subscription)</strong>：这个方法在订阅成功建立时被调用，可以在此方法中执行初始设置，并发出首个数据请求。它是与上游 Subscription 交互的，必须在此处调用 request(long n) 来启动数据流。如果在此处请求有限数量（例如 request(1) 或 request(5)），则意味着需要在 hookOnNext 中继续手动请求后续数据。</li>
<li><strong>hookOnNext(T value)</strong>：这个方法在每次接收到上游发出的数据项时被调用，是处理业务逻辑和持续流量控制的地方。在处理完当前接收到的数据后，可以决定何时以及请求多少下一个数据。如果在 hookOnSubscribe 中请求了有限数量，那么为了让数据流继续，需要在 hookOnNext 方法中再次调用 request(long n) 来请求下一个（或下一批）数据。</li>
</ul>
<h2 id="常用功能操作符"><a href="#常用功能操作符" class="headerlink" title="常用功能操作符"></a>常用功能操作符</h2><p>Project Reactor 提供了丰富的操作符来处理 Flux (0到N个元素) 和 Mono (0或1个元素) 数据流。虽然没有一个官方统一的分类标准，但根据功能，可以将这些操作符分为：创建操作符 (Creation Operators)、转换操作符 (Transformation Operators)、过滤操作符 (Filtering Operators)、组合操作符 (Combining Operators)、工具操作符 (Utility&#x2F;Side-Effect Operators)。</p>
<h3 id="创建操作符-Creation-Operators"><a href="#创建操作符-Creation-Operators" class="headerlink" title="创建操作符 (Creation Operators)"></a>创建操作符 (Creation Operators)</h3><ul>
<li><code>just(T...)</code>: 从给定的元素创建一个 Flux 或 Mono。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java">Mono.just(<span class="hljs-string">&quot;mono&quot;</span>).subscribe(data -&gt; System.out.println(<span class="hljs-string">&quot;mono: &quot;</span> + data));<br>Flux.just(<span class="hljs-string">&quot;flux-1&quot;</span>, <span class="hljs-string">&quot;flux-2&quot;</span>).subscribe(data -&gt; System.out.println(<span class="hljs-string">&quot;flux: &quot;</span> + data))<br></code></pre></td></tr></table></figure>
<ul>
<li><code>generate()</code>：通过同步和逐一的方式来产生Flux序列。序列的产生是通过调用所提供的的SynchronousSink对象的next()，complete()和error(Throwable)方法来完成的。逐一生成的含义是在具体的生成逻辑中，next()方法只能最多被调用一次。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java">Flux&lt;String&gt; flux = Flux.generate(<br>       () -&gt; <span class="hljs-number">0</span>,<br>       (state, sink) -&gt; &#123;<br>          sink.next(<span class="hljs-string">&quot;3 x &quot;</span> + state + <span class="hljs-string">&quot; = &quot;</span> + <span class="hljs-number">3</span>*state);<br>          <span class="hljs-keyword">if</span> (state == <span class="hljs-number">10</span>) sink.complete();<br>          <span class="hljs-keyword">return</span> state + <span class="hljs-number">1</span>;<br>       &#125;, (state) -&gt; System.out.println(<span class="hljs-string">&quot;state: &quot;</span> + state));<br>flux.subscribe(data -&gt; System.out.println(<span class="hljs-string">&quot;data &quot;</span> + data));<br></code></pre></td></tr></table></figure>

<ul>
<li><code>create()</code>：create 是一种更高级的编程方式创建 Flux 的形式，它适合每轮多次发出，甚至来自多个线程。它暴露了一个 FluxSink 及其 next，error 和 complete 方法。与 generate 相反，它没有基于状态的形式。但是，它可以在回调中触发多线程事件。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs Java">Flux&lt;String&gt; bridge = Flux.create(sink -&gt; &#123;<br>  myMessageProcessor.register(<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyMessageListener</span>&lt;String&gt;() &#123;<br><br>      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onMessage</span><span class="hljs-params">(List&lt;String&gt; messages)</span> &#123;<br>        <span class="hljs-keyword">for</span>(String s : messages) &#123;<br>          sink.next(s); <br>        &#125;<br>      &#125;<br>  &#125;);<br>  sink.onRequest(n -&gt; &#123;<br>    List&lt;String&gt; messages = myMessageProcessor.getHistory(n); <br>    <span class="hljs-keyword">for</span>(String s : message) &#123;<br>      sink.next(s); <br>    &#125;<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure>

<ul>
<li><code>defer()</code>：延迟捕获或创建序列对象。它会在每次对生成的 Flux&#x2F;Mono 进行订阅时懒惰地提供一个发布者，因此实际的源实例化被推迟到每次订阅时，并且提供者可以创建一个订阅者特定的实例。</li>
</ul>
<p><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_defer.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">Mono.defer(() -&gt; Mono.just(UUID.randomUUID())).subscribe(x -&gt; System.out.println(x));<br></code></pre></td></tr></table></figure>
<ul>
<li><code>fromIterable(Iterable&lt;T&gt;)/fromArray(T[])</code>: 从 Iterable (如 List, Set) 创建一个 Flux。</li>
</ul>
<p><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_fromIterable.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Java">Flux&lt;String&gt; flux = Flux.fromIterable(Arrays.asList(<span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>, <span class="hljs-string">&quot;purple&quot;</span>));             <br>flux.subscribe(System.out::println);<br></code></pre></td></tr></table></figure>
<ul>
<li><code>fromRunnable(Runnable) / fromCallable(Callable&lt;T&gt;)</code>: 将命令式代码转换为 Mono，并在订阅时执行。</li>
</ul>
<p><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_fromCallable.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">Mono.fromCallable(() -&gt; UUID.randomUUID()).subscribe(x -&gt; System.out.println(x));<br></code></pre></td></tr></table></figure>
<ul>
<li><code>fromSupplier()</code>：它与 defer() 类似，用于延迟创建类似 Mono 的序列对象。但不同之处在于，它可以自动将提供的数据转换为 Mono 格式。它创建一个 Mono 对象，并使用提供的提供者生成其值，如果提供者解析为 null，则生成的 Mono 对象为空。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">Mono.fromSupplier(() -&gt; UUID.randomUUID()).subscribe(x -&gt; System.out.println(x));<br></code></pre></td></tr></table></figure>
<ul>
<li><p><code>range()</code>: 创建一个整数序列的 Flux。</p>
</li>
<li><p><code>empty()/defaultIfEmpty()</code>: 创建一个立即完成但没有任何元素的 Flux 或 Mono。</p>
</li>
</ul>
<p><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_defaultEmpty.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java">Mono.empty().defaultIfEmpty(<span class="hljs-string">&quot;defaultValue&quot;</span>).subscribe(System.out::println);<br></code></pre></td></tr></table></figure>

<h3 id="转换操作符-Transformation-Operators"><a href="#转换操作符-Transformation-Operators" class="headerlink" title="转换操作符 (Transformation Operators)"></a>转换操作符 (Transformation Operators)</h3><ul>
<li><code>map(Function&lt;T, V&gt;)</code>: 同步地将上游的每个元素映射为下游的一个新元素。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java">Flux&lt;Integer&gt; flux = Flux.just(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>)<br>       .map(data -&gt; Integer.parseInt(data));<br>flux.subscribe(data -&gt; System.out.println(<span class="hljs-string">&quot;data &quot;</span> + data));<br></code></pre></td></tr></table></figure>
<ul>
<li><code>flatMap(Function&lt;T, Publisher&lt;V&gt;&gt;)</code>: 异步地将每个元素映射为一个新的 Publisher（Mono 或 Flux），并将所有内部流合并为一个扁平的下游流。这是响应式编程中最强大的操作符之一。</li>
</ul>
<p><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_flatMap.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java">Flux&lt;Integer&gt; flux = Flux.just(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>)<br>       .flatMap(data -&gt; Mono.just(Integer.parseInt(data)));<br>flux.subscribe(data -&gt; System.out.println(<span class="hljs-string">&quot;data &quot;</span> + data));<br></code></pre></td></tr></table></figure>

<ul>
<li><code>buffer(int maxSize) / window(int maxSize)</code>: 将元素收集到 List (buffer) 或一个新的 Flux (window) 中，然后发射这些集合。</li>
<li><code>cast(Class&lt;V&gt; clazz)</code>: 将流中的元素转换为指定的类型。</li>
</ul>
<h3 id="过滤操作符-Filtering-Operators"><a href="#过滤操作符-Filtering-Operators" class="headerlink" title="过滤操作符 (Filtering Operators)"></a>过滤操作符 (Filtering Operators)</h3><ul>
<li><code>filter(Predicate&lt;T&gt;)</code>: 只允许满足条件的元素通过。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java">Flux&lt;Integer&gt; flux = Flux.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span><br>       .filter(data -&gt; data != <span class="hljs-number">4</span>);<br>flux.subscribe(data -&gt; System.out.println(<span class="hljs-string">&quot;data &quot;</span> + data));)<br></code></pre></td></tr></table></figure>
<ul>
<li><code>take(long n)</code>: 只获取前 N 个元素。</li>
<li><code>skip(long n)</code>: 跳过前 N 个元素。</li>
<li><code>distinct() / distinctUntilChanged()</code>: 过滤掉重复的元素。</li>
</ul>
<p><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_distinct.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java">Flux&lt;String&gt; flux =Flux.just(<span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;orange&quot;</span>, <span class="hljs-string">&quot;purple&quot;</span>)<br>       .distinct();<br>flux.subscribe(System.out::println);<br></code></pre></td></tr></table></figure>

<h3 id="组合操作符-Combining-Operators"><a href="#组合操作符-Combining-Operators" class="headerlink" title="组合操作符 (Combining Operators)"></a>组合操作符 (Combining Operators)</h3><ul>
<li><code>merge(Publisher&lt;T&gt;... principals)</code>: 以交错的方式合并多个 Publisher 的输出。</li>
</ul>
<p><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_merge.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java">Flux&lt;Integer&gt; evenNumbers = Flux<br>			.range(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)<br>			.filter(x -&gt; x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>);<br><br>Flux&lt;String&gt; oddNumbers = Flux<br>			.range(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)<br>			.filter(x -&gt; x % <span class="hljs-number">2</span> &gt; <span class="hljs-number">0</span>)<br>			.map(x -&gt; x.toString().concat(<span class="hljs-string">&quot;: n&quot;</span>));<br><br><span class="hljs-type">var</span> <span class="hljs-variable">flux1</span> <span class="hljs-operator">=</span> Flux.merge(evenNumbers, oddNumbers);<br>flux1.subscribe(x -&gt; System.out.println(x));<br></code></pre></td></tr></table></figure>
<ul>
<li><code>zip(Publisher&lt;T&gt; p1, Publisher&lt;V&gt; p2)</code>: 将两个源 Publisher 按顺序发射的元素配对组合成一个新的元素（如 Tuple2）。</li>
</ul>
<p><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_zip.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Java">Flux&lt;Integer&gt; evenNumbers = Flux<br>			.range(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)<br>			.filter(x -&gt; x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>);<br><br>Flux&lt;Integer&gt; oddNumbers = Flux<br>			.range(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)<br>			.filter(x -&gt; x % <span class="hljs-number">2</span> &gt; <span class="hljs-number">0</span>);<br><br>Flux&lt;Tuple2&lt;Integer, Integer&gt;&gt; fluxOfIntegers = Flux.zip(evenNumbers, oddNumbers);<br>fluxOfIntegers.subscribe(x -&gt; System.out.println(x));<br><br>Flux&lt;Tuple2&lt;Integer, Integer&gt;&gt; flux = evenNumbers.zipWith(oddNumbers);<br>flux.subscribe(x -&gt; System.out.println(x));<br></code></pre></td></tr></table></figure>
<ul>
<li><code>concat()/concatMap()</code>：将提供的所有源连接成一个可迭代对象，并将源发出的元素向下游转发。concat是通过依次订阅第一个源，然后等待其完成再订阅下一个源来实现的，依此类推，直到最后一个源完成。任何错误都会立即中断序列并向下游转发，它会返回一个新的 Flux，该 Flux 连接了所有源序列。</li>
</ul>
<p><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_concat.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java">Flux&lt;Integer&gt; evenNumbers = Flux<br>			.range(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)<br>			.filter(x -&gt; x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>);<br><br>Flux&lt;Integer&gt; oddNumbers = Flux<br>			.range(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)<br>			.filter(x -&gt; x % <span class="hljs-number">2</span> &gt; <span class="hljs-number">0</span>);<br><br>Flux&lt;Integer&gt; fluxOfIntegers = Flux.concat(evenNumbers, oddNumbers);<br>fluxOfIntegers.subscribe(x -&gt; System.out.println(x));<br><br>Flux&lt;String&gt; mergedFlux = Flux.just(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>	.concatMap(it -&gt; Mono.just(it.toString().concat(<span class="hljs-string">&quot;: n&quot;</span>)));<br><br>mergedFlux.subscribe(x -&gt; System.out.println(x));<br></code></pre></td></tr></table></figure>
<ul>
<li><code>then()/thenEmpty()</code>：不关心发布者输出了哪些元素，而只关心它何时完成发布的情况。因此，它会接收一个现有的发布者，丢弃它所有的元素，然后传播完成信号或错误信号。如果我们把任何 Mono 作为 then() 的参数传递，它会将该 Mono 作为输出传递。</li>
</ul>
<p><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_then.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java">Mono&lt;Void&gt; then = Flux.just(<span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>, <span class="hljs-string">&quot;red&quot;</span>)<br>		  .then(Mono.just(<span class="hljs-string">&quot;Orange&quot;</span>))<br>		  .thenEmpty(Mono.empty());<br>then.subscribe();<br></code></pre></td></tr></table></figure>

<h3 id="工具操作符-Utility-Side-Effect-Operators"><a href="#工具操作符-Utility-Side-Effect-Operators" class="headerlink" title="工具操作符 (Utility&#x2F;Side-Effect Operators)"></a>工具操作符 (Utility&#x2F;Side-Effect Operators)</h3><ul>
<li><code>log()</code>: 记录所有响应式信号 (onNext, onError, onComplete, onSubscribe, request) 到日志。</li>
<li><code>doOnNext(...), doOnError(...), doOnComplete(...)</code>: 注册回调函数以观察特定信号并执行Side-Effect操作。</li>
</ul>
<p><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_doOnNext.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java">Flux&lt;Integer&gt; flux = Flux.just(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>)<br>       .map(data -&gt; Integer.parseInt(data));<br>flux.subscribe(data -&gt; System.out.println(<span class="hljs-string">&quot;data &quot;</span> + data));<br></code></pre></td></tr></table></figure>
<ul>
<li><code>subscribeOn(Scheduler s)</code>: 指定上游源执行的调度器（线程池）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">Scheduler</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> Schedulers.newParallel(<span class="hljs-string">&quot;parallel-scheduler&quot;</span>, <span class="hljs-number">4</span>); <br><br><span class="hljs-keyword">final</span> Flux&lt;String&gt; flux = Flux<br>    .range(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>    .map(i -&gt; <span class="hljs-number">10</span> + i)  <br>    .subscribeOn(s)  <br>    .map(i -&gt; <span class="hljs-string">&quot;value &quot;</span> + i);  <br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; flux.subscribe(System.out::println));  <br></code></pre></td></tr></table></figure>
<ul>
<li><code>publishOn(Scheduler s)</code>: 指定下游操作符执行的调度器。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">Scheduler</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> Schedulers.newParallel(<span class="hljs-string">&quot;parallel-scheduler&quot;</span>, <span class="hljs-number">4</span>); <br><br><span class="hljs-keyword">final</span> Flux&lt;String&gt; flux = Flux<br>    .range(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>    .map(i -&gt; <span class="hljs-number">10</span> + i)  <br>    .publishOn(s)  <br>    .map(i -&gt; <span class="hljs-string">&quot;value &quot;</span> + i);  <br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; flux.subscribe(System.out::println));  <br></code></pre></td></tr></table></figure>
<ul>
<li><code>block() / blockFirst() / blockLast()</code>: 阻塞当前线程直到流完成或发出元素（应谨慎使用，主要用于测试或非响应式边界）。</li>
</ul>
<p><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_block.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> Mono.just(<span class="hljs-string">&quot;Value&quot;</span>)<br>             .block();<br>System.out.println(value);<br></code></pre></td></tr></table></figure>
<ul>
<li><code>switchIfEmpty()</code>：如果序列完成时没有任何数据，它会切换到备用发布者。</li>
</ul>
<p><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_switchIfEmpty.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java">Mono&lt;String&gt; defaultMono = Mono.just(<span class="hljs-string">&quot;defaultString&quot;</span>);<br>Mono&lt;Object&gt; mono = Mono.empty().switchIfEmpty(defaultMono);<br>mono.subscribe(System.out::println);<br></code></pre></td></tr></table></figure>
<ul>
<li><code>handle()</code>：用于创建自定义处理器。handle 方法可以用于自定义流的处理逻辑，与 map 方法重新映射、生成新的流不同，handle 方法用于消费元素，可以重新定义流。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">alphabet</span><span class="hljs-params">(<span class="hljs-type">int</span> letterNumber)</span> &#123;<br>  <span class="hljs-keyword">if</span> (letterNumber &lt; <span class="hljs-number">1</span> || letterNumber &gt; <span class="hljs-number">26</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br>  <span class="hljs-type">int</span> <span class="hljs-variable">letterIndexAscii</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;A&#x27;</span> + letterNumber - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span> + (<span class="hljs-type">char</span>) letterIndexAscii;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operatorTest</span><span class="hljs-params">()</span> &#123;<br>  Flux&lt;String&gt; alphabet = Flux.just(-<span class="hljs-number">1</span>, <span class="hljs-number">30</span>, <span class="hljs-number">13</span>, <span class="hljs-number">9</span>, <span class="hljs-number">20</span>)<br>      .handle((i, sink) -&gt; &#123;<br>          <span class="hljs-type">String</span> <span class="hljs-variable">letter</span> <span class="hljs-operator">=</span> alphabet(i);<br>          <span class="hljs-keyword">if</span> (letter != <span class="hljs-literal">null</span>) sink.next(letter);<br>      &#125;)<br>      .filter(data -&gt; &#123;<br>          <span class="hljs-type">boolean</span> <span class="hljs-variable">isTrue</span> <span class="hljs-operator">=</span> !data.equals(<span class="hljs-string">&quot;M&quot;</span>);<br>          System.out.println(isTrue);<br>          <span class="hljs-keyword">return</span> isTrue;<br>      &#125;)<br>      .map(ch -&gt; ch+<span class="hljs-string">&quot;-Data&quot;</span>)<br>      .doOnNext(conData -&gt; System.out.println(conData))<br>      .flatMap(conData -&gt; Mono.just(conData));<br><br>  alphabet.subscribe(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>在 Project Reactor 中，处理错误是响应式编程的关键部分，流一旦发生错误就会终止 (onError 信号)，因此需要使用特定的操作符来截取错误并决定后续行为。</p>
<h3 id="错误恢复操作符-Recovery-Operators-："><a href="#错误恢复操作符-Recovery-Operators-：" class="headerlink" title="错误恢复操作符 (Recovery Operators)："></a>错误恢复操作符 (Recovery Operators)：</h3><p><strong>onErrorReturn(T fallbackValue)</strong>：当发生错误时，抛出一个默认值，然后正常完成 (onComplete)。适用于需要提供一个默认值作为简单回退逻辑的情况，例如：服务不可用时返回一个缓存的默认值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java">Flux.just(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)<br>    .map(i -&gt; <span class="hljs-number">10</span> / i) <span class="hljs-comment">// 当 i 为 0 时抛出 ArithmeticException</span><br>    .onErrorReturn(-<span class="hljs-number">1</span>) <span class="hljs-comment">// 捕获错误并返回 -1</span><br>    .subscribe(System.out::println); <br><span class="hljs-comment">// 输出: 10, -1</span><br></code></pre></td></tr></table></figure>

<p><strong><code>onErrorResume(Function&lt;Throwable, ? extends Publisher&lt;? extends T&gt;&gt; fallbackSupplier)</code></strong>：当发生错误时，切换到一个新的备用 Publisher (如另一个 Mono 或 Flux) 来继续数据流。适用于需要执行更复杂的备用逻辑、调用另一个服务或根据错误类型动态生成备用数据流的情况。</p>
<p><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_onErrorResume.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Java">Flux.just(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;unknown&quot;</span>)<br>    .flatMap(user -&gt; callExternalService(user) <span class="hljs-comment">// 模拟外部服务调用</span><br>        .onErrorResume(e -&gt; getFromCache(user)) <span class="hljs-comment">// 外部服务失败时从缓存获取</span><br>    )<br>    .subscribe(System.out::println);<br></code></pre></td></tr></table></figure>

<p><strong>onErrorComplete()</strong>：捕获错误信号，并将其转换为正常的完成信号 (onComplete)。适用于成功的结果而可以完全忽略错误的场景。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java">Flux.just(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>)<br>    .map(<span class="hljs-built_in">this</span>::doSomethingDangerousOn30)<br>    .onErrorComplete();<br></code></pre></td></tr></table></figure>

<p><strong>doFinally()</strong>：最终执行，类似try-finally。 doFinally 在终止时无论是 onComplete、<code>onError</code>还是取消都会被执行， 并且能够判断是什么类型的终止事件。</p>
<p><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_doFinally.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java">Flux.just(<span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>)<br>    .doOnSubscribe(s -&gt; stats.startTimer())<br>    .doFinally(type -&gt; &#123; <br>        stats.stopTimerAndRecordTiming();<br>        <span class="hljs-keyword">if</span> (type == SignalType.CANCEL) <br>          statsCancel.increment();<br>    &#125;);<br></code></pre></td></tr></table></figure>

<p><strong><code>onErrorContinue(BiConsumer&lt;Throwable, Object&gt; consumer)</code></strong>：允许在处理 Flux 流中的元素时，跳过导致错误的元素，记录错误信息，然后继续处理流中的下一个元素。主要用于 Flux 中，当某个元素处理失败不应中断整个流时。注意，必须将此操作符放在可能抛出异常的操作符（例如 map）之前。</p>
<h3 id="错误转换操作符"><a href="#错误转换操作符" class="headerlink" title="错误转换操作符"></a>错误转换操作符</h3><p><strong><code>onErrorMap(Function&lt;Throwable, Throwable&gt; mapper)</code></strong>：将捕获到的异常转换为另一种自定义的异常类型，并重新抛出（向下游传递新的 onError 信号）。适用于将底层技术异常（如 IOException）封装为业务异常（如 UserServiceException），以便下游更好地理解和处理。</p>
<p><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_onErrorMap.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java">Flux.just(<span class="hljs-string">&quot;timeout1&quot;</span>)<br>    .flatMap(k -&gt; callExternalService(k))<br>    .onErrorMap(original -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">BusinessException</span>(<span class="hljs-string">&quot;oops, SLA exceeded&quot;</span>, original));<br></code></pre></td></tr></table></figure>

<p><strong><code>doOnError(Consumer&lt;Throwable&gt; consumer)</code></strong>：注册一个回调函数，用于观察（记录日志、监控指标等）错误信号，但不会改变或消耗错误信号，错误会继续向下游传播。仅用于执行副作用操作，如日志记录或指标收集。</p>
<p><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_doOnError.png" srcset="/img/loading.gif" lazyload></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Java">Flux.just(<span class="hljs-string">&quot;unknown&quot;</span>)<br>    .flatMap(k -&gt; callExternalService(k).doOnError(e -&gt; &#123;<br>            failureStat.increment();<br>            log(<span class="hljs-string">&quot;uh oh, falling back, service failed for key &quot;</span> + k); <br>        &#125;)<br>    );<br></code></pre></td></tr></table></figure>

<h3 id="重试操作符-Retry-Operators"><a href="#重试操作符-Retry-Operators" class="headerlink" title="重试操作符 (Retry Operators)"></a>重试操作符 (Retry Operators)</h3><p><strong>retry() 或 retry(long maxRetries)</strong>：发生错误时，重新订阅上游的 Publisher，尝试再次执行整个流。原始流会终止，但 retry 会创建一个新的订阅。适用于处理瞬时错误（例如网络波动、临时服务不可用）的情况。应设置最大重试次数以避免无限循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Java">Flux.interval(Duration.ofMillis(<span class="hljs-number">250</span>))<br>    .map(input -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (input &lt; <span class="hljs-number">3</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;tick &quot;</span> + input;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;boom&quot;</span>);<br>    &#125;)<br>    .elapsed() <br>    .retry(<span class="hljs-number">1</span>)<br>    .subscribe(System.out::println, System.err::println);<br></code></pre></td></tr></table></figure>
<p><strong><code>retryWhen(Function&lt;Flux&lt;Throwable&gt;, ? extends Publisher&lt;?&gt;&gt;)</code></strong>：: 提供基于异常类型和重试次数的更精细的重试逻辑控制，支持指数退避等高级策略。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Java">Flux.&lt;String&gt;error(<span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>()) <br>    .doOnError(System.out::println) <br>    .retryWhen(companion -&gt; companion.take(<span class="hljs-number">3</span>));<br></code></pre></td></tr></table></figure>

<h2 id="线程和调度器"><a href="#线程和调度器" class="headerlink" title="线程和调度器"></a>线程和调度器</h2><p>响应式流（Flux和Mono）本质上是关于数据流和信号回调的，而不是并发模型。默认情况下，操作符会继续在执行前一个操作符的线程中工作。即，除非指定，否则源操作符本身运行在调用了 subscribe() 的 Thread 上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>  <span class="hljs-keyword">final</span> Flux&lt;Object&gt; flux = Flux.fromArray(Arrays.asList(<span class="hljs-string">&quot;hello &quot;</span>, <span class="hljs-string">&quot;reactive &quot;</span>).toArray());<br><br>  <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; flux<br>      .map(msg -&gt; msg + <span class="hljs-string">&quot;thread &quot;</span>)<br>      .subscribe(v -&gt;<br>          System.out.println(v + Thread.currentThread().getName())<br>      )<br>  );<br>  t.start();<br>  t.join();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Reactor的 <strong>调度器（Scheduler）</strong> 是控制线程执行的关键机制，它类似于 ExecutorService，用于将不同的操作分派到特定的线程或线程池。Schedulers 类提供了一系列静态方法来访问不同类型的内置调度器，它们抽象了底层的线程池管理。Reactor主要的内置调度器类型包括：</p>
<ul>
<li>Schedulers.immediate(): 在当前线程中立即执行任务。</li>
<li>Schedulers.single(): 使用一个单一的、可重用的后台线程。</li>
<li>Schedulers.parallel(): 使用一个固定大小的线程池，其大小通常等于 CPU 核心数，适用于并行计算任务。</li>
<li>Schedulers.boundedElastic(): 这是一个有界的弹性线程池，按需动态创建线程，但有数量上限，适用于执行阻塞 I&#x2F;O 操作（如数据库调用、网络请求）。它是已弃用的 Schedulers.elastic() 的替代品。</li>
</ul>
<p>除了上面内置的调度器，也可以使用现有的 ExecutorService 创建自定义调度器。Project Reactor 提供了两个核心操作符来控制流的执行线程上下文：</p>
<ul>
<li><strong>subscribeOn(Scheduler)</strong>：把订阅动作（Subscriber.onSubscribe 的创建、链路建立、上游 request 的初次调用等）移动到指定 Scheduler。当在上游调用 subscribe 时，subscribeOn 会 schedule 一个 Runnable 去执行真正的 subscribe 操作（即把 subscription 的建立放到其他线程），因此上游的同步产生&#x2F;拉取代码会在该 Scheduler 的线程上运行。它影响整个操作链的源头（upstream）和下游（downstream），决定了数据生成和初始订阅发生的线程。无论 subscribeOn 放在操作链的哪个位置，它都会改变整个流的根执行上下文。</li>
<li><strong>publishOn(Scheduler)</strong>：在数据流中的某处建立异步边界——把从这个 operator 向下游发送的信号切换到指定 Scheduler 的线程。publishOn 用一个内部队列把上游发来的 onNext&#x2F;onError&#x2F;onComplete 等事件缓存起来，然后在 Worker 的线程中做 drain（取出并调用下游的 onNext&#x2F;onComplete&#x2F;onError）。因此，publishOn 会序列化并且切换信号执行线程。它只影响其 <strong>下游（downstream）</strong> 的操作符（从它出现的位置到下一个 publishOn 或流结束）。会在流中引入一个异步边界，将后续的处理切换到指定的调度器上。这对于在不同阶段（例如，将 I&#x2F;O 操作与 CPU 密集型操作分开）使用不同的线程池非常有用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs Java">Flux.range(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>)<br>    .map(i -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;map1 thread: &quot;</span> + Thread.currentThread().getName());<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;)<br>    .subscribeOn(Schedulers.boundedElastic()) <span class="hljs-comment">// 订阅在 boundedElastic 线程</span><br>    .map(i -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;map2 thread: &quot;</span> + Thread.currentThread().getName());<br>        <span class="hljs-keyword">return</span> i * <span class="hljs-number">10</span>;<br>    &#125;)<br>    .publishOn(Schedulers.parallel()) <span class="hljs-comment">// 从这里开始把信号转到 parallel 线程</span><br>    .map(i -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;map3 thread: &quot;</span> + Thread.currentThread().getName());<br>        <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>    &#125;)<br>    .subscribe(i -&gt; System.out.println(<span class="hljs-string">&quot;onNext thread: &quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot; =&gt; &quot;</span> + i));<br></code></pre></td></tr></table></figure>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Java/" class="category-chain-item">Java</a>
  
  

      </span>
    
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%BC%82%E6%AD%A5/" class="category-chain-item">异步</a>
  
  

      </span>
    
  
    
      <span class="category-chain">
        
  <a href="/categories/%E5%93%8D%E5%BA%94%E5%BC%8F/" class="category-chain-item">响应式</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Java/" class="print-no-link">#Java</a>
      
        <a href="/tags/%E5%BC%82%E6%AD%A5/" class="print-no-link">#异步</a>
      
        <a href="/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/" class="print-no-link">#响应式</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Java 响应式编程-Project Reactor基础</div>
      <div>http://example.com/2025/08/19/Java-响应式-ProjectReactor基础/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>ares</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年8月19日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/08/21/java-%E5%93%8D%E5%BA%94%E5%BC%8F-WebFlux%E5%9F%BA%E7%A1%80/" title="Java 响应式编程-WebFlux基础">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Java 响应式编程-WebFlux基础</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/08/17/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/" title="Java 响应式编程基础">
                        <span class="hidden-mobile">Java 响应式编程基础</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  



  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});

    Fluid.utils.listenDOMLoaded(function() {
      Fluid.events.registerRefreshCallback(function() {
        if ('mermaid' in window) {
          mermaid.init();
        }
      });
    });
  });
</script>






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>





  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
