<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="概述在上篇中介绍了响应式编程基础，其中提到在JDK中只提供了接口规范，并没有提供丰富的操作算子。而 Project Reactor就是基于Reactive Streams规范的具体实现。Project Reactor是由 Spring 团队维护的，与 Spring 生态系统（特别是 Spring WebFlux）无缝集成，其专注于高性能的服务器端应用，特别强调与函数式编程和响应式流规范的集成。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 响应式编程-Project Reactor基础">
<meta property="og:url" content="http://example.com/2025/08/19/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Ares&#39;s Notes">
<meta property="og:description" content="概述在上篇中介绍了响应式编程基础，其中提到在JDK中只提供了接口规范，并没有提供丰富的操作算子。而 Project Reactor就是基于Reactive Streams规范的具体实现。Project Reactor是由 Spring 团队维护的，与 Spring 生态系统（特别是 Spring WebFlux）无缝集成，其专注于高性能的服务器端应用，特别强调与函数式编程和响应式流规范的集成。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_Flux%E6%B5%81.png">
<meta property="og:image" content="http://example.com/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_Mono%E6%B5%81.png">
<meta property="og:image" content="http://example.com/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_defer.png">
<meta property="og:image" content="http://example.com/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_fromIterable.png">
<meta property="og:image" content="http://example.com/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_fromCallable.png">
<meta property="og:image" content="http://example.com/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_defaultEmpty.png">
<meta property="og:image" content="http://example.com/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_flatMap.png">
<meta property="og:image" content="http://example.com/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_distinct.png">
<meta property="og:image" content="http://example.com/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_merge.png">
<meta property="og:image" content="http://example.com/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_zip.png">
<meta property="og:image" content="http://example.com/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_concat.png">
<meta property="og:image" content="http://example.com/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_then.png">
<meta property="og:image" content="http://example.com/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_doOnNext.png">
<meta property="og:image" content="http://example.com/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_block.png">
<meta property="og:image" content="http://example.com/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_switchIfEmpty.png">
<meta property="og:image" content="http://example.com/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_onErrorResume.png">
<meta property="og:image" content="http://example.com/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_doFinally.png">
<meta property="og:image" content="http://example.com/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_onErrorMap.png">
<meta property="og:image" content="http://example.com/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_doOnError.png">
<meta property="article:published_time" content="2025-08-19T12:13:04.000Z">
<meta property="article:modified_time" content="2025-12-01T16:35:28.183Z">
<meta property="article:author" content="ares">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="响应式">
<meta property="article:tag" content="异步">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_Flux%E6%B5%81.png">
    
    
      
        
          <link rel="shortcut icon" href="/images/favicon.ico">
        
      
      
        
          <link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192">
        
      
      
        
          <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
        
      
    
    <!-- title -->
    <title>Java 响应式编程-Project Reactor基础</title>
    <!-- async scripts -->
    <!-- Google Analytics -->

  <script async src="https://www.googletagmanager.com/gtag/js?id=G-RL5NX8NL9X"></script>
  <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-RL5NX8NL9X');
  </script>


    <!-- Umami Analytics -->


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<meta name="generator" content="Hexo 8.1.0"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#" aria-label="目录"><i class="fa-solid fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" aria-label="顶部" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fa-solid fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     -->
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        
        <li><a class="icon" aria-label="下一篇" href="/2025/08/17/Java-%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" aria-label="返回顶部" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" aria-label="分享文章" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2025/08/19/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2025/08/19/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80/&text=Java 响应式编程-Project Reactor基础"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2025/08/19/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80/&title=Java 响应式编程-Project Reactor基础"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2025/08/19/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80/&is_video=false&description=Java 响应式编程-Project Reactor基础"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Java 响应式编程-Project Reactor基础&body=Check out this article: http://example.com/2025/08/19/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80/"><i class="fa-solid fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2025/08/19/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80/&title=Java 响应式编程-Project Reactor基础"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2025/08/19/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80/&title=Java 响应式编程-Project Reactor基础"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2025/08/19/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80/&title=Java 响应式编程-Project Reactor基础"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2025/08/19/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80/&title=Java 响应式编程-Project Reactor基础"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2025/08/19/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80/&name=Java 响应式编程-Project Reactor基础&description=&lt;h2 id=&#34;概述&#34;&gt;&lt;a href=&#34;#概述&#34; class=&#34;headerlink&#34; title=&#34;概述&#34;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;在上篇中介绍了响应式编程基础，其中提到在JDK中只提供了接口规范，并没有提供丰富的操作算子。而 Project Reactor就是基于Reactive Streams规范的具体实现。Project Reactor是由 Spring 团队维护的，与 Spring 生态系统（特别是 Spring WebFlux）无缝集成，其专注于高性能的服务器端应用，特别强调与函数式编程和响应式流规范的集成。&lt;/p&gt;"><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2025/08/19/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80/&t=Java 响应式编程-Project Reactor基础"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    
    
      <div id="toc">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Project-Reactor%E5%9F%BA%E7%A1%80"><span class="toc-number">2.</span> <span class="toc-text">Project Reactor基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Flux%E4%B8%8EMono%E7%BB%84%E4%BB%B6"><span class="toc-number">3.</span> <span class="toc-text">Flux与Mono组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Backpressure%E5%A4%84%E7%90%86%EF%BC%9A"><span class="toc-number">4.</span> <span class="toc-text">Backpressure处理：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">5.</span> <span class="toc-text">常用功能操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%AC%A6-Creation-Operators"><span class="toc-number">5.1.</span> <span class="toc-text">创建操作符 (Creation Operators)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%93%8D%E4%BD%9C%E7%AC%A6-Transformation-Operators"><span class="toc-number">5.2.</span> <span class="toc-text">转换操作符 (Transformation Operators)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E6%93%8D%E4%BD%9C%E7%AC%A6-Filtering-Operators"><span class="toc-number">5.3.</span> <span class="toc-text">过滤操作符 (Filtering Operators)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%93%8D%E4%BD%9C%E7%AC%A6-Combining-Operators"><span class="toc-number">5.4.</span> <span class="toc-text">组合操作符 (Combining Operators)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7%E6%93%8D%E4%BD%9C%E7%AC%A6-Utility-Side-Effect-Operators"><span class="toc-number">5.5.</span> <span class="toc-text">工具操作符 (Utility&#x2F;Side-Effect Operators)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text">错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E6%81%A2%E5%A4%8D%E6%93%8D%E4%BD%9C%E7%AC%A6-Recovery-Operators-%EF%BC%9A"><span class="toc-number">6.1.</span> <span class="toc-text">错误恢复操作符 (Recovery Operators)：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E8%BD%AC%E6%8D%A2%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">6.2.</span> <span class="toc-text">错误转换操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%AF%95%E6%93%8D%E4%BD%9C%E7%AC%A6-Retry-Operators"><span class="toc-number">6.3.</span> <span class="toc-text">重试操作符 (Retry Operators)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">7.</span> <span class="toc-text">线程和调度器</span></a></li></ol>
      </div>
    
  </span>
</div>

    
    <div class="content index py4 ">
        
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle p-name" itemprop="name headline">
        Java 响应式编程-Project Reactor基础
    </h1>



    <div class="meta">
      <span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span class="p-name" itemprop="name">ares</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2025-08-19T12:13:04.000Z" class="dt-published" itemprop="datePublished">2025-08-19</time>
        
        (Updated: <time datetime="2025-12-01T16:35:28.183Z" class="dt-updated" itemprop="dateModified">2025-12-02</time>)
        
      
    </div>


      
    <div class="article-category">
        <i class="fa-solid fa-archive"></i>
        <a class="category-link" href="/categories/Java/">Java</a> › <a class="category-link" href="/categories/%E5%93%8D%E5%BA%94%E5%BC%8F/">响应式</a> › <a class="category-link" href="/categories/%E5%BC%82%E6%AD%A5/">异步</a>
    </div>


      
    <div class="article-tag">
        <i class="fa-solid fa-tag"></i>
        <a class="p-category" href="/tags/Java/" rel="tag">Java</a>, <a class="p-category" href="/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/" rel="tag">响应式</a>, <a class="p-category" href="/tags/%E5%BC%82%E6%AD%A5/" rel="tag">异步</a>
    </div>


    </div>
  </header>
  

  <div class="content e-content" itemprop="articleBody">
    <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在上篇中介绍了响应式编程基础，其中提到在JDK中只提供了接口规范，并没有提供丰富的操作算子。而 Project Reactor就是基于Reactive Streams规范的具体实现。Project Reactor是由 Spring 团队维护的，与 Spring 生态系统（特别是 Spring WebFlux）无缝集成，其专注于高性能的服务器端应用，特别强调与函数式编程和响应式流规范的集成。</p>
<span id="more"></span>

<h2 id="Project-Reactor基础"><a href="#Project-Reactor基础" class="headerlink" title="Project Reactor基础"></a>Project Reactor基础</h2><p>Reactor 项目主要是 reactor-core，这是一个基于 Java 8 的实现了响应式流规范 （Reactive Streams specification）的响应式库。Reactor 围绕两个核心发布者（Publisher）实现及其管理订阅和调度的机制展开：</p>
<ul>
<li><strong><code>Flux&lt;T&gt;</code></strong>：0到N个元素的异步序列：可以发出零个、一个或多个元素，最后可以发出一个完成信号或一个错误信号。用于处理数据流、事件序列、列表数据等，例如网络请求返回的多个结果。</li>
<li><strong><code>Mono&lt;T&gt;</code></strong>：0到1个元素的异步序列，最多发出一个元素，最后可以发出一个完成信号或一个错误信号。用于处理单个结果的异步操作，例如根据 ID 查找单个用户、执行一个 void 方法（返回 Mono）等。</li>
<li><strong>Scheduler</strong>：线程调度器，类似于 RxJava 的 Scheduler，用于管理执行上下文和线程切换。<ul>
<li>Schedulers.elastic()：动态线程池，适合 IO 任务。</li>
<li>Schedulers.parallel()：固定大小线程池，适合计算任务。</li>
<li>publishOn()&#x2F;subscribeOn()：用于控制操作符链的执行线程。</li>
</ul>
</li>
<li><strong>Subscriber</strong>：订阅者&#x2F;消费者，遵循 Reactive Streams 规范的标准接口，用于消费 Flux 或 Mono 发出的数据。onSubscribe(), onNext(), onError(), onComplete(), request() (背压控制)。</li>
<li><strong>Publisher</strong>：发布者&#x2F;数据源，Flux 和 Mono 实现的标准接口，定义了 subscribe(Subscriber s) 方法。这是响应式流规范的核心接口，代表可以发出元素和信号的数据源。</li>
</ul>
<p>在 Reactor 中，当创建了一条 Publisher 处理链，数据还不会开始生成。事实上是创建了一个抽象的对于异步处理流程的描述。只有真正“订阅（subscrib）”的时，将 Publisher 关联到一个 Subscriber 上，才会触发整个链的流动。这时候，Subscriber 会向上游发送一个 request 信号，一直到达源头的 Publisher。</p>
<h2 id="Flux与Mono组件"><a href="#Flux与Mono组件" class="headerlink" title="Flux与Mono组件"></a>Flux与Mono组件</h2><p>Flux 是一个发出(emit)0-N个元素组成的异步序列的<code>Publisher&lt;T&gt;</code>, 可以被onComplete信号或者onError信号所终止。一个 flux 的可能结果是一个 value、completion 或 error，就像在响应式流规范中规定的那样，这三种类型的信号被翻译为面向下游的 onNext，<code>onComplete</code>和<code>onError</code>方法。需要注意，<font color=red>所有的信号事件， 包括代表终止的信号事件都是可选的：如果没有 onNext 事件但是有一个 onComplete 事件， 那么发出的就是 空的 有限序列，但是去掉 onComplete 那么得到的就是一个 无限的 空序列</font>。</p>
<p><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_Flux%E6%B5%81.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FluxExample</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Flux&lt;String&gt; flux = Flux.just(<span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span>, <span class="string">&quot;From&quot;</span>, <span class="string">&quot;Project&quot;</span>, <span class="string">&quot;Reactor&quot;</span>);</span><br><span class="line"></span><br><span class="line">    flux.subscribe(System.out::println,</span><br><span class="line">                    error -&gt; System.err.println(<span class="string">&quot;Error: &quot;</span> + error),</span><br><span class="line">                    () -&gt; System.out.println(<span class="string">&quot;Completed&quot;</span>));</span><br><span class="line"></span><br><span class="line">    Flux&lt;String&gt; flux1 = Flux.just(<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>);</span><br><span class="line">    Flux&lt;String&gt; flux2 = Flux.just(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Merge fluxes</span></span><br><span class="line">    Flux&lt;String&gt; mergedFlux = Flux.merge(flux1, flux2);</span><br><span class="line">    mergedFlux.subscribe(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Zip fluxes</span></span><br><span class="line">    Flux&lt;String&gt; zippedFlux = Flux.zip(flux1, flux2, (s1, s2) -&gt; s1 + s2);</span><br><span class="line">    zippedFlux.subscribe(System.out::println);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Flux常用操作符：</p>
<ul>
<li>just()：可以指定序列中包含的全部元素。创建出来的Flux序列在发布这些元素之后会自动结束</li>
<li>fromArray()，fromIterable()，fromStream()：可以从一个数组，Iterable对象或Stream对象中穿件Flux对象</li>
<li>empty()：创建一个不包含任何元素，只发布结束消息的序列</li>
<li>error(Throwable error)：创建一个只包含错误消息的序列</li>
<li>never()：传建一个不包含任务消息通知的序列</li>
<li>range(int start, int count)：创建包含从start起始的count个数量的Integer对象的序列</li>
<li>interval(Duration period)和interval(Duration delay, Duration period)：创建一个包含了从0开始递增的Long对象的序列。其中包含的元素按照指定的间隔来发布。除了间隔时间之外，还可以指定起始元素发布之前的延迟时间</li>
<li>intervalMillis(long period)和intervalMillis(long delay, long period)：与interval()方法相同，但该方法通过毫秒数来指定时间间隔和延迟时间</li>
</ul>
<p><code>Mono&lt;T&gt;</code> 是一种特殊的 <code>Publisher&lt;T&gt;</code>， 它最多发出一个元素，然后终止于一个 onComplete 信号或一个 onError 信号。它只适用其中一部分可用于 Flux 的操作。比如，（两个 Mono 的）结合类操作可以忽略其中之一 而发出另一个 Mono，也可以将两个都发出，对于后一种情况会切换为一个 Flux。例如，Mono#concatWith(Publisher) 返回一个 Flux，而 Mono#then(Mono) 返回另一个 Mono。注意，<font color=red>Mono 可以用于表示“空”的只有完成概念的异步处理（比如 Runnable）。这种用 <code>Mono&lt;Void&gt;</code> 来创建</font>。</p>
<p><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_Mono%E6%B5%81.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MonoExample</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    Mono&lt;String&gt; mono = Mono.just(<span class="string">&quot;Hello Mono&quot;</span>);</span><br><span class="line"></span><br><span class="line">    mono.subscribe(System.out::println,</span><br><span class="line">                  error -&gt; System.err.println(<span class="string">&quot;Error: &quot;</span> + error),</span><br><span class="line">                  () -&gt; System.out.println(<span class="string">&quot;Completed&quot;</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Mono常用操作符：Mono类包含了与Flux类中相同的静态方法just()，empty()和never()等。Mono还有一些独有的静态方法：</p>
<ul>
<li>fromCallable()，fromCompletionStage()，fromFuture()，fromRunnable()和fromSupplier()：分别从Callable，CompletionStage，CompletableFuture，Runnable和Supplier中创建Mono。</li>
<li>delay(Duration duration)和delayMillis(long duration)：创建一个Mono序列，在指定的延迟时间之后，产生数字0作为唯一值。</li>
<li>ignoreElements(Publisher<T> source)：创建一个Mono序列，忽略作为源的Publisher中的所有元素，只产生消息。</li>
<li>justOrEmpty(Optional&lt;? extends T&gt; data)和justOrEmpty(T data)：从一个Optional对象或可能为null的对象中创建Mono。只有Optional对象中包含之或对象不为null时，Mono序列才产生对应的元素。</li>
</ul>
<h2 id="Backpressure处理："><a href="#Backpressure处理：" class="headerlink" title="Backpressure处理："></a>Backpressure处理：</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BackpressureExample</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 收集到缓冲区中，直到消费者准备好处理</span></span><br><span class="line">    Flux.range(<span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">        .onBackpressureBuffer(<span class="number">10</span>)</span><br><span class="line">        .subscribe(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果消费者跟不上，直接删除</span></span><br><span class="line">    Flux.range(<span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">        .onBackpressureDrop(item -&gt; System.out.println(<span class="string">&quot;Dropped: &quot;</span> + item))</span><br><span class="line">        .subscribe(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只保留最新，其余丢弃</span></span><br><span class="line">    Flux.range(<span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">        .onBackpressureLatest()</span><br><span class="line">        .subscribe(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 包含错误处理    </span></span><br><span class="line">    Flux.range(<span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">        .onBackpressureError()</span><br><span class="line">        .subscribe(</span><br><span class="line">            System.out::println,</span><br><span class="line">            error -&gt; System.err.println(<span class="string">&quot;Error: &quot;</span> + error));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用BaseSubscriber实现精细化流量控制（背压，Backpressure），通过重写 hookOnSubscribe 和 hookOnNext 方法，可以手动管理从发布者（Publisher）请求的数据量，而不是默认请求无限制的数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Flux.range(<span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">    .subscribe(<span class="keyword">new</span> <span class="title class_">BaseSubscriber</span>&lt;Integer&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">hookOnSubscribe</span><span class="params">(Subscription subscription)</span> &#123;</span><br><span class="line">            request(<span class="number">1</span>); <span class="comment">// Request the first item</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">hookOnNext</span><span class="params">(Integer value)</span> &#123;</span><br><span class="line">            System.out.println(value);</span><br><span class="line">            request(<span class="number">1</span>); <span class="comment">// Request the next item after processing the current one</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>BaseSubscriber 实现了 Subscriber 接口，并提供了方便的以 hook 开头的方法供重写。它的核心优势在于允许用户直接调用 request(long n) 方法来向上游发布者发出数据请求，从而避免因消费者处理速度慢而导致的系统过载。<font color=red>默认情况下，如果不重写 hookOnSubscribe 或 hookOnNext，BaseSubscriber 会自动发出一个无限制的请求（Long.MAX_VALUE）</font>。</p>
<ul>
<li><strong>hookOnSubscribe(Subscription subscription)</strong>：这个方法在订阅成功建立时被调用，可以在此方法中执行初始设置，并发出首个数据请求。它是与上游 Subscription 交互的，必须在此处调用 request(long n) 来启动数据流。如果在此处请求有限数量（例如 request(1) 或 request(5)），则意味着需要在 hookOnNext 中继续手动请求后续数据。</li>
<li><strong>hookOnNext(T value)</strong>：这个方法在每次接收到上游发出的数据项时被调用，是处理业务逻辑和持续流量控制的地方。在处理完当前接收到的数据后，可以决定何时以及请求多少下一个数据。如果在 hookOnSubscribe 中请求了有限数量，那么为了让数据流继续，需要在 hookOnNext 方法中再次调用 request(long n) 来请求下一个（或下一批）数据。</li>
</ul>
<h2 id="常用功能操作符"><a href="#常用功能操作符" class="headerlink" title="常用功能操作符"></a>常用功能操作符</h2><p>Project Reactor 提供了丰富的操作符来处理 Flux (0到N个元素) 和 Mono (0或1个元素) 数据流。虽然没有一个官方统一的分类标准，但根据功能，可以将这些操作符分为：创建操作符 (Creation Operators)、转换操作符 (Transformation Operators)、过滤操作符 (Filtering Operators)、组合操作符 (Combining Operators)、工具操作符 (Utility&#x2F;Side-Effect Operators)。</p>
<h3 id="创建操作符-Creation-Operators"><a href="#创建操作符-Creation-Operators" class="headerlink" title="创建操作符 (Creation Operators)"></a>创建操作符 (Creation Operators)</h3><ul>
<li><code>just(T...)</code>: 从给定的元素创建一个 Flux 或 Mono。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Mono.just(<span class="string">&quot;mono&quot;</span>).subscribe(data -&gt; System.out.println(<span class="string">&quot;mono: &quot;</span> + data));</span><br><span class="line">Flux.just(<span class="string">&quot;flux-1&quot;</span>, <span class="string">&quot;flux-2&quot;</span>).subscribe(data -&gt; System.out.println(<span class="string">&quot;flux: &quot;</span> + data))</span><br></pre></td></tr></table></figure>
<ul>
<li><code>generate()</code>：通过同步和逐一的方式来产生Flux序列。序列的产生是通过调用所提供的的SynchronousSink对象的next()，complete()和error(Throwable)方法来完成的。逐一生成的含义是在具体的生成逻辑中，next()方法只能最多被调用一次。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; flux = Flux.generate(</span><br><span class="line">       () -&gt; <span class="number">0</span>,</span><br><span class="line">       (state, sink) -&gt; &#123;</span><br><span class="line">          sink.next(<span class="string">&quot;3 x &quot;</span> + state + <span class="string">&quot; = &quot;</span> + <span class="number">3</span>*state);</span><br><span class="line">          <span class="keyword">if</span> (state == <span class="number">10</span>) sink.complete();</span><br><span class="line">          <span class="keyword">return</span> state + <span class="number">1</span>;</span><br><span class="line">       &#125;, (state) -&gt; System.out.println(<span class="string">&quot;state: &quot;</span> + state));</span><br><span class="line">flux.subscribe(data -&gt; System.out.println(<span class="string">&quot;data &quot;</span> + data));</span><br></pre></td></tr></table></figure>

<ul>
<li><code>create()</code>：create 是一种更高级的编程方式创建 Flux 的形式，它适合每轮多次发出，甚至来自多个线程。它暴露了一个 FluxSink 及其 next，error 和 complete 方法。与 generate 相反，它没有基于状态的形式。但是，它可以在回调中触发多线程事件。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; bridge = Flux.create(sink -&gt; &#123;</span><br><span class="line">  myMessageProcessor.register(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MyMessageListener</span>&lt;String&gt;() &#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(List&lt;String&gt; messages)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(String s : messages) &#123;</span><br><span class="line">          sink.next(s); </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  sink.onRequest(n -&gt; &#123;</span><br><span class="line">    List&lt;String&gt; messages = myMessageProcessor.getHistory(n); </span><br><span class="line">    <span class="keyword">for</span>(String s : message) &#123;</span><br><span class="line">      sink.next(s); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>defer()</code>：延迟捕获或创建序列对象。它会在每次对生成的 Flux&#x2F;Mono 进行订阅时懒惰地提供一个发布者，因此实际的源实例化被推迟到每次订阅时，并且提供者可以创建一个订阅者特定的实例。<br><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_defer.png"></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mono.defer(() -&gt; Mono.just(UUID.randomUUID())).subscribe(x -&gt; System.out.println(x));</span><br></pre></td></tr></table></figure>
<ul>
<li><code>fromIterable(Iterable&lt;T&gt;)/fromArray(T[])</code>: 从 Iterable (如 List, Set) 创建一个 Flux。<br><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_fromIterable.png"></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; flux = Flux.fromIterable(Arrays.asList(<span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;purple&quot;</span>));             </span><br><span class="line">flux.subscribe(System.out::println);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>fromRunnable(Runnable) / fromCallable(Callable&lt;T&gt;)</code>: 将命令式代码转换为 Mono，并在订阅时执行。<br><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_fromCallable.png"></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mono.fromCallable(() -&gt; UUID.randomUUID()).subscribe(x -&gt; System.out.println(x));</span><br></pre></td></tr></table></figure>
<ul>
<li><code>fromSupplier()</code>：它与 defer() 类似，用于延迟创建类似 Mono 的序列对象。但不同之处在于，它可以自动将提供的数据转换为 Mono 格式。它创建一个 Mono 对象，并使用提供的提供者生成其值，如果提供者解析为 null，则生成的 Mono 对象为空。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mono.fromSupplier(() -&gt; UUID.randomUUID()).subscribe(x -&gt; System.out.println(x));</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>range()</code>: 创建一个整数序列的 Flux。</p>
</li>
<li><p><code>empty()/defaultIfEmpty()</code>: 创建一个立即完成但没有任何元素的 Flux 或 Mono。<br><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_defaultEmpty.png"></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mono.empty().defaultIfEmpty(<span class="string">&quot;defaultValue&quot;</span>).subscribe(System.out::println);</span><br></pre></td></tr></table></figure>

<h3 id="转换操作符-Transformation-Operators"><a href="#转换操作符-Transformation-Operators" class="headerlink" title="转换操作符 (Transformation Operators)"></a>转换操作符 (Transformation Operators)</h3><ul>
<li><code>map(Function&lt;T, V&gt;)</code>: 同步地将上游的每个元素映射为下游的一个新元素。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;Integer&gt; flux = Flux.just(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">       .map(data -&gt; Integer.parseInt(data));</span><br><span class="line">flux.subscribe(data -&gt; System.out.println(<span class="string">&quot;data &quot;</span> + data));</span><br></pre></td></tr></table></figure>
<ul>
<li><code>flatMap(Function&lt;T, Publisher&lt;V&gt;&gt;)</code>: 异步地将每个元素映射为一个新的 Publisher（Mono 或 Flux），并将所有内部流合并为一个扁平的下游流。这是响应式编程中最强大的操作符之一。<br><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_flatMap.png"></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;Integer&gt; flux = Flux.just(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>)</span><br><span class="line">       .flatMap(data -&gt; Mono.just(Integer.parseInt(data)));</span><br><span class="line">flux.subscribe(data -&gt; System.out.println(<span class="string">&quot;data &quot;</span> + data));</span><br></pre></td></tr></table></figure>

<ul>
<li><code>buffer(int maxSize) / window(int maxSize)</code>: 将元素收集到 List (buffer) 或一个新的 Flux (window) 中，然后发射这些集合。</li>
<li><code>cast(Class&lt;V&gt; clazz)</code>: 将流中的元素转换为指定的类型。</li>
</ul>
<h3 id="过滤操作符-Filtering-Operators"><a href="#过滤操作符-Filtering-Operators" class="headerlink" title="过滤操作符 (Filtering Operators)"></a>过滤操作符 (Filtering Operators)</h3><ul>
<li><code>filter(Predicate&lt;T&gt;)</code>: 只允许满足条件的元素通过。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;Integer&gt; flux = Flux.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span></span><br><span class="line">       .filter(data -&gt; data != <span class="number">4</span>);</span><br><span class="line">flux.subscribe(data -&gt; System.out.println(<span class="string">&quot;data &quot;</span> + data));)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>take(long n)</code>: 只获取前 N 个元素。</li>
<li><code>skip(long n)</code>: 跳过前 N 个元素。</li>
<li><code>distinct() / distinctUntilChanged()</code>: 过滤掉重复的元素。<br><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_distinct.png"></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;String&gt; flux =Flux.just(<span class="string">&quot;blue&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;purple&quot;</span>)</span><br><span class="line">       .distinct();</span><br><span class="line">flux.subscribe(System.out::println);</span><br></pre></td></tr></table></figure>

<h3 id="组合操作符-Combining-Operators"><a href="#组合操作符-Combining-Operators" class="headerlink" title="组合操作符 (Combining Operators)"></a>组合操作符 (Combining Operators)</h3><ul>
<li><code>merge(Publisher&lt;T&gt;... principals)</code>: 以交错的方式合并多个 Publisher 的输出。<br><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_merge.png"></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;Integer&gt; evenNumbers = Flux</span><br><span class="line">			.range(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">			.filter(x -&gt; x % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">Flux&lt;String&gt; oddNumbers = Flux</span><br><span class="line">			.range(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">			.filter(x -&gt; x % <span class="number">2</span> &gt; <span class="number">0</span>)</span><br><span class="line">			.map(x -&gt; x.toString().concat(<span class="string">&quot;: n&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="type">var</span> <span class="variable">flux1</span> <span class="operator">=</span> Flux.merge(evenNumbers, oddNumbers);</span><br><span class="line">flux1.subscribe(x -&gt; System.out.println(x));</span><br></pre></td></tr></table></figure>
<ul>
<li><code>zip(Publisher&lt;T&gt; p1, Publisher&lt;V&gt; p2)</code>: 将两个源 Publisher 按顺序发射的元素配对组合成一个新的元素（如 Tuple2）。<br><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_zip.png"></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;Integer&gt; evenNumbers = Flux</span><br><span class="line">			.range(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">			.filter(x -&gt; x % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">Flux&lt;Integer&gt; oddNumbers = Flux</span><br><span class="line">			.range(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">			.filter(x -&gt; x % <span class="number">2</span> &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">Flux&lt;Tuple2&lt;Integer, Integer&gt;&gt; fluxOfIntegers = Flux.zip(evenNumbers, oddNumbers);</span><br><span class="line">fluxOfIntegers.subscribe(x -&gt; System.out.println(x));</span><br><span class="line"></span><br><span class="line">Flux&lt;Tuple2&lt;Integer, Integer&gt;&gt; flux = evenNumbers.zipWith(oddNumbers);</span><br><span class="line">flux.subscribe(x -&gt; System.out.println(x));</span><br></pre></td></tr></table></figure>
<ul>
<li><code>concat()/concatMap()</code>：将提供的所有源连接成一个可迭代对象，并将源发出的元素向下游转发。concat是通过依次订阅第一个源，然后等待其完成再订阅下一个源来实现的，依此类推，直到最后一个源完成。任何错误都会立即中断序列并向下游转发，它会返回一个新的 Flux，该 Flux 连接了所有源序列。<br><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_concat.png"></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;Integer&gt; evenNumbers = Flux</span><br><span class="line">			.range(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">			.filter(x -&gt; x % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">Flux&lt;Integer&gt; oddNumbers = Flux</span><br><span class="line">			.range(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">			.filter(x -&gt; x % <span class="number">2</span> &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">Flux&lt;Integer&gt; fluxOfIntegers = Flux.concat(evenNumbers, oddNumbers);</span><br><span class="line">fluxOfIntegers.subscribe(x -&gt; System.out.println(x));</span><br><span class="line"></span><br><span class="line">Flux&lt;String&gt; mergedFlux = Flux.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">	.concatMap(it -&gt; Mono.just(it.toString().concat(<span class="string">&quot;: n&quot;</span>)));</span><br><span class="line"></span><br><span class="line">mergedFlux.subscribe(x -&gt; System.out.println(x));</span><br></pre></td></tr></table></figure>
<ul>
<li><code>then()/thenEmpty()</code>：不关心发布者输出了哪些元素，而只关心它何时完成发布的情况。因此，它会接收一个现有的发布者，丢弃它所有的元素，然后传播完成信号或错误信号。如果我们把任何 Mono 作为 then() 的参数传递，它会将该 Mono 作为输出传递。<br><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_then.png"></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Mono&lt;Void&gt; then = Flux.just(<span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>, <span class="string">&quot;red&quot;</span>)</span><br><span class="line">		  .then(Mono.just(<span class="string">&quot;Orange&quot;</span>))</span><br><span class="line">		  .thenEmpty(Mono.empty());</span><br><span class="line">then.subscribe();</span><br></pre></td></tr></table></figure>

<h3 id="工具操作符-Utility-Side-Effect-Operators"><a href="#工具操作符-Utility-Side-Effect-Operators" class="headerlink" title="工具操作符 (Utility&#x2F;Side-Effect Operators)"></a>工具操作符 (Utility&#x2F;Side-Effect Operators)</h3><ul>
<li><code>log()</code>: 记录所有响应式信号 (onNext, onError, onComplete, onSubscribe, request) 到日志。</li>
<li><code>doOnNext(...), doOnError(...), doOnComplete(...)</code>: 注册回调函数以观察特定信号并执行Side-Effect操作。<br><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_doOnNext.png"></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Flux&lt;Integer&gt; flux = Flux.just(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>)</span><br><span class="line">       .map(data -&gt; Integer.parseInt(data));</span><br><span class="line">flux.subscribe(data -&gt; System.out.println(<span class="string">&quot;data &quot;</span> + data));</span><br></pre></td></tr></table></figure>
<ul>
<li><code>subscribeOn(Scheduler s)</code>: 指定上游源执行的调度器（线程池）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scheduler</span> <span class="variable">s</span> <span class="operator">=</span> Schedulers.newParallel(<span class="string">&quot;parallel-scheduler&quot;</span>, <span class="number">4</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Flux&lt;String&gt; flux = Flux</span><br><span class="line">    .range(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    .map(i -&gt; <span class="number">10</span> + i)  </span><br><span class="line">    .subscribeOn(s)  </span><br><span class="line">    .map(i -&gt; <span class="string">&quot;value &quot;</span> + i);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; flux.subscribe(System.out::println));  </span><br></pre></td></tr></table></figure>
<ul>
<li><code>publishOn(Scheduler s)</code>: 指定下游操作符执行的调度器。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Scheduler</span> <span class="variable">s</span> <span class="operator">=</span> Schedulers.newParallel(<span class="string">&quot;parallel-scheduler&quot;</span>, <span class="number">4</span>); </span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Flux&lt;String&gt; flux = Flux</span><br><span class="line">    .range(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">    .map(i -&gt; <span class="number">10</span> + i)  </span><br><span class="line">    .publishOn(s)  </span><br><span class="line">    .map(i -&gt; <span class="string">&quot;value &quot;</span> + i);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; flux.subscribe(System.out::println));  </span><br></pre></td></tr></table></figure>
<ul>
<li><code>block() / blockFirst() / blockLast()</code>: 阻塞当前线程直到流完成或发出元素（应谨慎使用，主要用于测试或非响应式边界）。<br><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_block.png"></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> Mono.just(<span class="string">&quot;Value&quot;</span>)</span><br><span class="line">             .block();</span><br><span class="line">System.out.println(value);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>switchIfEmpty()</code>：如果序列完成时没有任何数据，它会切换到备用发布者。<br><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_switchIfEmpty.png"></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Mono&lt;String&gt; defaultMono = Mono.just(<span class="string">&quot;defaultString&quot;</span>);</span><br><span class="line">Mono&lt;Object&gt; mono = Mono.empty().switchIfEmpty(defaultMono);</span><br><span class="line">mono.subscribe(System.out::println);</span><br></pre></td></tr></table></figure>
<ul>
<li><code>handle()</code>：用于创建自定义处理器。handle 方法可以用于自定义流的处理逻辑，与 map 方法重新映射、生成新的流不同，handle 方法用于消费元素，可以重新定义流。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">alphabet</span><span class="params">(<span class="type">int</span> letterNumber)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (letterNumber &lt; <span class="number">1</span> || letterNumber &gt; <span class="number">26</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="type">int</span> <span class="variable">letterIndexAscii</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span> + letterNumber - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;&quot;</span> + (<span class="type">char</span>) letterIndexAscii;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">operatorTest</span><span class="params">()</span> &#123;</span><br><span class="line">  Flux&lt;String&gt; alphabet = Flux.just(-<span class="number">1</span>, <span class="number">30</span>, <span class="number">13</span>, <span class="number">9</span>, <span class="number">20</span>)</span><br><span class="line">      .handle((i, sink) -&gt; &#123;</span><br><span class="line">          <span class="type">String</span> <span class="variable">letter</span> <span class="operator">=</span> alphabet(i);</span><br><span class="line">          <span class="keyword">if</span> (letter != <span class="literal">null</span>) sink.next(letter);</span><br><span class="line">      &#125;)</span><br><span class="line">      .filter(data -&gt; &#123;</span><br><span class="line">          <span class="type">boolean</span> <span class="variable">isTrue</span> <span class="operator">=</span> !data.equals(<span class="string">&quot;M&quot;</span>);</span><br><span class="line">          System.out.println(isTrue);</span><br><span class="line">          <span class="keyword">return</span> isTrue;</span><br><span class="line">      &#125;)</span><br><span class="line">      .map(ch -&gt; ch+<span class="string">&quot;-Data&quot;</span>)</span><br><span class="line">      .doOnNext(conData -&gt; System.out.println(conData))</span><br><span class="line">      .flatMap(conData -&gt; Mono.just(conData));</span><br><span class="line"></span><br><span class="line">  alphabet.subscribe(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>在 Project Reactor 中，处理错误是响应式编程的关键部分，流一旦发生错误就会终止 (onError 信号)，因此需要使用特定的操作符来截取错误并决定后续行为。</p>
<h3 id="错误恢复操作符-Recovery-Operators-："><a href="#错误恢复操作符-Recovery-Operators-：" class="headerlink" title="错误恢复操作符 (Recovery Operators)："></a>错误恢复操作符 (Recovery Operators)：</h3><p><strong>onErrorReturn(T fallbackValue)</strong>：当发生错误时，抛出一个默认值，然后正常完成 (onComplete)。适用于需要提供一个默认值作为简单回退逻辑的情况，例如：服务不可用时返回一个缓存的默认值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    .map(i -&gt; <span class="number">10</span> / i) <span class="comment">// 当 i 为 0 时抛出 ArithmeticException</span></span><br><span class="line">    .onErrorReturn(-<span class="number">1</span>) <span class="comment">// 捕获错误并返回 -1</span></span><br><span class="line">    .subscribe(System.out::println); </span><br><span class="line"><span class="comment">// 输出: 10, -1</span></span><br></pre></td></tr></table></figure>

<p><strong><code>onErrorResume(Function&lt;Throwable, ? extends Publisher&lt;? extends T&gt;&gt; fallbackSupplier)</code></strong>：当发生错误时，切换到一个新的备用 Publisher (如另一个 Mono 或 Flux) 来继续数据流。适用于需要执行更复杂的备用逻辑、调用另一个服务或根据错误类型动态生成备用数据流的情况。</p>
<p><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_onErrorResume.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="string">&quot;user&quot;</span>, <span class="string">&quot;unknown&quot;</span>)</span><br><span class="line">    .flatMap(user -&gt; callExternalService(user) <span class="comment">// 模拟外部服务调用</span></span><br><span class="line">        .onErrorResume(e -&gt; getFromCache(user)) <span class="comment">// 外部服务失败时从缓存获取</span></span><br><span class="line">    )</span><br><span class="line">    .subscribe(System.out::println);</span><br></pre></td></tr></table></figure>

<p><strong>onErrorComplete()</strong>：捕获错误信号，并将其转换为正常的完成信号 (onComplete)。适用于成功的结果而可以完全忽略错误的场景。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>)</span><br><span class="line">    .map(<span class="built_in">this</span>::doSomethingDangerousOn30)</span><br><span class="line">    .onErrorComplete();</span><br></pre></td></tr></table></figure>

<p><strong>doFinally()</strong>：最终执行，类似try-finally。 doFinally 在终止时无论是 onComplete、<code>onError</code>还是取消都会被执行， 并且能够判断是什么类型的终止事件。</p>
<p><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_doFinally.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="string">&quot;foo&quot;</span>, <span class="string">&quot;bar&quot;</span>)</span><br><span class="line">    .doOnSubscribe(s -&gt; stats.startTimer())</span><br><span class="line">    .doFinally(type -&gt; &#123; </span><br><span class="line">        stats.stopTimerAndRecordTiming();</span><br><span class="line">        <span class="keyword">if</span> (type == SignalType.CANCEL) </span><br><span class="line">          statsCancel.increment();</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p><strong><code>onErrorContinue(BiConsumer&lt;Throwable, Object&gt; consumer)</code></strong>：允许在处理 Flux 流中的元素时，跳过导致错误的元素，记录错误信息，然后继续处理流中的下一个元素。主要用于 Flux 中，当某个元素处理失败不应中断整个流时。注意，必须将此操作符放在可能抛出异常的操作符（例如 map）之前。</p>
<h3 id="错误转换操作符"><a href="#错误转换操作符" class="headerlink" title="错误转换操作符"></a>错误转换操作符</h3><p><strong><code>onErrorMap(Function&lt;Throwable, Throwable&gt; mapper)</code></strong>：将捕获到的异常转换为另一种自定义的异常类型，并重新抛出（向下游传递新的 onError 信号）。适用于将底层技术异常（如 IOException）封装为业务异常（如 UserServiceException），以便下游更好地理解和处理。</p>
<p><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_onErrorMap.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="string">&quot;timeout1&quot;</span>)</span><br><span class="line">    .flatMap(k -&gt; callExternalService(k))</span><br><span class="line">    .onErrorMap(original -&gt; <span class="keyword">new</span> <span class="title class_">BusinessException</span>(<span class="string">&quot;oops, SLA exceeded&quot;</span>, original));</span><br></pre></td></tr></table></figure>

<p><strong><code>doOnError(Consumer&lt;Throwable&gt; consumer)</code></strong>：注册一个回调函数，用于观察（记录日志、监控指标等）错误信号，但不会改变或消耗错误信号，错误会继续向下游传播。仅用于执行副作用操作，如日志记录或指标收集。</p>
<p><img src="/images/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80_doOnError.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Flux.just(<span class="string">&quot;unknown&quot;</span>)</span><br><span class="line">    .flatMap(k -&gt; callExternalService(k).doOnError(e -&gt; &#123;</span><br><span class="line">            failureStat.increment();</span><br><span class="line">            log(<span class="string">&quot;uh oh, falling back, service failed for key &quot;</span> + k); </span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<h3 id="重试操作符-Retry-Operators"><a href="#重试操作符-Retry-Operators" class="headerlink" title="重试操作符 (Retry Operators)"></a>重试操作符 (Retry Operators)</h3><p><strong>retry() 或 retry(long maxRetries)</strong>：发生错误时，重新订阅上游的 Publisher，尝试再次执行整个流。原始流会终止，但 retry 会创建一个新的订阅。适用于处理瞬时错误（例如网络波动、临时服务不可用）的情况。应设置最大重试次数以避免无限循环。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Flux.interval(Duration.ofMillis(<span class="number">250</span>))</span><br><span class="line">    .map(input -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (input &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="string">&quot;tick &quot;</span> + input;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;boom&quot;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    .elapsed() </span><br><span class="line">    .retry(<span class="number">1</span>)</span><br><span class="line">    .subscribe(System.out::println, System.err::println);</span><br></pre></td></tr></table></figure>
<p><strong><code>retryWhen(Function&lt;Flux&lt;Throwable&gt;, ? extends Publisher&lt;?&gt;&gt;)</code></strong>：: 提供基于异常类型和重试次数的更精细的重试逻辑控制，支持指数退避等高级策略。 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Flux.&lt;String&gt;error(<span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>()) </span><br><span class="line">    .doOnError(System.out::println) </span><br><span class="line">    .retryWhen(companion -&gt; companion.take(<span class="number">3</span>));</span><br></pre></td></tr></table></figure>

<h2 id="线程和调度器"><a href="#线程和调度器" class="headerlink" title="线程和调度器"></a>线程和调度器</h2><p>响应式流（Flux和Mono）本质上是关于数据流和信号回调的，而不是并发模型。默认情况下，操作符会继续在执行前一个操作符的线程中工作。即，除非指定，否则源操作符本身运行在调用了 subscribe() 的 Thread 上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">  <span class="keyword">final</span> Flux&lt;Object&gt; flux = Flux.fromArray(Arrays.asList(<span class="string">&quot;hello &quot;</span>, <span class="string">&quot;reactive &quot;</span>).toArray());</span><br><span class="line"></span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; flux</span><br><span class="line">      .map(msg -&gt; msg + <span class="string">&quot;thread &quot;</span>)</span><br><span class="line">      .subscribe(v -&gt;</span><br><span class="line">          System.out.println(v + Thread.currentThread().getName())</span><br><span class="line">      )</span><br><span class="line">  );</span><br><span class="line">  t.start();</span><br><span class="line">  t.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Reactor的 <strong>调度器（Scheduler）</strong> 是控制线程执行的关键机制，它类似于 ExecutorService，用于将不同的操作分派到特定的线程或线程池。Schedulers 类提供了一系列静态方法来访问不同类型的内置调度器，它们抽象了底层的线程池管理。Reactor主要的内置调度器类型包括：</p>
<ul>
<li>Schedulers.immediate(): 在当前线程中立即执行任务。</li>
<li>Schedulers.single(): 使用一个单一的、可重用的后台线程。</li>
<li>Schedulers.parallel(): 使用一个固定大小的线程池，其大小通常等于 CPU 核心数，适用于并行计算任务。</li>
<li>Schedulers.boundedElastic(): 这是一个有界的弹性线程池，按需动态创建线程，但有数量上限，适用于执行阻塞 I&#x2F;O 操作（如数据库调用、网络请求）。它是已弃用的 Schedulers.elastic() 的替代品。</li>
</ul>
<p>除了上面内置的调度器，也可以使用现有的 ExecutorService 创建自定义调度器。Project Reactor 提供了两个核心操作符来控制流的执行线程上下文：</p>
<ul>
<li><strong>subscribeOn(Scheduler)</strong>：把订阅动作（Subscriber.onSubscribe 的创建、链路建立、上游 request 的初次调用等）移动到指定 Scheduler。当在上游调用 subscribe 时，subscribeOn 会 schedule 一个 Runnable 去执行真正的 subscribe 操作（即把 subscription 的建立放到其他线程），因此上游的同步产生&#x2F;拉取代码会在该 Scheduler 的线程上运行。它影响整个操作链的源头（upstream）和下游（downstream），决定了数据生成和初始订阅发生的线程。无论 subscribeOn 放在操作链的哪个位置，它都会改变整个流的根执行上下文。</li>
<li><strong>publishOn(Scheduler)</strong>：在数据流中的某处建立异步边界——把从这个 operator 向下游发送的信号切换到指定 Scheduler 的线程。publishOn 用一个内部队列把上游发来的 onNext&#x2F;onError&#x2F;onComplete 等事件缓存起来，然后在 Worker 的线程中做 drain（取出并调用下游的 onNext&#x2F;onComplete&#x2F;onError）。因此，publishOn 会序列化并且切换信号执行线程。它只影响其 <strong>下游（downstream）</strong> 的操作符（从它出现的位置到下一个 publishOn 或流结束）。会在流中引入一个异步边界，将后续的处理切换到指定的调度器上。这对于在不同阶段（例如，将 I&#x2F;O 操作与 CPU 密集型操作分开）使用不同的线程池非常有用。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Flux.range(<span class="number">1</span>, <span class="number">5</span>)</span><br><span class="line">    .map(i -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;map1 thread: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribeOn(Schedulers.boundedElastic()) <span class="comment">// 订阅在 boundedElastic 线程</span></span><br><span class="line">    .map(i -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;map2 thread: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> i * <span class="number">10</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    .publishOn(Schedulers.parallel()) <span class="comment">// 从这里开始把信号转到 parallel 线程</span></span><br><span class="line">    .map(i -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;map3 thread: &quot;</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe(i -&gt; System.out.println(<span class="string">&quot;onNext thread: &quot;</span> + Thread.currentThread().getName() + <span class="string">&quot; =&gt; &quot;</span> + i));</span><br></pre></td></tr></table></figure>
  </div>
</article>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
        
          <li><a href="/">首页</a></li>
        
          <li><a href="/archives/">归档</a></li>
        
      </ul>
    </div>

    
    
      <div id="toc-footer" style="display: none">
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Project-Reactor%E5%9F%BA%E7%A1%80"><span class="toc-number">2.</span> <span class="toc-text">Project Reactor基础</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Flux%E4%B8%8EMono%E7%BB%84%E4%BB%B6"><span class="toc-number">3.</span> <span class="toc-text">Flux与Mono组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Backpressure%E5%A4%84%E7%90%86%EF%BC%9A"><span class="toc-number">4.</span> <span class="toc-text">Backpressure处理：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">5.</span> <span class="toc-text">常用功能操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%93%8D%E4%BD%9C%E7%AC%A6-Creation-Operators"><span class="toc-number">5.1.</span> <span class="toc-text">创建操作符 (Creation Operators)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%93%8D%E4%BD%9C%E7%AC%A6-Transformation-Operators"><span class="toc-number">5.2.</span> <span class="toc-text">转换操作符 (Transformation Operators)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E6%93%8D%E4%BD%9C%E7%AC%A6-Filtering-Operators"><span class="toc-number">5.3.</span> <span class="toc-text">过滤操作符 (Filtering Operators)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%93%8D%E4%BD%9C%E7%AC%A6-Combining-Operators"><span class="toc-number">5.4.</span> <span class="toc-text">组合操作符 (Combining Operators)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7%E6%93%8D%E4%BD%9C%E7%AC%A6-Utility-Side-Effect-Operators"><span class="toc-number">5.5.</span> <span class="toc-text">工具操作符 (Utility&#x2F;Side-Effect Operators)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text">错误处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E6%81%A2%E5%A4%8D%E6%93%8D%E4%BD%9C%E7%AC%A6-Recovery-Operators-%EF%BC%9A"><span class="toc-number">6.1.</span> <span class="toc-text">错误恢复操作符 (Recovery Operators)：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E8%BD%AC%E6%8D%A2%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">6.2.</span> <span class="toc-text">错误转换操作符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%AF%95%E6%93%8D%E4%BD%9C%E7%AC%A6-Retry-Operators"><span class="toc-number">6.3.</span> <span class="toc-text">重试操作符 (Retry Operators)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">7.</span> <span class="toc-text">线程和调度器</span></a></li></ol>
      </div>
    

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=http://example.com/2025/08/19/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=http://example.com/2025/08/19/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80/&text=Java 响应式编程-Project Reactor基础"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=http://example.com/2025/08/19/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80/&title=Java 响应式编程-Project Reactor基础"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=http://example.com/2025/08/19/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80/&is_video=false&description=Java 响应式编程-Project Reactor基础"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Java 响应式编程-Project Reactor基础&body=Check out this article: http://example.com/2025/08/19/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=http://example.com/2025/08/19/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80/&title=Java 响应式编程-Project Reactor基础"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=http://example.com/2025/08/19/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80/&title=Java 响应式编程-Project Reactor基础"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=http://example.com/2025/08/19/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80/&title=Java 响应式编程-Project Reactor基础"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=http://example.com/2025/08/19/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80/&title=Java 响应式编程-Project Reactor基础"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=http://example.com/2025/08/19/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80/&name=Java 响应式编程-Project Reactor基础&description=&lt;h2 id=&#34;概述&#34;&gt;&lt;a href=&#34;#概述&#34; class=&#34;headerlink&#34; title=&#34;概述&#34;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;在上篇中介绍了响应式编程基础，其中提到在JDK中只提供了接口规范，并没有提供丰富的操作算子。而 Project Reactor就是基于Reactive Streams规范的具体实现。Project Reactor是由 Spring 团队维护的，与 Spring 生态系统（特别是 Spring WebFlux）无缝集成，其专注于高性能的服务器端应用，特别强调与函数式编程和响应式流规范的集成。&lt;/p&gt;"><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=http://example.com/2025/08/19/Java-%E5%93%8D%E5%BA%94%E5%BC%8F-ProjectReactor%E5%9F%BA%E7%A1%80/&t=Java 响应式编程-Project Reactor基础"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        
          <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2023-2025
    ares
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->


 
  <link
    rel="preload"
    href="/lib/font-awesome/css/all.min.css"
    as="style"
    onload="this.onload=null;this.rel='stylesheet'"
  />
  <noscript
    ><link
      rel="stylesheet"
      href="/lib/font-awesome/css/all.min.css"
  /></noscript>


    <!-- jquery -->

  
<script src="/lib/jquery/jquery.min.js"></script>





<!-- clipboard -->

  
    
<script src="/lib/clipboard/clipboard.min.js"></script>

  
  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板！\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功！");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
